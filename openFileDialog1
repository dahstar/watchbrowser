<start>ai-test
hi all
<end>ai-test
<start>ai-code
welcome
test
all 
code
<end>ai-code
<start>ai-topcoder c++
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}
<end>ai-topcoder c++
<start>ai-hiall
hi all
<end>ai-hiall
<start>writeai-dawood
hi dawood abbaspour
<end>writeai-dawood
<start>ai-getstring
#include<iostream>
using namespace std;
int main()
{
    string s;
    cin>>s;
    cout<<"="<<s;
    return 0;
}
<end>ai-getstring
<start>ai-char to integer
int ia = a - '0';
<end>ai-char to integer
<start>ai-WritingWords type a word on her old cell phone with one keye'    'A' 
#include<iostream>
#include<string>
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}

<end>ai-WritingWords type a word on her old cell phone with one keye'    'A' 
<start>ai-count character in string
#include<algorithm>

#include<iostream>
#include<string>
#include<vector>
using namespace std;
class FoxAndGame
{
public:
    FoxAndGame()
    {
    }
    	int countStars(vector<string> result)
    {
        int count1=result.size();
        int counto=0;
        for(int i=0;i<count1;i++)
            counto+=count(result[i].begin(), result[i].end(),  'o');
        return counto;        

    }
};

<end>ai-count character in string
<start>ai-string middle to left
#include <string>
#include <algorithm>

using namespace std;

class InsideOut
{
public:
	string unscramble(string line);
};

string InsideOut::unscramble(string line)
{
	size_t lnLnth = line.length();

	string p1 = string(line, 0, line.length() / 2);

	string p2 = string(line, (line.length() / 2), line.length()/2);

	reverse(p1.begin(), p1.end());
	reverse(p2.begin(), p2.end());

	return p1+p2;
}


int main()
{
	InsideOut ins;

	string l = "RUT OWT SNEH HCNERF EERHTEGDIRTRAP A DNA  SEVODELT";

	string out = ins.unscramble(l);
	return 0;
	<end>string middle to left
	<start>ai-game stand or jump kiloman topcoder
	//https://community.topcoder.com/stat?c=problem_statement&pm=2268
	#include <vector>
#include<string>

using namespace std;

class KiloMan {
public:
	int hitsTaken(vector <int> pattern, string jumps) {
		int hits = 0;
		for (int i = 0, ilen = pattern.size(); i < ilen; ++i) {
			if ((pattern[i] == 1 || pattern[i] == 2) && jumps[i] == 'S')
				++hits;
			else if (pattern[i] > 2 && jumps[i] == 'J')
				++hits;
		}
		return hits;
	}
};
<end>ai-game stand or jump kiloman topcoder
<start>ai-topcoder c++  array integer
using namespace std;
class RosePetals
{
public:
    RosePetals()
    {
    }
    int getScore(vector<int> dice)
    {
        int count=0;
        for(int i=0;i<dice.size();i++)
        {
            if(dice[i]==3)
                count+=2;
            if (dice[i]==5)
                count+=4;
        } 
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}

<end>ai-topcoder c++  array integer
<start>D:\dawood\topcoder\typingdistabce.cpp
#include<iostream>
#include<string>
#include <stdlib.h>
using namespace std;
class TypingDistance
{
public:
    WritingWords()
    {
    }
    int getdis(string board,char a,char b)
    {
        int a1=0;int b1=0;
        for(int i=0;i<board.length();i++)
        {if(board[i]==a)
            a1=i;
            if(board[i]==b)
                b1=i;
        }
        return abs(a1-b1);
    }
    	int minDistance(string keyboard, string word)
    {
        int count=0;
        for(int i=0;i<word.length()-1;i++)
            count+= getdis(keyboard,word[i],word[i+1]);
        return count;

    }
};
int main()
{
    TypingDistance a;
    cout<<a.minDistance("qwertyuiop","potter");
    
    return 0;
}

<end>D:\dawood\topcoder\typingdistabce.cpp
<start>ai-string char distance   typing distance
#include<iostream>
#include<string>
#include <stdlib.h>
using namespace std;
class TypingDistance
{
public:
    WritingWords()
    {
    }
    int getdis(string board,char a,char b)
    {
        int a1=0;int b1=0;
        for(int i=0;i<board.length();i++)
        {if(board[i]==a)
            a1=i;
            if(board[i]==b)
                b1=i;
        }
        return abs(a1-b1);
    }
    	int minDistance(string keyboard, string word)
    {
        int count=0;
        for(int i=0;i<word.length()-1;i++)
            count+= getdis(keyboard,word[i],word[i+1]);
        return count;

    }
};
int main()
{
    TypingDistance a;
    cout<<a.minDistance("qwertyuiop","potter");
    
    return 0;
}

<end>ai-string char distance   typing distance
<start>D:\dawood\topcoder\letterstring.cpp
#include<iostream>
#include<string>
#include <stdlib.h>
#include<vector>
using namespace std;
class LetterStrings
{
public:
    LetterStrings()
    {
    }
    int getlength(string board)
    {
        int count=0;
        for(int i=0;i<board.length();i++)
            if(board[i]!='-')
            count++;
        return count;
    }
    	int sum(vector<string> s)
    {
        int count=0;
        for(int i=0;i<s.size();i++)
            count+=getlength(s[i]);
        return count;

    }
};
int main()
{
    LetterStrings a;
    cout<<a.sum("-----Abc");
    
    return 0;
}

<end>D:\dawood\topcoder\letterstring.cpp
<start>ai-check string 
#include<iostream>
#include<string>
#include <stdlib.h>
#include<vector>
using namespace std;
class LetterStrings
{
public:
    LetterStrings()
    {
    }
    int getlength(string board)
    {
        int count=0;
        for(int i=0;i<board.length();i++)
            if(board[i]!='-')
            count++;
        return count;
    }
    	int sum(vector<string> s)
    {
        int count=0;
        for(int i=0;i<s.size();i++)
            count+=getlength(s[i]);
        return count;

    }
};
int main()
{
    LetterStrings a;
    cout<<a.sum("-----Abc");
    
    return 0;
}

<end>ai-check string 
<start>ai-array to vector
vector<int> dataVec;

int dataArray[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sizea = sizeof(dataArray) / sizeof(dataArray[0]);
 dataVec(dataArray,dataArray+sizea);

<start>ai-array increasing
#include<vector>
#include<stdlib.h>
using namespace std;
class SkiResortsEasy
{
public:
    SkiResortsEasy()
    {
    }
    	int minCost(vector<int> altitude)
    {
        int count=0;
        for(int i=0;i<altitude.size();-1i++)
            if(altitude[i+1]>altitude[i])
            count+=abs(altitude[i+1]-altitude[i])
    }
};
int main()
{
    vector<int> dataVec;

int dataArray[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
int sizea = sizeof(dataArray) / sizeof(dataArray[0]);
 dataVec(dataArray,dataArray+sizea);

WritingWords a;
    
    cout<<a.write("ABC");
    
    return 0;
}

<end>ai-array increasing
<start>ai-example  setprecession
#include<iostream>
#include<string>
#include<iomanip>
using namespace std;
int main()
{
    float y;int x;float result=0;
    cin>>x>>y;
    if((x+0.5<=y)&&(x%5==0))
        result=(y-x)-0.5;
    else
        result=y;
   
        cout<<fixed<<setprecision( 2) <<result<<endl;
    
        
   
    return 0;
}
<end>ai-example  setprecession
<start>ai-floating point
#include<iomanip>
cout<<fixed<<setprecision( 2) <<result<<endl;
<end>ai-floating point
<start>ai-problem
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
#define FOR(i,a,b) for(int i=a;i<b;++i)
#define REP(i,n) FOR(i,0,n)
#define getmax(a,b) ((a)>(b)?(a):(b))

int main()
{
	int i,a,b;i=0;char d=getmax('b','a');cout<<d<<endl;	;
		REP(i,7);
	cout<<"t";
	return 0;
}
<end>ai-problem
<start>ai-factorial calculate end zero
#include<iostream>
 
using namespace std;
 
int main(){
	int t;
	long long int n;
	cin>>t;
	
 
	while(t>0){
		cin>>n;
		long long int ct = 0;
		for(long long int i=1;i<=n;i*=5){
			ct+= n/i;
		}
		cout<<ct<<endl;
		t--;
	}
	
	return 0;
}

<end>ai-factorial calculate end zero
<start>ai-smallest path
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// A structure to represent a node in adjacency list
struct AdjListNode
{
    int dest;
    int weight;
    struct AdjListNode* next;
};

// A structure to represent an adjacency liat
struct AdjList
{
    struct AdjListNode *head;  // pointer to head node of list
};

// A structure to represent a graph. A graph is an array of adjacency lists.
// Size of array will be V (number of vertices in graph)
struct Graph
{
    int V;
    struct AdjList* array;
};

// A utility function to create a new adjacency list node
struct AdjListNode* newAdjListNode(int dest, int weight)
{
    struct AdjListNode* newNode =
            (struct AdjListNode*) malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// A utility function that creates a graph of V vertices
struct Graph* createGraph(int V)
{
    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));
    graph->V = V;

    // Create an array of adjacency lists.  Size of array will be V
    graph->array = (struct AdjList*) malloc(V * sizeof(struct AdjList));

     // Initialize each adjacency list as empty by making head as NULL
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;

    return graph;
}

// Adds an edge to an undirected graph
void addEdge(struct Graph* graph, int src, int dest, int weight)
{
    // Add an edge from src to dest.  A new node is added to the adjacency
    // list of src.  The node is added at the begining
    struct AdjListNode* newNode = newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

    // Since graph is undirected, add an edge from dest to src also
    newNode = newAdjListNode(src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

// Structure to represent a min heap node
struct MinHeapNode
{
    int  v;
    int dist;
};

// Structure to represent a min heap
struct MinHeap
{
    int size;      // Number of heap nodes present currently
    int capacity;  // Capacity of min heap
    int *pos;     // This is needed for decreaseKey()
    struct MinHeapNode **array;
};

// A utility function to create a new Min Heap Node
struct MinHeapNode* newMinHeapNode(int v, int dist)
{
    struct MinHeapNode* minHeapNode =
           (struct MinHeapNode*) malloc(sizeof(struct MinHeapNode));
    minHeapNode->v = v;
    minHeapNode->dist = dist;
    return minHeapNode;
}

// A utility function to create a Min Heap
struct MinHeap* createMinHeap(int capacity)
{
    struct MinHeap* minHeap =
         (struct MinHeap*) malloc(sizeof(struct MinHeap));
    minHeap->pos = (int *)malloc(capacity * sizeof(int));
    minHeap->size = 0;
    minHeap->capacity = capacity;
    minHeap->array =
         (struct MinHeapNode**) malloc(capacity * sizeof(struct MinHeapNode*));
    return minHeap;
}

// A utility function to swap two nodes of min heap. Needed for min heapify
void swapMinHeapNode(struct MinHeapNode** a, struct MinHeapNode** b)
{
    struct MinHeapNode* t = *a;
    *a = *b;
    *b = t;
}

// A standard function to heapify at given idx
// This function also updates position of nodes when they are swapped.
// Position is needed for decreaseKey()
void minHeapify(struct MinHeap* minHeap, int idx)
{
    int smallest, left, right;
    smallest = idx;
    left = 2 * idx + 1;
    right = 2 * idx + 2;

    if (left < minHeap->size &&
        minHeap->array[left]->dist < minHeap->array[smallest]->dist )
      smallest = left;

    if (right < minHeap->size &&
        minHeap->array[right]->dist < minHeap->array[smallest]->dist )
      smallest = right;

    if (smallest != idx)
    {
        // The nodes to be swapped in min heap
        MinHeapNode *smallestNode = minHeap->array[smallest];
        MinHeapNode *idxNode = minHeap->array[idx];

        // Swap positions
        minHeap->pos[smallestNode->v] = idx;
        minHeap->pos[idxNode->v] = smallest;

        // Swap nodes
        swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);

        minHeapify(minHeap, smallest);
    }
}

// A utility function to check if the given minHeap is ampty or not
int isEmpty(struct MinHeap* minHeap)
{
    return minHeap->size == 0;
}

// Standard function to extract minimum node from heap
struct MinHeapNode* extractMin(struct MinHeap* minHeap)
{
    if (isEmpty(minHeap))
        return NULL;

    // Store the root node
    struct MinHeapNode* root = minHeap->array[0];

    // Replace root node with last node
    struct MinHeapNode* lastNode = minHeap->array[minHeap->size - 1];
    minHeap->array[0] = lastNode;

    // Update position of last node
    minHeap->pos[root->v] = minHeap->size-1;
    minHeap->pos[lastNode->v] = 0;

    // Reduce heap size and heapify root
    --minHeap->size;
    minHeapify(minHeap, 0);

    return root;
}

// Function to decreasy dist value of a given vertex v. This function
// uses pos[] of min heap to get the current index of node in min heap
void decreaseKey(struct MinHeap* minHeap, int v, int dist)
{
    // Get the index of v in  heap array
    int i = minHeap->pos[v];

    // Get the node and update its dist value
    minHeap->array[i]->dist = dist;

    // Travel up while the complete tree is not hepified.
    // This is a O(Logn) loop
    while (i && minHeap->array[i]->dist < minHeap->array[(i - 1) / 2]->dist)
    {
        // Swap this node with its parent
        minHeap->pos[minHeap->array[i]->v] = (i-1)/2;
        minHeap->pos[minHeap->array[(i-1)/2]->v] = i;
        swapMinHeapNode(&minHeap->array[i],  &minHeap->array[(i - 1) / 2]);

        // move to parent index
        i = (i - 1) / 2;
    }
}

// A utility function to check if a given vertex
// 'v' is in min heap or not
bool isInMinHeap(struct MinHeap *minHeap, int v)
{
   if (minHeap->pos[v] < minHeap->size)
     return true;
   return false;
}

// A utility function used to print the solution
void printArr(int dist[], int n)
{
    printf("Vertex   Distance from Source\n");
    for (int i = 0; i < n; ++i)
        printf("%d \t\t %d\n", i, dist[i]);
}

// The main function that calulates distances of shortest paths from src to all
// vertices. It is a O(ELogV) function
void dijkstra(struct Graph* graph, int src)
{
    int V = graph->V;// Get the number of vertices in graph
    int dist[V];      // dist values used to pick minimum weight edge in cut

    // minHeap represents set E
    struct MinHeap* minHeap = createMinHeap(V);

    // Initialize min heap with all vertices. dist value of all vertices 
    for (int v = 0; v < V; ++v)
    {
        dist[v] = INT_MAX;
        minHeap->array[v] = newMinHeapNode(v, dist[v]);
        minHeap->pos[v] = v;
    }

    // Make dist value of src vertex as 0 so that it is extracted first
    minHeap->array[src] = newMinHeapNode(src, dist[src]);
    minHeap->pos[src]   = src;
    dist[src] = 0;
    decreaseKey(minHeap, src, dist[src]);

    // Initially size of min heap is equal to V
    minHeap->size = V;

    // In the followin loop, min heap contains all nodes
    // whose shortest distance is not yet finalized.
    while (!isEmpty(minHeap))
    {
        // Extract the vertex with minimum distance value
        struct MinHeapNode* minHeapNode = extractMin(minHeap);
        int u = minHeapNode->v; // Store the extracted vertex number

        // Traverse through all adjacent vertices of u (the extracted
        // vertex) and update their distance values
        struct AdjListNode* pCrawl = graph->array[u].head;
        while (pCrawl != NULL)
        {
            int v = pCrawl->dest;

            // If shortest distance to v is not finalized yet, and distance to v
            // through u is less than its previously calculated distance
            if (isInMinHeap(minHeap, v) && dist[u] != INT_MAX && 
                                          pCrawl->weight + dist[u] < dist[v])
            {
                dist[v] = dist[u] + pCrawl->weight;

                // update distance value in min heap also
                decreaseKey(minHeap, v, dist[v]);
            }
            pCrawl = pCrawl->next;
        }
    }

    // print the calculated shortest distances
    printArr(dist, V);
}


// Driver program to test above functions
int main()
{
    // create the graph given in above fugure
    int V = 9;
    struct Graph* graph = createGraph(V);
    addEdge(graph, 0, 1, 4);
    addEdge(graph, 0, 7, 8);
    addEdge(graph, 1, 2, 8);
    addEdge(graph, 1, 7, 11);
    addEdge(graph, 2, 3, 7);
    addEdge(graph, 2, 8, 2);
    addEdge(graph, 2, 5, 4);
    addEdge(graph, 3, 4, 9);
    addEdge(graph, 3, 5, 14);
    addEdge(graph, 4, 5, 10);
    addEdge(graph, 5, 6, 2);
    addEdge(graph, 6, 7, 1);
    addEdge(graph, 6, 8, 6);
    addEdge(graph, 7, 8, 7);

    dijkstra(graph, 0);

    return 0;
}

<end>ai-smallest path
<start>ai-shortest smallest path
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include<iostream>
using namespace std;
// A structure to represent a node in adjacency list
struct AdjListNode
{
    int dest;
    int weight;
    struct AdjListNode* next;
};

// A structure to represent an adjacency liat
struct AdjList
{
    struct AdjListNode *head;  // pointer to head node of list
};

// A structure to represent a graph. A graph is an array of adjacency lists.
// Size of array will be V (number of vertices in graph)
struct Graph
{
    int V;
    struct AdjList* array;
};

// A utility function to create a new adjacency list node
struct AdjListNode* newAdjListNode(int dest, int weight)
{
    struct AdjListNode* newNode =
            (struct AdjListNode*) malloc(sizeof(struct AdjListNode));
    newNode->dest = dest;
    newNode->weight = weight;
    newNode->next = NULL;
    return newNode;
}

// A utility function that creates a graph of V vertices
struct Graph* createGraph(int V)
{
    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));
    graph->V = V;

    // Create an array of adjacency lists.  Size of array will be V
    graph->array = (struct AdjList*) malloc(V * sizeof(struct AdjList));

     // Initialize each adjacency list as empty by making head as NULL
    for (int i = 0; i < V; ++i)
        graph->array[i].head = NULL;

    return graph;
}

// Adds an edge to an undirected graph
void addEdge(struct Graph* graph, int src, int dest, int weight)
{
    // Add an edge from src to dest.  A new node is added to the adjacency
    // list of src.  The node is added at the begining
    struct AdjListNode* newNode = newAdjListNode(dest, weight);
    newNode->next = graph->array[src].head;
    graph->array[src].head = newNode;

    // Since graph is undirected, add an edge from dest to src also
    newNode = newAdjListNode(src, weight);
    newNode->next = graph->array[dest].head;
    graph->array[dest].head = newNode;
}

// Structure to represent a min heap node
struct MinHeapNode
{
    int  v;
    int dist;
};

// Structure to represent a min heap
struct MinHeap
{
    int size;      // Number of heap nodes present currently
    int capacity;  // Capacity of min heap
    int *pos;     // This is needed for decreaseKey()
    struct MinHeapNode **array;
};

// A utility function to create a new Min Heap Node
struct MinHeapNode* newMinHeapNode(int v, int dist)
{
    struct MinHeapNode* minHeapNode =
           (struct MinHeapNode*) malloc(sizeof(struct MinHeapNode));
    minHeapNode->v = v;
    minHeapNode->dist = dist;
    return minHeapNode;
}

// A utility function to create a Min Heap
struct MinHeap* createMinHeap(int capacity)
{
    struct MinHeap* minHeap =
         (struct MinHeap*) malloc(sizeof(struct MinHeap));
    minHeap->pos = (int *)malloc(capacity * sizeof(int));
    minHeap->size = 0;
    minHeap->capacity = capacity;
    minHeap->array =
         (struct MinHeapNode**) malloc(capacity * sizeof(struct MinHeapNode*));
    return minHeap;
}

// A utility function to swap two nodes of min heap. Needed for min heapify
void swapMinHeapNode(struct MinHeapNode** a, struct MinHeapNode** b)
{
    struct MinHeapNode* t = *a;
    *a = *b;
    *b = t;
}

// A standard function to heapify at given idx
// This function also updates position of nodes when they are swapped.
// Position is needed for decreaseKey()
void minHeapify(struct MinHeap* minHeap, int idx)
{
    int smallest, left, right;
    smallest = idx;
    left = 2 * idx + 1;
    right = 2 * idx + 2;

    if (left < minHeap->size &&
        minHeap->array[left]->dist < minHeap->array[smallest]->dist )
      smallest = left;

    if (right < minHeap->size &&
        minHeap->array[right]->dist < minHeap->array[smallest]->dist )
      smallest = right;

    if (smallest != idx)
    {
        // The nodes to be swapped in min heap
        MinHeapNode *smallestNode = minHeap->array[smallest];
        MinHeapNode *idxNode = minHeap->array[idx];

        // Swap positions
        minHeap->pos[smallestNode->v] = idx;
        minHeap->pos[idxNode->v] = smallest;

        // Swap nodes
        swapMinHeapNode(&minHeap->array[smallest], &minHeap->array[idx]);

        minHeapify(minHeap, smallest);
    }
}

// A utility function to check if the given minHeap is ampty or not
int isEmpty(struct MinHeap* minHeap)
{
    return minHeap->size == 0;
}

// Standard function to extract minimum node from heap
struct MinHeapNode* extractMin(struct MinHeap* minHeap)
{
    if (isEmpty(minHeap))
        return NULL;

    // Store the root node
    struct MinHeapNode* root = minHeap->array[0];

    // Replace root node with last node
    struct MinHeapNode* lastNode = minHeap->array[minHeap->size - 1];
    minHeap->array[0] = lastNode;

    // Update position of last node
    minHeap->pos[root->v] = minHeap->size-1;
    minHeap->pos[lastNode->v] = 0;

    // Reduce heap size and heapify root
    --minHeap->size;
    minHeapify(minHeap, 0);

    return root;
}

// Function to decreasy dist value of a given vertex v. This function
// uses pos[] of min heap to get the current index of node in min heap
void decreaseKey(struct MinHeap* minHeap, int v, int dist)
{
    // Get the index of v in  heap array
    int i = minHeap->pos[v];

    // Get the node and update its dist value
    minHeap->array[i]->dist = dist;

    // Travel up while the complete tree is not hepified.
    // This is a O(Logn) loop
    while (i && minHeap->array[i]->dist < minHeap->array[(i - 1) / 2]->dist)
    {
        // Swap this node with its parent
        minHeap->pos[minHeap->array[i]->v] = (i-1)/2;
        minHeap->pos[minHeap->array[(i-1)/2]->v] = i;
        swapMinHeapNode(&minHeap->array[i],  &minHeap->array[(i - 1) / 2]);

        // move to parent index
        i = (i - 1) / 2;
    }
}

// A utility function to check if a given vertex
// 'v' is in min heap or not
bool isInMinHeap(struct MinHeap *minHeap, int v)
{
   if (minHeap->pos[v] < minHeap->size)
     return true;
   return false;
}

// A utility function used to print the solution
void printArr(int dist[], int n)
{
    printf("Vertex   Distance from Source\n");
    for (int i = 0; i < n; ++i)
        printf("%d \t\t %d\n", i, dist[i]);
}
void printint(int dist[], int x)
{
     
        printf("%d\n", dist[x]);
}
// The main function that calulates distances of shortest paths from src to all
// vertices. It is a O(ELogV) function
void dijkstra(struct Graph* graph, int src)
{
    int V = graph->V;// Get the number of vertices in graph
    int dist[V];      // dist values used to pick minimum weight edge in cut

    // minHeap represents set E
    struct MinHeap* minHeap = createMinHeap(V);

    // Initialize min heap with all vertices. dist value of all vertices 
    for (int v = 0; v < V; ++v)
    {
        dist[v] = INT_MAX;
        minHeap->array[v] = newMinHeapNode(v, dist[v]);
        minHeap->pos[v] = v;
    }

    // Make dist value of src vertex as 0 so that it is extracted first
    minHeap->array[src] = newMinHeapNode(src, dist[src]);
    minHeap->pos[src]   = src;
    dist[src] = 0;
    decreaseKey(minHeap, src, dist[src]);

    // Initially size of min heap is equal to V
    minHeap->size = V;

    // In the followin loop, min heap contains all nodes
    // whose shortest distance is not yet finalized.
    while (!isEmpty(minHeap))
    {
        // Extract the vertex with minimum distance value
        struct MinHeapNode* minHeapNode = extractMin(minHeap);
        int u = minHeapNode->v; // Store the extracted vertex number

        // Traverse through all adjacent vertices of u (the extracted
        // vertex) and update their distance values
        struct AdjListNode* pCrawl = graph->array[u].head;
        while (pCrawl != NULL)
        {
            int v = pCrawl->dest;

            // If shortest distance to v is not finalized yet, and distance to v
            // through u is less than its previously calculated distance
            if (isInMinHeap(minHeap, v) && dist[u] != INT_MAX && 
                                          pCrawl->weight + dist[u] < dist[v])
            {
                dist[v] = dist[u] + pCrawl->weight;

                // update distance value in min heap also
                decreaseKey(minHeap, v, dist[v]);
            }
            pCrawl = pCrawl->next;
        }
    }

    // print the calculated shortest distances
   // printArr(dist, V);
}


// Driver program to test above functions
int main()
{
    // create the graph given in above fugure
	int t,n,m,q,x;int a,b,w;
	int count=0;
	
    int V = 9;
    struct Graph* graph = createGraph(V);
	cin>>t;
	while(t-->0)
	{
		cin>>n>>m>>q;
		V=n;
     while(m-->0)
	 {
		 cin>>a>>b>>w;
    addEdge(graph, a, b, w);
    
	 }
     while(q-->0)
	 {
		 cin>>x;
	if(count==0)	 
    dijkstra(graph, x);
	
		 count++;

	 }
	}
    return 0;
}
<end>ai-shortest smallest path
<start>ai-factorial long  
#include<iostream>
using namespace std;
 
// Maximum number of digits in output
#define MAX 500
 
int multiply(int x, int res[], int res_size);
 
// This function finds factorial of large numbers and prints them
void factorial(int n)
{
    int res[MAX];
 
    // Initialize result
    res[0] = 1;
    int res_size = 1;
 
    // Apply simple factorial formula n! = 1 * 2 * 3 * 4...*n
    for (int x=2; x<=n; x++)
        res_size = multiply(x, res, res_size);
 
    
    for (int i=res_size-1; i>=0; i--)
        cout << res[i];
    cout<<endl;
}
 
// This function multiplies x with the number represented by res[].
// res_size is size of res[] or number of digits in the number represented
// by res[]. This function uses simple school mathematics for multiplication.
// This function may value of res_size and returns the new value of res_size
int multiply(int x, int res[], int res_size)
{
    int carry = 0;  // Initialize carry
 
    // One by one multiply n with individual digits of res[]
    for (int i=0; i<res_size; i++)
    {
        int prod = res[i] * x + carry;
        res[i] = prod % 10;  // Store last digit of 'prod' in res[]
        carry  = prod/10;    // Put rest in carry
    }
 
    // Put carry in res and increase result size
    while (carry)
    {
        res[res_size] = carry%10;
        carry = carry/10;
        res_size++;
    }
    return res_size;
}
 
// Driver program
int main()
{
    int t,n;
    cin>>t;
    while(t-->0)
    {
        cin>>n;
        factorial(n);
}
    return 0;
}
<end>ai-factorial long  
<start>ai-maximum  array
#include<iostream>
using namespace std;
int main()
{
    long long int t,a,b;
    long long int max,maxid;max=0;maxid=0;
    cin>>t;
    while(t-->0)
    {
        cin>>a>>b;
        if(max>abs(a-b))
        {max=abs(a-b);
            if(a>b)
                maxid=a;
            else
                maxid=b;
        }
        cout<<maxid<<" "<<max<<endl;
    }
    return 0;
}



<end>ai-maximum  array

<start>ai-dawood
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}

<end>ai-dawood
<start>ai-maxnum
#include<iostream>
using namespace std;
int main()
{
	int maxk=1;int maxq=1;int maxr=2;int maxb=2;int maxkn=2;int maxp=8;
	int k,q,r,b,kn,p;
	cin>>k>>q>>r>>b>>kn>>p;
	k=(k<maxk)?maxk-k:0;
	q=(q<maxq)?maxq-q:0;
    r=(r<maxk)?maxr-r:0;
    b=(b<maxb)?maxb-b:0;
    kn=(kn<maxkn)?maxkn-kn:0;

    int foo [5] = { (k<maxk)?maxk-k:0, (q<maxq)?maxq-q:0,maxp, 77, 40, }; 
    p=(p<maxp)?maxp-p:0;
	cout<<foo[2]<<" "<<q<<" "<<r<<" "<<b<<" "<<kn<<" "<<p;
	return 0;
}

<end>ai-maxnum
<start>ai-stringswap
#include<iostream>
using namespace std;
int main()
{
	string s="";int count=1;
	cin>>s;
	if(s[s.length()-1]!=s[0])
		count++;
   	if(s[s.length()/2]!=s[0])
		count++;
	 if(s[s.length()/2]!=s[s.length()-1])
		count++;
	return 0;
}


<end>ai-stringswap<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
#include<iostream>
#include <list>
 
using namespace std;
 

// Driver program to test methods of graph class
int main()
{
	int i=0;
	cout<<"hi";
 
    return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
#include <bits/stdc++.h>

using namespace std;
//short lazieeeeeee
#define FOR(i,n) for(i=0;i<n;i++)
#define FORI(i,a,n) for(i=a;i<n;i++)
 #define ll  long long
 #define MAX 100001
ll A[MAX+1];
 #define AIN(A, B, C) assert(IN(A, B, C))
int main()
{
	int t,i;
	int n;
	cin>>t;
	AIN(t,1,10);
	ll ceven,codd;
	ll ans;
	while(t--)
	{
		ceven=0;
		codd=0;
		cin>>n;
		AIN(n,1,100000);
		FOR(i,n)
		{
			cin>>A[i];
			AIN(A[i],0,1000000000);
			if(A[i]%2==0)
			{
				ceven++;
			}
			else codd++;
			
		}
		ans=ceven*codd;
		cout<<ans<<endl;
	}
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
#include <bits/stdc++.h>

using namespace std;
//short lazieeeeeee
#define FOR(i,n) for(i=0;i<n;i++)
#define FORI(i,a,n) for(i=a;i<n;i++)
 #define ll  long long
 #define MAX 100001
ll A[MAX+1];
 #define AIN(A, B, C) assert(IN(A, B, C))
int main()
{
	int t,i;
	int n;
	cin>>t;
	AIN(t,1,10);
	ll ceven,codd;
	ll ans;
	while(t--)
	{
		ceven=0;
		codd=0;
		cin>>n;
		AIN(n,1,100000);
		FOR(i,n)
		{
			cin>>A[i];
			AIN(A[i],0,1000000000);
			if(A[i]%2==0)
			{
				ceven++;
			}
			else codd++;
			
		}
		ans=ceven*codd;
		cout<<ans<<endl;
	}
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
<start>ai-sumseq
#include <bits/stdc++.h>

using namespace std;
//short lazieeeeeee
#define FOR(i,n) for(i=0;i<n;i++)
#define FORI(i,a,n) for(i=a;i<n;i++)
 #define ll  long long
 #define MAX 100001
ll A[MAX+1];
 #define AIN(A, B, C) assert(IN(A, B, C))
int main()
{
	int t,i;
	int n;
	cin>>t;
	AIN(t,1,10);
	ll ceven,codd;
	ll ans;
	while(t--)
	{
		ceven=0;
		codd=0;
		cin>>n;
		AIN(n,1,100000);
		FOR(i,n)
		{
			cin>>A[i];
			AIN(A[i],0,1000000000);
			if(A[i]%2==0)
			{
				ceven++;
			}
			else codd++;
			
		}
		ans=ceven*codd;
		cout<<ans<<endl;
	}
	return 0;
}
<end>ai-sumseq
<start>ai-maximum and
#include<bits/stdc++.h>
using namespace std;
bool pow_of_two(long long int num)
{

    return (num)&&(!(num&(num-1)));
}
int main()
{
    long long int  m,test,i,j,num,maxx,minn,ans,total;
    cin>>test;
    while(test--)
    {
        cin>>num>>m;
        if((m-num)==1)
            cout<<(num&m)<<endl;
        else if(pow_of_two(m))
            cout<<(m-2)<<endl;
        else
        {
            if(m%2)
                cout<<(m-1)<<endl;
            else
                cout<<(m-2)<<endl;
        }
    }
}

<end>ai-maximum and
<start>ai-countcharinnumber
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long int
int main()
{
	string s;
	cin>>s;
	ll a[12];a[0]=0;
	for(int i=0;i<=10;i++)
	a[i]=0;

	for(unsigned int i=0;i<s.length();i++)
	{
		 if(s[i]=='0')
		 a[0]++;
			 if(s[i]=='1')
		 a[1]++;
		  if(s[i]=='2')
		 a[2]++;
		  if(s[i]=='3')
		 a[3]++;
			 if(s[i]=='4')
		 a[4]++;
		  if(s[i]=='5')
		 a[5]++;
		  if(s[i]=='6')
		 a[6]++;
			 if(s[i]=='7')
		 a[7]++;
		  if(s[i]=='8')
		 a[8]++;
		  if(s[i]=='9')
		 a[9]++;
			
	}
	for(int i=0;i<=9;i++)
	 cout<<i<<" "<<a[i]<<endl;
	 return 0;
}
<end>ai-countcharinnumber
<start>ai-countbinary10
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long int
int main()
{
	string s;
	cin>>s;
	ll a[12];a[0]=0;
	for(int i=0;i<=10;i++)
	a[i]=0;

	for(unsigned int i=0;i<s.length();i++)
	{
		 if(s[i]=='0')
		 a[0]++;
			 if(s[i]=='1')
		 a[1]++;
		  
	}
if((a[0]%6==0)||(a[1]%6==0))

	 cout<<"Sorry, sorry!"<<endl;
else
	cout<<"Good luck!"<<endl;
	 return 0;
}
<end>ai-countbinary10
<start>openFileDialog1
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int i=12;
    i+=12;
    cout<<i<<"hiy";
    return 0;
    
}
<end>openFileDialog1
<start>openFileDialog1

<end>openFileDialog1
<start>ai-cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int i=12;
    i+=12;
    cout<<i<<"hiy";
    return 0;
    
}
<end>ai-cpp
<start>openFileDialog1

<end>openFileDialog1<start>ai-stringmultiple
#include <iostream>
#include <string>
#define OVERFLOW 2
#define ROW b_len
#define COL a_len+b_len+OVERFLOW

using namespace std;

int getCarry(int num) {
    int carry = 0;
    if(num>=10) {
        while(num!=0) {
            carry = num %10;
            num = num/10;
        }
    }
    else carry = 0;
    return carry;
}

int num(char a) {
    return int(a)-48;
}

string mult(string a, string b) {
        string ret;
        int a_len = a.length();
        int b_len = b.length();
        int mat[ROW][COL];
        for(int i =0; i<ROW; ++i) {
            for(int j=0; j<COL; ++j) {
                mat[i][j] = 0;

            }
        }

        int carry=0, n,x=a_len-1,y=b_len-1;
        for(int i=0; i<ROW; ++i) {
            x=a_len-1;
            carry = 0;
            for(int j=(COL-1)-i; j>=0; --j) {
                if((x>=0)&&(y>=0))  {
                    n = (num(a[x])*num(b[y]))+carry;
                    mat[i][j] = n%10;
                    carry = getCarry(n);
                }
                else if((x>=-1)&&(y>=-1)) mat[i][j] = carry;
                x=x-1;
            }
            y=y-1;
        }

        carry = 0;
        int sum_arr[COL];
        for(int i =0; i<COL; ++i) sum_arr[i] = 0;
        for(int i=0; i<ROW; ++i) {
            for(int j=COL-1; j>=0; --j) {
                sum_arr[j] += (mat[i][j]);
            }
        }
        int temp;
        for(int i=COL-1; i>=0; --i) {
            sum_arr[i] += carry;
            temp = sum_arr[i];
            sum_arr[i] = sum_arr[i]%10;
            carry = getCarry(temp);
        }

        for(int i=0; i<COL; ++i) {
            ret.push_back(char(sum_arr[i]+48));
        }

        while(ret[0]=='0'){
            ret = ret.substr(1,ret.length()-1);
        }
        return ret;
}

void printhuge(string a) {
    cout<<"\n";
    for(string::iterator i = a.begin(); i!=a.end(); ++i) {
        cout<<*i;
    }
}

int main() {
    string a,b;
    cin>>a>>b;
    printhuge(mult(a,b));
    return 0;
}
<end>ai-stringmultiple
<start>ai-speedcarexceed
#include <bits/stdc++.h>

using namespace std;
#define max pow(10,9)
#define ll long long int
int main()
{
    ll t , x,n,a;int scape=1;int count=0;	bool iscontinue=true;
	cin>>n>>x;
	 while(n--)
	 {
		 cin>>a;
		 if(iscontinue)
		 {
		 if(a<=x)
		  count++;
		 else
		 {
			 if(scape==0)
			 {
				 iscontinue=false;
			 }
			 else
				 scape--;

		 }
		 }

	 }
   	  cout<<count<<endl;

    return 0;
}
<end>ai-speedcarexceed
<start>D:\dawood\basidcan.cpp
#include <bits/stdc++.h>

using namespace std;
#define max 5*pow(10,3)
#define ll long long int

int main()
{
	int a[5000];
    ll n,sum;int i=0;		 sum=0;
	cin>>n>>a[0];
sum+=a[0];
	while(i++<n-1)
	{ cin>>a[i];
    if(a[i]==0)
    {sum-=a[i-1];
        a[i-1]=0;
    }
    else
        sum+=a[i];
}
	
		cout<<sum<<endl;

  
	 
    return 0;
}
<end>D:\dawood\basidcan.cpp
<start>ai-beforezero
#include <bits/stdc++.h>

using namespace std;
#define max 5*pow(10,3)
#define ll long long int

int main()
{
	int a[5000];
    ll n,sum;int i=0;		 sum=0;
	cin>>n>>a[0];
sum+=a[0];
	while(i++<n-1)
	{ cin>>a[i];
    if(a[i]==0)
    {sum-=a[i-1];
        a[i-1]=0;
    }
    else
        sum+=a[i];
}
	
		cout<<sum<<endl;

  
	 
    return 0;
}
<end>ai-beforezero
<start>ai-palindromes  by arbitary   length
#include<bits/stdc++.h>
using namespace std;
long int max1 =0;

void palin(string s,long int l,long int u)
{
long int i,j;
for(i=l,j=u;i<j;i++,j--)
{
if(s[i]!=s[j])
{
//printf("i is: %d j is%d\n",i,j);
if(max1<((j-i)+1))
max1 = (j-i)+1;
return;

}

}

}
int main()
{
long int i,j;
string s;
cin>>s;

long int len =s.length();
//printf("%d",len);
for(i=0;i<len-1;i++)
{
palin(s,i,len-1);

}	
for(j=len-1;j>=0;j--)
{
palin(s,0,j);

}	
cout<<max1<<endl;
return 0;
}
<end>ai-palindromes  by arbitary   length
<start>ai-palindromes  by length  long
#include<bits/stdc++.h>
using namespace std;
long long int max1 =0;

void palin(string s,long long int l,long long  int u)
{
    long long int i,j;
for(i=l,j=u;i<j;i++,j--)
{
if(s[i]!=s[j])
{
//printf("i is: %d j is%d\n",i,j);
if(max1<((j-i)+1))
max1 = (j-i)+1;
return;

}

}

}
int main()
{
    long long int i,j;
string s;
cin>>s;
if(count(s.begin(), s.end(), s[0])==s.length())
cout<<0<<endl;
else
{
long long  int len =s.length();
//printf("%d",len);
for(i=0;i<len-1;i++)
{
palin(s,i,len-1);

}	
for(j=len-1;j>=0;j--)
{
palin(s,0,j);

}	
cout<<max1<<endl;
}
return 0;
}

<end>ai-palindromes  by length  long
<start>ai-count char  in string
#include<bits/stdc++.h>
using namespace std;

int cs(string s)
{
    int count1=count(s.begin(), s.end(), 'O');
    for(int i=0;i<s.length();i++)
    {if((s[i]=='X')&&(s[i+1]=='O'))
        count1--;
        if((s[i]== 'O')&&(s[i+1]=='X'))
            count1--; 
    }
    return count1;
}
    
int main()
{
    int t;string s;
    cin>>t;
    while(t--)
    {
        cin>>s;
        cout<<cs(s)<<endl;
        s="";
}
    return 0;
    
}

<end>ai-count char  in string
<start>ai-smallest character  in string
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,q;
    int l,r,k;
    string s;
    cin>>n>>q;
    cin>>s;
    while(q--)
    {
        cin>>l>>r>>k;
        
    }
    return 0;
    
}

<end>ai-smallest character  in string
<start>ai-cpp hello world
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int i=12;
    i+=12;
    cout<<"hello world";
    return 0;
    
}

<end>ai-cpp hello world
<start>ai-stack
#include <bits/stdc++.h>
using namespace std;

 //	https://www.hackerearth.com/problem/algorithm/the-football-fest-6/
 // work on stack
using namespace std;
int main()
{
int T;
cin>>T;
while(T--){
long long N,Id;
cin>>N>>Id;
stack<long long> s;
s.push(Id);
while(N--){
char ch;
long long pid;
cin>>ch;
if(ch=='P'){
cin>>pid;
s.push(pid);
}
else{
long long x=s.top();
s.pop();
long long y=s.top();
s.push(x);
s.push(y);
}
}
cout<<"Player"<<" "<< s.top()<<endl;
}
return 0;
}
<end>ai-stack
<start>
#include <bits/stdc++.h>
using namespace std;

 //	https://www.hackerearth.com/problem/algorithm/the-football-fest-6/
 // work on stack
using namespace std;
int main()
{
    string str = "Meet the new boss...";
    hash<std::string> hash_fn;
    size_t str_hash = hash_fn(str);
 
    std::cout << str_hash << '\n';
}
<end>
<start>ai-vector pair hash
#include <bits/stdc++.h>
using namespace std;

 //	https://www.hackerearth.com/practice/data-structures-1/hash-tables-1/basics-4/tutorial/
 // problem on end of toturial
using namespace std;

#define ll long long int
int main()
{
   		ll n,rn,q,x;	string name	 ;
		 vector<pair<ll,string>> moves;
			pair<int,int> aPair;

		cin>>n;
		while(n--)
		{
			cin>>rn>>name;
		moves.push_back(make_pair(rn, name));
		}
		cin>>q;
		while(q--)
		{
			cin>>x;
			cout<<moves[x-1].second<<endl;
		}
			return 0;
}
<end>ai-vector pair hash
<start>ai-string equal 
#include <bits/stdc++.h>
using namespace std;
int cnt[32];
int main()
{
	int t;
	string s,rs;
	cin >> t;
	while ( t-- ) {
		cin >> s;
		memset(cnt, 0, sizeof(cnt));
		for ( int i = 0; i < s.size(); i++ ) cnt[s[i]-'a']++;
		for ( int i = 0; i < 26; i++ ) {
			if ( cnt[i] >= 2 ) {
				rs="Yes";
				break;
			}
		}
		if(rs!="Yes")
		rs="No";
		cout<<rs<<endl;
		rs="";
	}
	return 0;
}
<end>ai-string equal 
<start>ai-linked list
#include <bits/stdc++.h>
using namespace std;
struct Node{
    Node *next;
    int *data;
};
class DataLine{
    private:
      Node *first;
    public:
      DataLine(){
          first=NULL;
  }
    void create_list(){
        Node *temp=new Node;
        int i=2;
        int dat[5]={12,13,14,13,16};
        temp->data=dat;
        temp->next=NULL;
        if(first==NULL){
            //cout<<"hello 1"<<endl;
            first=temp;

        }
        else{
            Node *curr=first;    //We are now doing trevercing so we are assigning the first to the node because we donot want to move the first bacuse link break if we move the first
            while(curr->next!=NULL) //searching end of list
            {   
                curr=curr->next; //Moving to the next node
            }
            curr->next=temp; //insert node

            temp=NULL;        //Making the temp enpty to use it for the new purpose
            //delete temp;
        }
    }
    void print_list()
        {
            Node *prnt=first;  //We are now again want trevercing so we agin run the node by the new node
            while(prnt!=NULL)  //Checking the loop will run till it get the null in the node means its address part and data part both are nUll
            {
                for(int i=0;i<5;i++)
                cout<<"         ***** The "<<" node is "<<*(prnt->data+i)<<endl; //Printing the data
                prnt=prnt->next;           //Moving to the next node
            }

        }
};
int main(){
DataLine dl;
dl.create_list();
    dl.print_list();

return 0;
} 

<end>ai-linked list
<start>ai-binary tree
class BinaryTree {
    int data;
    BinaryTree *left, *right;

public:
    BinaryTree( int node_data ) {
        data = node_data;
        left = NULL;
        right = NULL;
    }
};
<end>ai-binary tree
<start>ai-dfs
#include<iostream>
#include<vector>
using namespace std;
vector<int> adj[100001];
int heightof[100001];
void dfs(int at,int height)
{
    vector<int>::iterator it;
    heightof[at]=height;
    it=adj[at].begin();
    while(it!=adj[at].end())
    {
        dfs((*it),height+1);
        it++;
    }
    return;
}
int main()
{
    int t;
    //cin>>t;
    scanf(" %d",&t);
    while(t--)
    {
        int n,i,root,par;
        scanf(" %d",&n);
        i=1;
        while(i<=n)
        {
            adj[i].clear();
            i++;
        }
        i=1;
        while(i<=n)
        {
            //cin>>par;
            scanf(" %d",&par);
            if(par==0)
            {
                root=i;
            }
            else
            {
                adj[par].push_back(i);
            }
            i++;
        }
        dfs(root,0);
        i=1;
        long long sumofheights=0,total=(long long)n*(n-1);
        total/=2;
        while(i<=n)
        {
            sumofheights+=(long long)heightof[i];
      //      cout<<heightof[i]<<" ";
            i++;
        }
       // cout<<sumofheights<<" "<<total-sumofheights<<endl;
       printf("%lld %lld\n",sumofheights,total-sumofheights);
    }
    return 0;
}
<end>ai-dfs
<start>ai-keyword tree
#include <bits/stdc++.h>
using namespace std;
 #define F first
#define S second
#define all(a) a.begin(),a.end()
  typedef long long LL;
#define MOD 1000000007ll

struct node{
    int maxweight;
    node * next[26];
    node(){
        maxweight=0;
        for(int i=0; i<26; i++)
            next[i]=NULL;
    }
};
node * insert(node * root, string & s, int ind, int weight){
    if(ind==s.length()){
        return NULL;
    }
    root->maxweight=weight;
    node * & cur=root->next[s[ind]-'a'];
    if(cur==NULL)
        cur=new node();
    cur=insert(cur, s, ind+1, weight);
    return root;
}
int query(node * root, string & q, int i){
    if(i==q.length())return root->maxweight;
    if(root->next[q[i]-'a']==NULL)
        return -1;
    return query(root->next[q[i]-'a'], q, i+1);
}
int main()
{
    int n,q;
    cin>>n>>q;
    vector< pair< int, string > > ar(n);
    for(int i=0; i<n; i++)
        cin >> ar[i].S >> ar[i].F;
    sort(all(ar));
    node * root=new node();
    for(int i=0; i<n; i++)
        root=insert(root, ar[i].S, 0, ar[i].F);
    while(q--){
        string s;
        cin >> s;
        cout << query(root, s, 0) << endl;
    }
    return 0;
}

<end>ai-keyword tree
<start>ai-auto complete tree
#include <bits/stdc++.h>
using namespace std;
 #define F first
#define S second
#define all(a) a.begin(),a.end()
  typedef long long LL;
#define MOD 1000000007ll

struct node{
    int maxweight;
    node * next[26];
    node(){
        maxweight=0;
        for(int i=0; i<26; i++)
            next[i]=NULL;
    }
};
node * insert(node * root, string & s, int ind, int weight){
    if(ind==s.length()){
        return NULL;
    }
    root->maxweight=weight;
    node * & cur=root->next[s[ind]-'a'];
    if(cur==NULL)
        cur=new node();
    cur=insert(cur, s, ind+1, weight);
    return root;
}
int query(node * root, string & q, int i){
    if(i==q.length())return root->maxweight;
    if(root->next[q[i]-'a']==NULL)
        return -1;
    return query(root->next[q[i]-'a'], q, i+1);
}
int main()
{
    int n,q;
    cin>>n>>q;
    vector< pair< int, string > > ar(n);
    for(int i=0; i<n; i++)
        cin >> ar[i].S >> ar[i].F;
    sort(all(ar));
    node * root=new node();
    for(int i=0; i<n; i++)
        root=insert(root, ar[i].S, 0, ar[i].F);
    while(q--){
        string s;
        cin >> s;
        cout << query(root, s, 0) << endl;
    }
    return 0;
}
	   /*
		  2 1
hackerearth 10
hackerrank 9
hacker
*/
<end>ai-auto complete tree
<start>ai-Disjoint Data Structures
int root(int Arr[ ],int i)
{
    while(Arr[ i ] != i)           //chase parent of current element until it reaches root.
    {
     Arr[ i ] = Arr[ Arr[ i ] ];        // Path Compression
     i = Arr[ i ];
    }
    return i;
}

/*modified union function where we connect the elements by changing the root of one of the element */

int union(int Arr[ ] ,int A ,int B)
{
    int root_A = root(Arr, A);       
    int root_B = root(Arr, B);  
    Arr[ root_A ] = root_B ;       //setting parent of root(A) as root(B).
}
bool find(int A,int B)
{
    if( root(A)==root(B) )       //if A and B have same root,means they are connected.
    return true;
    else
    return false;
}
<end>ai-Disjoint Data Structures
<start>ai-print the size of all the connected components 
int root(int Arr[ ],int i)
{
    while(Arr[ i ] != i)           //chase parent of current element until it reaches root.
    {
     Arr[ i ] = Arr[ Arr[ i ] ];        // Path Compression
     i = Arr[ i ];
    }
    return i;
}

/*modified union function where we connect the elements by changing the root of one of the element */

int union(int Arr[ ] ,int A ,int B)
{
    int root_A = root(Arr, A);       
    int root_B = root(Arr, B);  
    Arr[ root_A ] = root_B ;       //setting parent of root(A) as root(B).
}
bool find(int A,int B)
{
    if( root(A)==root(B) )       //if A and B have same root,means they are connected.
    return true;
    else
    return false;
}
<end>ai-print the size of all the connected components 
<start>ai-bubble sort
#include <bits/stdc++.h>
using namespace std;
  int* bubble_sort( int A[ ], int n ) {
    int temp;
    for(int k = 0; k< n-1; k++) {
        // (n-k-1) is for ignoring comparisons of elements which have already been compared in earlier iterations

        for(int i = 0; i < n-k-1; i++) {
            if(A[ i ] > A[ i+1] ) {
                // here swapping of positions is being done.
                temp = A[ i ];
                A[ i ] = A[ i+1 ];
                A[ i + 1] = temp;
            }
        }
    }
	return A;
}
int main()
{
  int n;
  cin>>n;int a[n];	 int i=0;	int *b;
  while(i++<n)
  {
	  cin>>a[i];
  }
	 b= bubble_sort(a,n);
	 for(int i=0;i<n;i++)
		 cout<<b[i]<<" ";
    return 0;
}
	

<end>ai-bubble sort
<start>ai-selection sort
#include <bits/stdc++.h>
using namespace std;
  int*  selection_sort (int A[ ], int n) {
        // temporary variable to store the position of minimum element

        int minimum;        
        // reduces the effective size of the array by one in  each iteration.

        for(int i = 0; i < n-1 ; i++)  {

           // assuming the first element to be the minimum of the unsorted array .
             minimum = i ;

          // gives the effective size of the unsorted  array .

            for(int j = i+1; j < n ; j++ ) {
                if(A[ j ] < A[ minimum ])  {                //finds the minimum element
                minimum = j ;
                }
             }
          // putting minimum element on its proper position.
          swap ( A[ minimum ], A[ i ]) ; 
        }
		return A;
   }
int main()
{
  int n;
  cin>>n;int a[n];	 int i=0;	int *b;
  while(i++<n)
  {
	  cin>>a[i];
  }
	 b= selection_sort(a,n);
	 for(int i=0;i<n;i++)
		 cout<<b[i]<<" ";
    return 0;
}
	

<end>ai-selection sort
<start>ai-insertion sort
#include <bits/stdc++.h>
using namespace std;
  int*   insertion_sort ( int A[ ] , int n) 
{
     for( int i = 0 ;i < n ; i++ ) {
    /*storing current element whose left side is checked for its 
             correct position .*/

      int temp = A[ i ];    
      int j = i;

       /* check whether the adjacent element in left side is greater or
            less than the current element. */

          while( temp < A[ j -1] && j > 0 ) {

           // moving the left side element to one position forward.
                A[ j ] = A[ j-1];   
                j= j - 1;

           }
         // moving current element to its  correct position.
           A[ j ] = temp;       
     } 
	 return A;
}
int main()
{
  int n;
  cin>>n;int a[n];	 int i=0;	int *b;
  while(i++<n)
  {
	  cin>>a[i];
  }
	 b= insertion_sort(a,n);
	 for(int i=0;i<n;i++)
		 cout<<b[i]<<" ";
    return 0;
}
	

<end>ai-insertion sort
<start>ai-quicksort
#include <bits/stdc++.h>
using namespace std;
int partition ( int A[],int start ,int end) {
    int i = start + 1;
    int piv = A[start] ;            //make the first element as pivot element.
    for(int j =start + 1; j <= end ; j++ )  {
    /*rearrange the array by putting elements which are less than pivot
       on one side and which are greater that on other. */

          if ( A[ j ] < piv) {
                 swap (A[ i ],A [ j ]);
            i += 1;
        }
   }
   swap ( A[ start ] ,A[ i-1 ] ) ;  //put the pivot element in its proper place.
   return i-1;                      //return the position of the pivot
}
			 int rand_partition ( int A[ ] , int start , int end ) {
    //chooses position of pivot randomly by using rand() function .
     int random = start + rand( )%(end-start +1 ) ;

      swap ( A[random] , A[start]) ;        //swap pivot with 1st element.
     return partition(A,start ,end) ;       //call the above partition function
}
  int*  quick_sort ( int A[ ] ,int start , int end ) {
   if( start < end ) {
        //stores the position of pivot element
         int piv_pos = rand_partition (A,start , end ) ;     
         quick_sort (A,start , piv_pos -1);    //sorts the left side of pivot.
         quick_sort ( A,piv_pos +1 , end) ; //sorts the right side of pivot.
   }

	 return A;
}
int main()
{
  int n;
  cin>>n;int a[n];	 int i=0;	int *b;
  while(i++<n)
  {
	  cin>>a[i];
  }
	 b= quick_sort(a,0,n+1);
	 for(int i=0;i<=n;i++)
		 cout<<b[i]<<" ";
    return 0;
}
	

<end>ai-quicksort
<start>ai-mergesort
#include <bits/stdc++.h>
using namespace std;

void merge(int a[],int,int,int);
int* merge_sort(int a[],int low,int high)
{
 int mid;
 if(low<high)
 {
  mid = low + (high-low)/2; //This avoids overflow when low, high are too large
  merge_sort(a,low,mid);
  merge_sort(a,mid+1,high);
  merge(a,low,mid,high);
 }
 return a;
}
void merge(int a[],int low,int mid,int high)
{
 int h,i,j,b[50],k;
 h=low;
 i=low;
 j=mid+1;

 while((h<=mid)&&(j<=high))
 {
  if(a[h]<=a[j])
  {
   b[i]=a[h];
   h++;
  }
  else
  {
   b[i]=a[j];
   j++;
  }
  i++;
 }
 if(h>mid)
 {
  for(k=j;k<=high;k++)
  {
   b[i]=a[k];
   i++;
  }
 }
 else
 {
  for(k=h;k<=mid;k++)
  {
   b[i]=a[k];
   i++;
  }
 }
 for(k=low;k<=high;k++) a[k]=b[k];
}
int main()
{
  int n;
  cin>>n;int a[n];	 int i=0;	int *b;
  while(i++<n)
  {
	  cin>>a[i];
  }
	 b= merge_sort(a,0,n+1);
	 for(int i=0;i<=n;i++)
		 cout<<b[i]<<" ";
    return 0;
}
	

<end>ai-mergesort
<start>ai-java hello
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class WriteText
{
    public static void main(String[] args)
    {

        System.out.println( "hello" );
    }
}
<end>ai-java hello
<start>ai-bubblesort count
#include <bits/stdc++.h>

using namespace std;
int count1=0;
 void bubble_sort( int A[ ], int n ) {
    int temp;
	   
    for(int k = 0; k< n; k++) {
        // (n-k-1) is for ignoring comparisons of elements which have already been compared in earlier iterations

        for(int i = 0; i < n-k-1; i++) {
            if(A[ i ] >= A[ i+1] ) {
                // here swapping of positions is being done.
                temp = A[ i ];
                A[ i ] = A[ i+1 ];
                A[ i + 1] = temp;
				count1++;
            }
        }
    }
  
}
int main() {
int n;cin>>n;
		 
int a[n];int i=0;
   for(int k = 0; k< n; k++)
			a[k]=0;
while(i++<n)
	cin>>a[i];

bubble_sort(a,n+1);
 cout<<count1;
return 0;
}
	
<end>ai-bubblesort count
<start>ai-bubble sort count
#include <bits/stdc++.h>

using namespace std;
int count1=0;
 void bubble_sort( int A[ ], int n ) {
    int temp;
	   
    for(int k = 0; k< n; k++) {
        // (n-k-1) is for ignoring comparisons of elements which have already been compared in earlier iterations

        for(int i = 0; i < n-k-1; i++) {
            if(A[ i ] >= A[ i+1] ) {
                // here swapping of positions is being done.
                temp = A[ i ];
                A[ i ] = A[ i+1 ];
                A[ i + 1] = temp;
				count1++;
            }
        }
    }
  
}
int main() {
int n;cin>>n;
		 
int a[n];int i=0;
   for(int k = 0; k<= n; k++)
			a[k]=0;
while(i++<n)
	cin>>a[i];

bubble_sort(a,n+1);
 cout<<count1;
return 0;
}
	
<end>ai-bubble sort count
<start>ai-macros
#define FOR(i, a, b) for(int i=(a);i<(b);i++)
#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)
#define FILL(A,value) memset(A,value,sizeof(A))
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define Pi 3.14159265358979
#define x0 ikjnrmthklmnt
#define y0 lkrjhkltr
#define y1 ewrgrg
typedef long long Int;
typedef unsigned long long UInt;
typedef vector<int> VI;
typedef pair<int, int> PII;
typedef pair<Int, Int> PLL;
typedef pair<double, double> PDD;
typedef complex<double> base;
const int INF = 1000000000;
const int BASE = 1000000007;
const int MAX = 100007;
const int MAX2 = 7777;
const int MAXE = 100000;
const int ADD = 1000000;
const int MOD = 1000000007;
const int CNT = 800;

<end>ai-macros

<start>ai-include
#include <bits/stdc++.h>
using namespace std;

<end>ai-include
<start>ai-responding rectangle
#include<bits/stdc++.h>
using namespace std;
void eval()
 {
 	int n,m,q,x,y;
 	cin>>n>>m;
 	cin>>q;
 	set<int> xAxis;
 	set<int> yAxis;
 	xAxis.insert(1);
 	yAxis.insert(1);
 	xAxis.insert(n);
 	yAxis.insert(m);
 	
 	for(int i=0;i<q;i++)
 	 {
 	 		cin>>x>>y;
 	 		xAxis.insert(x);
 	 		yAxis.insert(y);
	 }
	long long cuts = (xAxis.size()-1)*1LL*(yAxis.size()-1);
	cout<<cuts<<" ";
	
	int xMax = 0, xMin = n;
	int yMax = 0, yMin = m;
	set<int>::iterator it=xAxis.begin();
	set<int>::iterator it2=it;
	it2++;
	for(;it2!=xAxis.end();it++,it2++) 
	{
		xMax=max(xMax, *it2-*it);
		xMin=min(xMin, *it2-*it);
		
	}
	it=yAxis.begin();
	it2=it;
	it2++;
	for(;it2!=yAxis.end();it++,it2++) 
	{
		yMax=max(yMax, *it2-*it);
		yMin=min(yMin, *it2-*it);
	}
	cout<<xMin*1LL*yMin<<" "<<xMax*1LL*yMax<<endl;
	
 }
int main()
{
	int t;
	cin>>t;
	while(t--)
	 {
	 	eval();
	 }
}
<end>ai-responding rectangle
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera11-2-1.cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{		 
	int x,y,x1,y1;
	cin>>x>>y>>x1>>y1;	 string result="Right";
		if((x1>x)&&(y1>y))
			result="Right";
	   	  if((x1>x)&&(y1<y))
			result="Right";
		  if((x1<x)&&(y1>y))
			result="Left";
		  if((x1<x)&&(y1<y))
			  result="Left";
cout<<result<<endl;
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera11-2-1.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{		 
	int x,y,x1,y1;
	cin>>x>>y>>x1>>y1;	 string result="Right";
		if((x1>x)&&(y1>y))
			result="Right";
	   	  if((x1>x)&&(y1<y))
			result="Right";
		  if((x1<x)&&(y1>y))
			result="Left";
		  if((x1<x)&&(y1<y))
			  result="Left";
cout<<result<<endl;
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{		 
	int x,y,x1,y1;
	cin>>x>>y>>x1>>y1;	 string result="Right";
		if((x1>x)&&(y1>y))
			result="Right";
	   	  if((x1>x)&&(y1<y))
			result="Right";
		  if((x1<x)&&(y1>y))
			result="Left";
		  if((x1<x)&&(y1<y))
			  result="Left";
cout<<result<<endl;
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{		 
	int x,y,x1,y1;
	cin>>x>>y>>x1>>y1;	 string result="Right";
		if((x1>=x)&&(y1>=y))
			result="Right";
	   	  if((x1>=x)&&(y1<=y))
			result="Right";
		  if((x1<=x)&&(y1>y))
			result="Left";
		  if((x1<=x)&&(y1<y))
			  result="Left";
		  
cout<<result<<endl;
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{		 
	int x,y,x1,y1;
	cin>>x>>y>>x1>>y1;	 string result="Right";
	if((x1>x)&&(y1==0))
		  result="Right";
	else if((x1<x)&&(y1==0))
		  result="Left";
	else	if((x1>x)&&(y1>y))
			result="Right";
	else	  if((x1>x)&&(y1<=y))
			result="Right";
	else	  if((x1<x)&&(y1>y))
			result="Left";
	else	  if((x1<x)&&(y1<y))
			  result="Left";
	else
		   			  result="Left";

		  
cout<<result<<endl;
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{		 
	int x,y,x1,y1;
	cin>>x>>y>>x1>>y1;	 string result="Right";
	if((x1>x)&&(y1==0))
		  result="Right";
	else if((x1<x)&&(y1==0))
		  result="Left";
	else	if((x1>x)&&(y1>y))
			result="Right";
	else	  if((x1>x)&&(y1<=y))
			result="Right";
	else	  if((x1<x)&&(y1>y))
			result="Left";
	else	  if((x1<x)&&(y1<y))
			  result="Left";
	else
		   			  result="Left";

		  
cout<<result<<endl;
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{		 
	int x,y,x1,y1;
	cin>>x>>y>>x1>>y1;	 string result="Right";
	if((x1>x)&&(y1==0))
		  result="Right";
	else if((x1<x)&&(y1==0))
		  result="Left";
	else	if((x1>x)&&(y1>y))
			result="Right";
	else	  if((x1>x)&&(y1<=y))
			result="Right";
	else	  if((x1<x)&&(y1>y))
			result="Left";
	else	  if((x1<x)&&(y1<y))
			  result="Left";
	else
		   			  result="Left";

		  
cout<<result<<endl;
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1121.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1122.cpp
#include<bits/stdc++.h>
using namespace std;
typedef  long long int ll;
int main()
{		 
	ll  n,k,mx,my;    vector< pair <ll,ll> > vect;

	cin>>n>>k;	 ll i=0;
	while(i++<n)
	{		 cin>>mx>>my;       
		vect.push_back( make_pair(mx,my) );


	}

	       sort(vect.begin(), vect.end());

		 for (int i=0; i<n; i++)
    {
        // "first" and "second" are used to access
        // 1st and 2nd element of pair respectively
		if(k-vect[i].first>0)
		{
        k-= vect[i].first ;
       k+= vect[i].second ;
		}
		else
			break;
    }
  	  cout<<k;

	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\quera1122.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    cout<<"test";
    
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    cout<<"test";
    
	return 0;
}
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\testp.cpp
<start>ai-algorithm story
this is a story
<end>ai-algorithm story
<start>ai-algorithm story
test
<end>ai-algorithm story
<start>ai-algorithm


<end>ai-algorithm
<start>ai-algorithm story


<end>ai-algorithm story
<start>ai-algorithm story


<end>ai-algorithm story
<start>ai-quicksort prome night
//https://www.hackerearth.com/practice/algorithms/sorting/quick-sort/practice-problems/algorithm////pnht/

#include<bits/stdc++.h>
#define ll long long
using namespace std;

int main()
{
   // freopen("input10.txt","r",stdin);
    //freopen("output10.txt","w",stdout);
    int t,n,m,in;	  string res="YES";
	vector<int> boys,girls;
	cin>>t;
	while(t--)
	{	res= "YES";
		cin>>m>>n;
		while(m-->0)
		{
			cin>>in	;
			boys.push_back(in);
		}
		 while(n-->0)
		{
			cin>>in	;
			girls.push_back(in);
		}
		  sort(boys.begin(), boys.end());

		 sort(girls.begin(), girls.end());
		 for(int i=0;i<boys.size();i++)
		  if(boys[i]<=girls[i])
		  { res="NO";break;}
				   cout<<res<<endl;
		 boys.clear();
		 girls.clear();

	 }

	
    return 0;
}
<end>ai-quicksort prome night
<start>ai-graph all path
#include<iostream>
#include <list>
using namespace std;

// A directed graph using adjacency list representation
class Graph
{
    int V;    // No. of vertices in graph
    list<int> *adj; // Pointer to an array containing adjacency lists

    // A recursive function used by printAllPaths()
    void printAllPathsUtil(int , int , bool [], int [], int &);

public:
    Graph(int V);   // Constructor
    void addEdge(int u, int v);
    void printAllPaths(int s, int d);
};

Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V];
}

void Graph::addEdge(int u, int v)
{
    adj[u].push_back(v); // Add v to u’s list.
}

// Prints all paths from 's' to 'd'
void Graph::printAllPaths(int s, int d)
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];

    // Create an array to store paths
    int *path = new int[V];
    int path_index = 0; // Initialize path[] as empty

    // Initialize all vertices as not visited
    for (int i = 0; i < V; i++)
        visited[i] = false;

    // Call the recursive helper function to print all paths
    printAllPathsUtil(s, d, visited, path, path_index);
}

// A recursive function to print all paths from 'u' to 'd'.
// visited[] keeps track of vertices in current path.
// path[] stores actual vertices and path_index is current
// index in path[]
void Graph::printAllPathsUtil(int u, int d, bool visited[],
                              int path[], int &path_index)
{
    // Mark the current node and store it in path[]
    visited[u] = true;
    path[path_index] = u;
    path_index++;

    // If current vertex is same as destination, then print
    // current path[]
    if (u == d)
    {
        for (int i = 0; i<path_index; i++)
            cout << path[i] << " ";
        cout << endl;
    }
    else // If current vertex is not destination
    {
        // Recur for all the vertices adjacent to current vertex
        list<int>::iterator i;
        for (i = adj[u].begin(); i != adj[u].end(); ++i)
            if (!visited[*i])
                printAllPathsUtil(*i, d, visited, path, path_index);
    }

    // Remove current vertex from path[] and mark it as unvisited
    path_index--;
    visited[u] = false;
}

// Driver program
int main()
{
    // Create a graph given in the above diagram
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(0, 3);
    g.addEdge(2, 0);
    g.addEdge(2, 1);
    g.addEdge(1, 3);

    int s = 2, d = 3;
    cout << "Following are all different paths from " << s
         << " to " << d << endl;
    g.printAllPaths(s, d);

    return 0;
}

<end>ai-graph all path
<start>ai-string ispal
#include <bits/stdc++.h>

using namespace std;
bool ispal(string s)
{	

	if (s == string(s.rbegin(), s.rend())) 
		return true	 ;
		  	return false;

}
int main()
{
   	string s,s1;		int t;
	cin>>t;
	while(t--)
	{
			cin>>s>>s1;
		 if(ispal(s+s1)||(ispal(s1+s)))
			 cout<<"YES";
		 else
			 cout<<"NO";
	}
	 ;
    return 0;
}







<end>ai-string ispal
<start>ai-string group
#include <bits/stdc++.h>

using namespace std;
  #define FOR(i, a, b) for(int i=(a);i<(b);i++)

int main()
{
	int t;
	cin >> t;
	FOR(tt,0,t)
	{
		string s;
		cin >> s;
		if (s.size() >= 10)
		{
			cout << "YES" << endl;
			continue;
		}
		bool ok = 0;
		FOR(i,1,s.size())
			FOR(j,i + 1 , s.size())
				FOR(k,j + 1 , s.size())
				{
					string s1 = s.substr(0,i);
					string s2 = s.substr(i, j - i);
					string s3 = s.substr(j, k - j);
					string s4 = s.substr(k, s.size() - k);
					cout<<s1<<endl<<s2<<endl<<s3<<endl<<s4<<endl;
					if (s1 != s2 && s1 != s3 && s1 != s4 && s2 != s3 && s2 != s4 && s3 != s4)
					{
						ok = 1;
					}
				}
		if (ok) cout << "YES" << endl;
		else cout << "NO" << endl;
	}
    return 0;
}







<end>ai-string group
<start>ai-vector pair sort
	  // C++ program to demonstrate sorting in vector
// of pair according to 2nd element of pair
#include<bits/stdc++.h>
using namespace std;
 
// Driver function to sort the vector elements
// by second element of pairs
bool sortbysec(const pair<int,int> &a,
              const pair<int,int> &b)
{
    return (a.second < b.second);
}
 
int main()
{
    // declaring vector of pairs
    vector< pair <int, int> > vect;
 
    // Initialising 1st and 2nd element of pairs
    // with array values
    int arr[] = {10, 20, 5, 40 };
    int arr1[] = {30, 60, 20, 50};
    int n = sizeof(arr)/sizeof(arr[0]);
 
    // Entering values in vector of pairs
    for (int i=0; i<n; i++)
        vect.push_back( make_pair(arr[i],arr1[i]) );
 
    // Printing the original vector(before sort())
    cout << "The vector before sort operation is:\n" ;
    for (int i=0; i<n; i++)
    {
        // "first" and "second" are used to access
        // 1st and 2nd element of pair respectively
        cout << vect[i].first << " "
             << vect[i].second << endl;
 
    }
 
    // Using sort() function to sort by 2nd element
    // of pair
    sort(vect.begin(), vect.end(), sortbysec);
 	 //remove sortbysec for sort first element
    // Printing the sorted vector(after using sort())
    cout << "The vector after sort operation is:\n" ;
    for (int i=0; i<n; i++)
    {
        // "first" and "second" are used to access
        // 1st and 2nd element of pair respectively
        cout << vect[i].first << " "
             << vect[i].second << endl;
    }
    return 0;
}
<end>ai-vector pair sort
<start>ai-bfs find distance
#include <bits/stdc++.h>
using namespace std;
 #define LL long long
#define MODM 1000000007

int binarySearch(vector < int > arr, int l, int r, int x) { while (l <= r){int m = l + (r-l)/2; if (arr[m] == x) return m; if (arr[m] < x) l = m + 1; else r = m - 1; return -1; }}
LL gcd(LL a, LL b){if(a==0)return(b);else return(gcd(b%a,a));}
LL fastpow(LL a, LL n, LL temp){if(n==0) return(1);if(n==1)return((a*temp)%MODM); if(n&1)temp=(temp*a)%MODM;return(fastpow((a*a)%MODM,n/2,temp));}
int dist[100001];
int visited[100001];
int n, tme;
struct node {
	int i,d;
};
typedef struct node node;
vector<node> v[100001];
int bfs (int start) {
	queue<int> q;
	q.push(start);
	for(int i=0;i<=n;i++){
		visited[i]=0;
		dist[i]=0;
	}
	visited[start]=1;
	while(!q.empty()){
		int temp = q.front();
		q.pop();
		for(int i=0;i<(int)v[temp].size();i++){
			if(visited[v[temp][i].i]==0){
				visited[v[temp][i].i]=1;
				dist[v[temp][i].i]+=dist[temp]+v[temp][i].d;
				q.push(v[temp][i].i);
			}
		}
	}
	return int(max_element(dist+1,dist+n+1)-dist);
}
int main() {
	int u1,v1,d;
	node temp;
	int tc;
	scanf("%d",&tc);
	while(tc--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++) {
			v[i].clear();
		}
		for(int i=1;i<=n-1;i++) {
			scanf("%d%d%d",&u1,&v1,&d);
			temp.i = v1;
			temp.d = d;
			v[u1].push_back(temp);
			temp.i = u1;
			v[v1].push_back(temp);
		}
		int start = bfs(1);
		int ans = bfs(start);
		int finalans = dist[ans];
		int money = 0;
		if (finalans>100)
			money = 100;
		if (finalans>1000)
			money = 1000;
		if (finalans>10000)
			money = 10000;
		printf("%d %d\n",money,finalans);
	}
	return 0;
}


<end>ai-bfs find distance
<start>openFileDialog1
o
<end>openFileDialog1
<start>openFileDialog1
o
<end>openFileDialog1
<start>openFileDialog1
o
<end>openFileDialog1
<start>ai-new editor
writeai-new editor
<end>ai-new editor
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\AIMS.CodeEditor.dll
\xz\\zx   
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\AIMS.CodeEditor.dll
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\AIMS.CodeEditor.dll
\xz\\zx   
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\AIMS.CodeEditor.dll
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\AIMS.CodeEditor.pdb
\xz\\zx   
<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\AIMS.CodeEditor.pdb
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\input3.in
 #include<bits/stdc++.h>
using namespace std;
int main()
{
    int i=12;
    i+=12;
    cout<<"hello world";
    return 0;
    
}


<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\input3.in
<start>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\A-small-attempt0.in
 #include<bits/stdc++.h>
using namespace std;
int main()
{
    int i=12;
    i+=12;
    cout<<"hello world";
    return 0;
    
}


<end>D:\dawood\topcoder\WindowsFormsApplication1\WindowsFormsApplication1\bin\Debug\A-small-attempt0.in

<start>ai-minimum product array
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long int uint64;
typedef long long int int64;
int a[1005];
int main(){
	int owkey,reqkey,n,i;

	cin>>owkey>>reqkey;
	cin>>n;
	for(i=0;i<n;i++)
	cin>>a[i];
	int ans[100005];
	memset(ans,-1,sizeof(ans));
	queue<int>q;
	q.push(owkey);
	ans[owkey]=0;
	while(!q.empty()){
		int64 val=q.front();
		q.pop();
		if(val==reqkey)
		break;
		for(i=0;i<n;i++){
			int64 to=a[i];
			to=to*val;
			to%=100000;
			if(ans[to]==-1){
				ans[to]=ans[val]+1;
				q.push(to);
			}
		}
	}
	printf("%d\n",ans[reqkey]);
	fclose(stdout);
	return 0;
}
<end>ai-minimum product array
<start>ai-graph class bfs dfs


#include <bits/stdc++.h>



using namespace std;

// This class represents a directed graph using adjacency list representation
class Graph
{
    int V;    // No. of vertices
    list<int> *adj;    // Pointer to an array containing adjacency lists
   void DFSUtil(int v, bool visited[]); 
public:
    Graph(int V);  // Constructor
    void addEdge(int v, int w); // function to add an edge to graph
    void BFS(int s);  // prints BFS traversal from a given source s
		  	bool isundirected=false;
	void DFS(int v);

};

Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int>[V+1];
}

void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v�s list.
	if(isundirected==true)
	   adj[v].push_back(w);
}

void Graph::BFS(int s)
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V+1];
    for(int i = 0; i < V; i++)
        visited[i] = false;

    // Create a queue for BFS
    list<int> queue;

    // Mark the current node as visited and enqueue it
    visited[s] = true;
    queue.push_back(s);

    // 'i' will be used to get all adjacent vertices of a vertex
    list<int>::iterator i;

    while(!queue.empty())
    {
        // Dequeue a vertex from queue and print it
        s = queue.front();
        cout << s << " ";
        queue.pop_front();

        // Get all adjacent vertices of the dequeued vertex s
        // If a adjacent has not been visited, then mark it visited
        // and enqueue it
        for(i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if(!visited[*i])
            {
                visited[*i] = true;
                queue.push_back(*i);
            }
        }
    }
}
	  void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and print it
    visited[v] = true;
    cout << v << " ";

    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}

// DFS traversal of the vertices reachable from v. It uses recursive DFSUtil()
void Graph::DFS(int v)
{
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;

    // Call the recursive helper function to print DFS traversal
    DFSUtil(v, visited);
}
// Driver program to test methods of graph class
int main()
{
    // Create a graph given in the above diagram
    Graph g(8) ;
	g.isundirected=false;
    g.addEdge(1, 2); 	    g.addEdge(1, 3); 
	 
	g.addEdge(2, 4);  g.addEdge(2, 5);
   	  g.addEdge(3,6);
	  g.addEdge(5, 7); 	    g.addEdge(5, 8); 
 
    cout << "Following is Breadth First Traversal (starting from vertex 2) \n";
    g.DFS(1);

    return 0;
}

<end>ai-graph class bfs dfs
<start>ai-dfs sample


#include <bits/stdc++.h>



using namespace std;


vector<int>adj[100001];
bool visited[100001];

void dfs(int s)
{
	visited[s] =true;
	for(int i=0;i<(int)adj[s].size();i++)
	{
		if(visited[adj[s][i]]==false)
			dfs(adj[s][i]);
	}
}

void initialize()
{
	for(int i=0;i<10;i++)
	{
		visited[i]=false;
	}
}
	
int main()
{
	int nodes,edges,x,y;//,connectedComponents=0;
	cin>>nodes>>edges;
	for(int i=0;i<edges;i++)
	{
		cin>>x>>y;
		adj[x].push_back(y);
		adj[y].push_back(x);
	}
	initialize();
	int s;
	cin>>s;
	dfs(s);
	int cnt=0;
	for(int i=1;i<=nodes;i++)
	{
		if(visited[i]==false) cnt++;
	}
	cout<<cnt<<endl;
	/*for(int i=1;i<=nodes;i++)
	{
		if(visited[i]==false)
		{
			dfs(i);
			connectedComponents++;
		}
	}
	cout<<connectedComponents<<endl;
	*/
	return 0;
}
<end>ai-dfs sample
<start>ai-split string
	 vector<string> split(const string &s, char delim) {
    stringstream ss(s);
    string item;
    vector<string> tokens;
    while (getline(ss, item, delim)) {
        tokens.push_back(item);
    }
    return tokens;
}
<end>ai-split string
<start>ai-dfs exp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 1000000;

int cc[MAXN];
bool visited[MAXN];
#define FOR(i,n) for(int (i)=0;(i)<(n);++(i))
#define pii pair<int,int>
 #define pb push_back
  #define fi first
#define se second
 #define mp make_pair
#define vi vector<int>
 vi g[MAXN];
void dfs(int v, int id)
{
    visited[v] = 1;
    cc[v] = id;
    FOR(i, g[v].size())
    {
        int u = g[v][i];
        if(!visited[u]) dfs(u, id);
    }
}
int main()    
{
    int t;
    cin >> t;
    while(t--)
    {
        int n, m;
        cin >> n >> m;
        FOR(i, n) g[i].clear();
        FOR(i, n) visited[i] = 0;
        vector<pii> bad_edges;
        FOR(i, m)
        {
            int v, u;
            string relation;
            cin >> v >> relation >> u;
            --v; --u;
            if(relation == "=")
            {
                g[v].pb(u);
                g[u].pb(v);
            }
            else
            {
                bad_edges.pb(mp(v, u));
            }
        }
        FOR(i, n)
        {
            if(!visited[i])
            {
                dfs(i, i);
            }
        }
        int fail = 0;
        FOR(i, bad_edges.size())
        {
            int v = bad_edges[i].fi;
            int u = bad_edges[i].se;
            if(cc[v] == cc[u])
            {
                fail = 1;
                break;
            }
        }
        if(fail) cout << "NO" << endl;
        else cout << "YES" << endl;
    }
    return 0;
}
<end>ai-dfs exp
<start>ai-dfs string shift add


#include<bits/stdc++.h>
using namespace std;
set<string>mp;
int add,shift;
void dfs( string tmp)
{
  //cout<<tmp<<endl;
  mp.insert(tmp);
  string next=tmp;
  int i,n=tmp.size();
  for(i=0;i<n;i++)
  {
    next[(i+shift)%n]=tmp[i];
  }
  if(mp.find(next)==mp.end())
    dfs(next);
  next=tmp;
  for(i=0;i<n;i++)
  {
    if(i%2)
    next[i]= '0'+ (next[i]-'0'+add)%10;
  }
  if(mp.find(next)==mp.end())
    dfs(next);
  return;
}
int main()
{

  int t;
  cin>>t;
  assert(1<=t && t<=10);
  while(t--)
  {
    string inp;
    cin>>inp>>add>>shift;
    mp.clear();
    dfs(inp);
    cout<<*(mp.begin());
    if(t>0)
      cout<<endl;
  }
 return 0;
}
<end>ai-dfs string shift add
<start>ai-good string


#include<bits/stdc++.h>
using namespace std;
string makegood(string s)
{  string temp="";
	for(int i=0;i<s.length();i++)
		if(s[i]!=s[i+1])
	    
			 temp+=s[i];
       
		
	
	return temp	  ;
}

int main( ) {
    int t;	   string s="";
	cin>>t;
	while(t--)
	{
	   cin>>s;
  cout<<makegood(s);
  s="";
	}
  return 0;
}
<end>ai-good string
<start>ai-merge sort count invension
include<bits/stdc++.h>
#define ll long long
using namespace std;
const int MAX = 100005;
const int MAX1 = 1000005;
int T,N;
int Weight[MAX],Frequency[MAX1],Aux[MAX],Copied[MAX],F[MAX1];
ll inv;
void mergeFunc(int left,int mid,int right)
{
    int p=left,q=mid+1,k=0,coun=0;
    for(int i=left;i<=right;i++)
    {
        if(p>mid)
        {
            Aux[k++] = Weight[q++];
        }
        else if(q>right)
        {
            Aux[k++] = Weight[p];
            Frequency[Weight[p]] += coun;
            p++;
        }
        else if(Weight[p] <= Weight[q])
        {
            Aux[k++] = Weight[p];
            Frequency[Weight[p]] += coun;
            p++;
        }
        else
        {
            Aux[k++] = Weight[q++];
            inv += mid-p+1;
            coun++;
        }
    }
    for(int i=0;i<k;i++)
    {
        Weight[left++] = Aux[i];
    }
}
void mergeSort(int left,int right)
{
    if(left<right)
    {
        int mid = (left+right)/2;
        mergeSort(left,mid);
        mergeSort(mid+1,right);
        mergeFunc(left,mid,right);
    }
}
int main()
{
   // freopen("input10.txt","r",stdin);
    //freopen("output10.txt","w",stdout);
    for(scanf("%d",&T);T;--T)
    {
        inv =0 ;
        for(int i=0;i<MAX1;i++)
        Frequency[i] = 0;
        scanf("%d",&N);
        for(int i=0;i<N;i++)
        {
            scanf("%d",&Weight[i]);
            Copied[i] = Weight[i];
        }
        mergeSort(0,N-1);
        ll sum = 0;
        for(int i=0;i<N;i++)
        {
            if(i != N-1)
            printf("%d ",Frequency[Copied[i]]);
            else
            printf("%d\n",Frequency[Copied[i]]);
        }
    }
    return 0;
}
<end>ai-merge sort count invension
<start>ai-string add abacus topcoder
#include<bits/stdc++.h>
#define ll long long
	using namespace std;
class 	 Abacus
{
	vector<int> carry;
	  string chagetostring(int carry,int	 result)
	 {
		 string s="";
		 for(int i=0;i<carry;i++)
			 s+='o';
		 s+="---";
		 for(int i=0;i<result;i++)
			 s+='o';
		 return s;
	 }

public:
	 vector<string> add(vector<string> original,int val)
	{
		vector<string> result;
	   string s=to_string(getnumberarray(original)	+val);
	   for(int i=0;i<s.length();i++)
		 result.push_back(convertnumber(s[i]));
		return result;
	}	
	 string convertnumber(char a)
	 {
			 
           int result = a - '0';
		   int carry=9-result;
			return 	 chagetostring(carry,result);
	 }
	 	  int getnumberarray(vector<string> original)
		  {		string converted="";	
			  for(int i=0;i<original.size();i++)
				  converted+= getnumber(original[i]);
			  return stoi(converted);
		  }
	  string getnumber(string original)
	 {
		  int result=0;	int carry=0; int carrytemp=0;
		bool iscarry=true;
		

		for(int i=0;i<original.length();i++)
		{
if(!iscarry)
		{ 
			if(original[i]=='o')
			result++;
         }
		if(original[i]=='-')
			iscarry=false;
	

		}
		

		return to_string(result);
	 }
	 string  change(string original,int val)
	{
		string converted="";	 int result=0;	int carry=0; int carrytemp=0;
		bool iscarry=true;
		for(int i=0;i<original.length();i++)
		{
if(!iscarry)
		{ if(original[i]=='o')
			result++;
}
		if(original[i]=='-')
			iscarry=false;
	

		}
		result=(result+val)%10;

		carry=9-result;

		return chagetostring(carry,result);
}
	
};
int main()
{
   	Abacus a1;
	vector<string> s=	 {"ooo---oooooo", "---ooooooooo", "---ooooooooo", "---ooooooooo", "oo---ooooooo", "---ooooooooo"};
  	  s=a1.add(s,5);
    for(int i=0;i<s.size();i++)
		cout<<s[i]<< " ";
    return 0;
}
<end>ai-string add abacus topcoder
<start>ai-macros
#define FOR(i, a, b) for(int i=(a);i<(b);i++)
#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)
#define FILL(A,value) memset(A,value,sizeof(A))
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define isMaped( m, element ) ((m).find( (element) ) != (m).end()) 
#define Pi 3.14159265358979
#define x0 ikjnrmthklmnt
#define y0 lkrjhkltr
#define y1 ewrgrg
typedef long long Int;
typedef unsigned long long UInt;
typedef vector<int> VI;
typedef pair<int, int> PII;
typedef pair<Int, Int> PLL;
typedef pair<double, double> PDD;
typedef complex<double> base;
const int INF = 1000000000;
const int BASE = 1000000007;
const int MAX = 100007;
const int MAX2 = 7777;
const int MAXE = 100000;
const int ADD = 1000000;
const int MOD = 1000000007;
const int CNT = 800;




<end>ai-macros
<start>ai-macros
#define FOR(i, a, b) for(int i=(a);i<(b);i++)
#define RFOR(i, b, a) for(int i=(b)-1;i>=(a);--i)
#define FILL(A,value) memset(A,value,sizeof(A))
#define ALL(V) V.begin(), V.end()
#define SZ(V) (int)V.size()
#define PB push_back
#define MP make_pair
#define isMaped( m, element ) ((m).find( (element) ) != (m).end()) 
#define Pi 3.14159265358979
#define x0 ikjnrmthklmnt
#define y0 lkrjhkltr
#define y1 ewrgrg
typedef long long Int;
typedef unsigned long long UInt;
typedef vector<int> VI;
typedef pair<int, int> PII;
typedef pair<Int, Int> PLL;
typedef pair<double, double> PDD;
typedef complex<double> base;
const int INF = 1000000000;
const int BASE = 1000000007;
const int MAX = 100007;
const int MAX2 = 7777;
const int MAXE = 100000;
const int ADD = 1000000;
const int MOD = 1000000007;
const int CNT = 800;




<end>ai-macros
<start>ai-graph node is critical
#include<bits/stdc++.h>
	#define ll long long

	using namespace std;
	 #define FOR( i, n ) for( int (i) = 0; (i) < (n); ++(i) ) 
#define FOREACH(_it,_l) for(__typeof((_l).begin()) _it=((_l).begin());(_it)!=(_l).end();(_it)++) 
#define isMaped( m, element ) ((m).find( (element) ) != (m).end()) 
int GraphSize( int n )
{
    return (n*(n-1))/2;
} 

int GridC( int wired_c, int n )
{ 
    int ret = 0;
    for( int i = n - 1; i > n - wired_c; --i )
    {
         ret += i;
    }
    return ret;
}

class AddElectricalWires 
{
	public:
	int maxNewWires(vector <string> wires, vector <int> gridConnections) 
	{
        map<pair<int,int>, int > connections;
        int c = 0;
        FOREACH( str, wires )
        {
                 FOREACH( ch, *str )
                 {
                          if( *ch == '1' ) c++;
                 }
        }
        c /= 2;
        cout<<GraphSize( 8 )<<endl;
        int total_connections = GraphSize( wires.size() );
        int need_connected = total_connections - c;
        cout<<c<<" "<<GridC( gridConnections.size(), wires.size() )<<" "<<need_connected<<" "<<total_connections<<endl;
        //if( gridConnections.size() == 1 ) return need_connected;
        return need_connected - GridC( gridConnections.size(), wires.size() );
		
	}
};
int main()
{	   vector <string> wires={"000","000","000"}	;
		 vector <int> gridConnections=   {0}	 ;
   	  AddElectricalWires m;	  
	  cout<<m.maxNewWires(wires,gridConnections);


    return 0;
}
<end>ai-graph node is critical
<start>ai-nqueen all solution
// nqueen.cpp
// Glenn G. Chappell
// VERSION 2
// 5 Oct 2009
//
// For CS 311 Fall 2009
// Prints solutions to the n-Queens Problem
// Example of Recursive Search with Backtracking

#include <iostream>
using std::cout;
using std::endl;
using std::cin;
#include <vector>
using std::vector;
#include <string>
using std::string;
using std::getline;
#include <sstream>
using std::istringstream;
#include <cstdlib>
using std::size_t;


typedef vector<int> BoardType;  // Holds queen loc's on a chessboard

// We represent a partial queen placement on a chessboard as a BoardType
// object (board) and an int (n). The int (n) gives the size of the
// chessboard. Thus, n = 8 means an 8 x 8 chessboard. Object board is a
// listing of the queen positions (columns) on 0 or more rows of the
// chessboard (at most n rows). There is at most one queen per row. Its
// position (column) is given by a number from 0 to n-1, inclusive.
//
// For example, a Board holding 1, 3, with n = 4 means a 4 x 4 chessboard
// with queens in its first 2 rows. The queen in the row 0 (1st row) lies
// in column 1 (the 2nd square), and the queen in row 1 (2nd row) lies in
// column 3 (the 4th & last square). This is pictured below:
//
// +---+---+---+---+
// |   | Q |   |   |
// +---+---+---+---+
// |   |   |   | Q |
// +---+---+---+---+
// |   |   |   |   |
// +---+---+---+---+
// |   |   |   |   |
// +---+---+---+---+

// We print a queen arrangement by printing the position of the queen in
// each column. For example, "1 3 0 2" represents the following arrangement
// of queens on a 4x4 chessboard:
//
// +---+---+---+---+
// |   | Q |   |   |
// +---+---+---+---+
// |   |   |   | Q |
// +---+---+---+---+
// | Q |   |   |   |
// +---+---+---+---+
// |   |   | Q |   |
// +---+---+---+---+


// printBoard
// Given a full solution to the n-Queens Problem, print it, as described
//  above.
// Pre:
//     n > 0
//     board.size() == n
//     Each entry of board is in [0, n-1].
//     board, n represent a full solution to the n-Queens Problem (see above).
// Post:
//     board has been printed to cout.
// Does not throw.
void printBoard(const BoardType & board,
                int n)
{
    for (int i = 0; i < n; ++i)
    {
        if (i != 0)
            cout << " ";
        cout << board[i];
    }
    cout << endl;
}


// checkQueen
// Given a partial solution to the n-Queens Problem (see above), determine
//  whether a proposed new queen placement is acceptable, that is, if it
//  cannot attack any any of the existing queens. If there is no possible
//  attack, then the return value is true.
// Pre:
//     board represents a placement of non-attacking queens on an n x n
//      chessboard (see above).
//     board.size() < n.
//     board.size() <= newRow < n.
//     0 <= newCol < n.
// Post:
//     Return value is true if, when a new queen is placed in row newRow
//      and column newCol, this new queen cannnot attack any other queen
//      on the chessboard. False otherwise.
// Does not throw.
bool checkQueen(const BoardType & board,
                int n,
                int newRow,
                int newCol)
{
    for (int oldRow = 0; oldRow < int(board.size()); ++oldRow)
    {
        int oldCol = board[oldRow];

        // vertical attack from existing queen?
        if (newCol == oldCol)
            return false;

        // NW-SE diagonal attack from existing queen?
        if (newRow - newCol == oldRow - oldCol)
            return false;

        // NE-SW diagonal attack from existing queen?
        if (newRow + newCol == oldRow + oldCol)
            return false;

        // NOTE: We do not need to check for horizontal attacks because of
        //  the assumption that there is at most one queen in each row.
    }
    return true;
}


// nQueen_recurse
// Given a partial solution to the n-Queens Problem (see above), print out
//  all non-attacking placements of n queens that include the given queens.
// Recursive.
// Pre:
//     n > 0.
//     board.size() <= n.
//     Each entry of board is in [0 .. n-1].
//     board represents a placement of non-attacking queens on an n x n
//      chessboard (see above).
// Post:
//     All solutions have been printed (see above).
//     b is equal to the value of b when the function was called.
// Does not throw.
void nQueen_recurse(BoardType & board,
                    int n)
// NOTE: We can pass b by reference since the function always restores it
//  to the same state it was in when the function was called. Because the
//  correct execution of the function now depends on this fact, it has
//  been added to the postconditions.
{
    // BASE CASE
    if (board.size() == size_t(n))
    {
        // A full solution! Print it.
        printBoard(board, n);
        return;
    }

    // RECURSIVE CASE
    // Try each position in next row
    for (int newCol = 0; newCol < n; ++newCol)
    {
        // If we can add a queen in position newColumn in the next row ...
        if (checkQueen(board, n, int(board.size()), newCol))
        {
            // ... then do it, and recurse.
            board.push_back(newCol);   // Add new queen
            nQueen_recurse(board, n);  // Recursive call
            board.pop_back();          // Remove queen
        }
    }
}


// nQueen
// Prints all solutions to the n-Queens Problem for a chessboard of the
//  given size. That is, prints a representation of every placement of n
//  mututally non-attacking queens on an n x n chessboard.
// Pre:
//     n > 0.
// Post:
//     All solutions printed (see above).
// Does not throw.
void nQueen(int n)
{
    BoardType emptyBoard;
    nQueen_recurse(emptyBoard, n);
}


// inputLoop
// Repeats the following until the user inputs a non-positive integer:
//     - Prompts for n, the size of a chessboard.
//     - Prints all n-Queen solutions, as described above, for an
//       n x n board.
// Pre: None.
// Post:
//     Interaction and output has been performed, as described.
// Does not throw.
void inputLoop()
{
    while (true)
    {
        // Print explanation
        cout << "n-Queen Solver" << endl;
        cout << endl;

        // Prompt & input chessboard size, with retry on bad input
        int n;
        while (true)
        {
            bool foundError = false;
            cout << "Chessboard size (0 to quit)? ";
            string line;
            getline(cin, line);
            if (!cin)
            {
                if (cin.eof())      // End of file
                    return;
                cin.clear();
                cin.ignore();
                foundError = true;  // Bad input
            }
            else
            {
                istringstream is(line);
                is >> n;
                if (!is)
                    foundError = true;  // Bad read from string
            }

            if (!foundError)
                break;
            cout << endl;
            cout << "Try again" << endl;
        }
        if (n <= 0)
            return;

        // Print solutions to n-Queens Problem
        cout << endl;
        cout << "n-Queen Solutions for "
             << n << " x " << n << " chessboard:" << endl;
        cout << "-----------------------" << endl;
        nQueen(n);
        cout << "-----------------------" << endl;
        cout << endl;
    }
}


// main
// Repeatedly inputs a number n and prints all n-Queen solutions.
// Terminates on n == 0.
// Uses inputLoop.
int main()
{
    inputLoop();
    return 0;
}


<end>ai-nqueen all solution
<start>ai-positivenegative
#include<bits/stdc++.h>
#include<iostream>
#include<vector>
#include<algorithm>
	#define ll long long
using namespace std;

					   

class EasyHomework
{
public:
		string determineSign(vector<int> A)
		{	 
		vector<int> m;
			for(int i=0;i<A.size();i++)
				{
					if(to_string(A[i])[0]=='0')
					m.push_back(0);
					  if(to_string(A[i])[0]=='-')
					m.push_back(-1);
					if(to_string(A[i])[0]=='+')
					m.push_back(1);
			}
			int product=1;
			for(int i=0;i<m.size();i++)
			product*=m[i];
			if(product==0)
				return "ZERO";
			else if(product<0)
				return "NEGATIVE";
			else
				return "POSITIVE";
		}
};
int main()
{			vector<int> a={5, 7, 2, 0};


		  EasyHomework am;
		  cout<<am.determineSign(a);
		  
		  
	return 0;
}


<end>ai-positivenegative
<start>ai-sort struct
#include<bits/stdc++.h>
using namespace std	 ;
   
  #ifndef BUFSIZ
#define BUFSIZ  1024
#endif

const int number_max = 9999;

struct check {
  int y_, m_, d_;
  int number_;
  double amount_;

bool operator<(const check& c) const {return number_ < c.number_;}
} checks[number_max];

int main()
{
  int N;
  scanf("%d", &N);
  getchar();
  getchar();
  while (N--) {
    char s[BUFSIZ];
    int nr_checks = 0;
    while (gets(s) && s[0]) {
      char *p = s, *q;
      check& c = checks[nr_checks];
      c.y_ = strtol(p, &q, 10);
      p = ++q;
      c.m_ = strtol(p, &q, 10);
      p = ++q;
      c.d_ = strtol(p, &q, 10);
      p = q;
      c.number_ = strtol(p, &q, 10);
      c.amount_ = strtod(q, NULL);
      if (c.amount_ < 1000000.0)
        nr_checks++;
    }
    sort(checks, checks + nr_checks);
    int nr_rows = (nr_checks + 2) / 3;
    for (int i = 0; i < nr_rows; i++)
      for (int j = i; j < nr_checks; j += nr_rows) {
        const check& c = checks[j];
        printf("%4d%c %9.2lf %02d/%02d/%02d%s", c.number_,
          ((j && c.number_ != checks[j - 1].number_ + 1) ? '*' : ' '),
          c.amount_, c.y_, c.m_, c.d_,
          ((j + nr_rows < nr_checks) ? "   " : "\n"));
      }
    if (N)
      putchar('\n');
  }
  return 0;
}




<end>ai-sort struct
<start>ai-prime factor
// Program to shortest path from a given source vertex �s� to
// a given destination vertex �t�.  Expected time complexity
// is O(V+E).
#include<bits/stdc++.h>
using namespace std;
class  TheKingsFactorization
{
public:
vector<long> getVector(long N, vector<long> primes){
    // Print the number of 2s that divide n
	 vector<long> correct;
    while (N%2 == 0)
    {
        correct.push_back(2);
        N = N/2;
    }
 
    // n must be odd at this point.  So we can skip one element (Note i = i +2)
    for (int i = 3; i <= sqrt(N); i = i+2)
    {
        // While i divides n, print i and divide n
        while (N%i == 0)
        {
            correct.push_back(i);
            N = N/i;
        }
    }
 
    // This condition is to handle the case whien n is a prime number
    // greater than 2
    if (N > 2)
        correct.push_back(N);
	return correct;
}
};
/* Driver program to test above function */
int main()
{
    long int n = 1764;
	 TheKingsFactorization	  th;
    vector<long> m=th.getVector(100000,{2, 2, 2, 5, 5});
	for(int i=0;i<m.size();i++)
		cout<< m[i]<<" ";
    return 0;
}
<end>ai-prime factor
<start>ai-string to integer
#include <bits/stdc++.h>
using namespace std;
int main()
{
string s1,s2; string p1,p2;

int a,b;
cin>>s1>>s2;
	   p1=s1;p2=s2;
reverse(s1.begin(),s1.end());
reverse(s2.begin(),s2.end());
a=stoi(s1);b=stoi(s2);
if(a<b)
cout<<p1<<" < "<<p2<<endl;
else if(a>b)
cout<<p2<<" < "<<p1<<endl;
else
   cout<<p2<<" = "<<p1<<endl;
  return 0;
}

<end>ai-string to integer
<start>ai-time interval
#include <bits/stdc++.h>

using namespace std;
vector<bool> days(40);
void gettime(int a1,int b1,int  a2, int b2)
{
  int a=0;int b=0;
if((a2<=b1)&&(b2>=a1))
  {
      if(a2>a1)
       a=a2;
       else
       a=a1;
       if(b2<b1)
       b=b2;
       else
       b=b1;
  }
  for(int i=a;i<=b;i++)
  days[i]=true;
     
    
}
void gettime(int a1,int b1,vector<int>  a2, vector<int> b2)
{
  int a=0;int b=0;int count=0;
  for(int i=0;i<a2.size();i++)
    gettime(a1,b1,a2[i],b2[i]);
 
      
    
}
void gettime(vector<int> a1,vector<int> b1,vector<int>  a2, vector<int> b2)
{
  int a=0;int b=0;int count=0;
  for(int i=0;i<a1.size();i++)
   gettime(a1[i],b1[i],a2,b2);
 
      
    
}
int main()
{
    
vector<int> na,nb,ma,mb;int count1=0;
for(int i=0;i<=31;i++)
days[i]=false;
int a,b,m,n,t;
cin>>n>>m;
while(n--)
{
    cin>>a>>b;
    na.push_back(a);nb.push_back(b);
}
while(m--)
{
    cin>>a>>b;
    ma.push_back(a);mb.push_back(b);
}
gettime(na,nb,ma,mb);
for(int i=1;i<=31;i++)
if(days[i]==true)
{
    cout<<i<<" ";
count1++;
}
cout<<endl<<count1;
    return 0;
}

 

<end>ai-time interval
<start>ai-vector int compare
#include <bits/stdc++.h>

using namespace std;
bool vectorisequal(vector<long int> a,vector<long int> b)
{
  for(int i=0;i<a.size();i++)
     if(a[i]!=b[i])
       return false;
  return true;     
      
    
}
bool vectorissmaller(vector<long int> a,vector<long int> b)
{
   if(vectorisequal(a,b))
     if(a.size()<b.size())
         return true;
  return false;;     
      
    
}

int main()
{
  long int n,m,p;
  vector<long int> ni,mi;
  cin>>n>>m;
  while(n--)
  {
      cin>>p;ni.push_back(p);
  }
   while(m--)
  {
      cin>>p;mi.push_back(p);
  }
  if(vectorisequal(ni,mi))
    {
        if(ni.size()<mi.size())
         cout<<"Mohammad Javad";
          if(ni.size()>mi.size())
         cout<<"Mostafa";
          if(ni.size()==mi.size())
         cout<<"Both";
    }
    else
    cout<<"None";
    return 0;
}

 





<end>ai-vector int compare
<start>ai-vecot string find in row col
#include <bits/stdc++.h>
using namespace std;
vector<string> s;
int Find(string orgStr, string findStr){    
    int i,j,k,l,szLen,orgLen;
    char temp[] = " ";

    orgLen = orgStr.length();
    szLen = findStr.length(); 

    k= 0;
    i = 0;
    l = 0;

    while( l < orgLen )
    {
        i = (orgLen - ( orgLen - l));
        for( j = 0; j < szLen; j++)
        {
            temp[j] = orgStr[i];            
            i++;
        }
        temp[j] = '\0';
        if(strcmp(temp,findStr.c_str()) == 0)
        {
            k++;
        }
        strcpy(temp,"");
        l++;
    }
    return k;
    //strcpy(temp,"");
}   
string getcol(int col=0)
{
    string result="";
    
    for(int i=0;i<s.size();i++)
        {
            result+=s[i][col];
        }
        return result;
}
int  getstring(string s1,int i,string main)
{
    string result="";
    for(int j=i;j<s1.length()+1;j++)
    result+=main[j];
    cout<<result<<endl;;
    if(result==s1)
         return 1;
         return 0;
         
}
int findinrow(string s1,int row=0)
{
    int count=0;
    count+= Find(s[row],s1);
    
       return count;
}
int findinrows(string s1 )
{
    int count=0;
for(int i=0;i<s.size();i++)
count+=findinrow(s1,i);
       return count;
}
int findsincol(string s1,int col=0)
{
   string m= getcol(col);
   return Find(m,s1);
    
}
int findsincols(string s1)
{
    int count=0;
  for(int i=0;i<s[0].length();i++)
  
   {
       string m= getcol(i);
       count+= Find(m,s1);
   }
    return count;
} 

int main()
{
    
s={"bbababab","aabababa","bbababab","aaababab"};
cout<< findsincols("baba" )+findinrows("baba");
    return 0;
}

 









<end>ai-vecot string find in row col
<start>ai-graph isconnected
class Graph
{
    private:
        int V;
        list<int> *adj;
    public:
        Graph(int V)
        {
            this->V = V;
            adj = new list<int>[V];
        }
        void addEdge(int v, int w);
        void BFS(int s, bool visited[]);
        Graph getTranspose();
        bool isConnected();
};
 
/*
 * Add Edge to connect v and w
 */
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
    adj[w].push_back(v);
}
 
/*
 *  A recursive function to print BFS starting from s
 */
void Graph::BFS(int s, bool visited[])
{
    list<int> q;
    list<int>::iterator i;
    visited[s] = true;
    q.push_back(s);
    while (!q.empty())
    {
        s = q.front();
        q.pop_front();
        for(i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if(!visited[*i])
            {
                visited[*i] = true;
                q.push_back(*i);
            }
        }
    }
}
/*
 * Function that returns reverse (or transpose) of this graph
 */
Graph Graph::getTranspose()
{
    Graph g(V);
    for (int v = 0; v < V; v++)
    {
        list<int>::iterator i;
        for(i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            g.adj[*i].push_back(v);
        }
    }
    return g;
}
/*
 * Check if Graph is Connected
 */
bool Graph::isConnected()
{
    bool visited[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
    BFS(0, visited);
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
    Graph gr = getTranspose();
    for(int i = 0; i < V; i++)
        visited[i] = false;
    gr.BFS(0, visited);
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
    return true;
}
/*
 * Main Contains Menu
 */
int main()
{
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    if (g.isConnected())
        cout<<"The Graph is Connected"<<endl;
    else
        cout<<"The Graph is not Connected"<<endl;
 
    Graph g1(5);
    g1.addEdge(0, 1);
    g1.addEdge(1, 2);
    g1.addEdge(2, 3);
    g1.addEdge(3, 0);
    g1.addEdge(2, 4);
    g1.addEdge(4, 2);
    if (g1.isConnected())
        cout<<"The Graph is Connected"<<endl;
    else
        cout<<"The Graph is not Connected"<<endl;
    return 0;
}



<end>ai-graph isconnected
<start>ai- check the Connectivity of Directed Graph Using BFS
#include<bits/stdc++.h>
using namespace std;

class Graph
{
    private:
        int V;
        list<int> *adj;
    public:
        Graph(int V)
        {
            this->V = V;
            adj = new list<int> [V];
        }
        void addEdge(int v, int w);
        void BFS(int s, bool visited[]);
        Graph getTranspose();
        bool isConnected();
};
/*
 * Add Edge to connect v and w
 */
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
    //adj[w].push_back(v);
}
/*
 *  A recursive function to print BFS starting from s
 */
void Graph::BFS(int s, bool visited[])
{
    list<int> q;
    list<int>::iterator i;
    visited[s] = true;
    q.push_back(s);
    while (!q.empty())
    {
        s = q.front();
        q.pop_front();
        for (i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if (!visited[*i])
            {
                visited[*i] = true;
                q.push_back(*i);
            }
        }
    }
}
/*
 * Function that returns reverse (or transpose) of this graph
 */
Graph Graph::getTranspose()
{
    Graph g(V);
    for (int v = 0; v < V; v++)
    {
        list<int>::iterator i;
        for (i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            g.adj[*i].push_back(v);
        }
    }
    return g;
}
/*
 * Check if Graph is Connected
 */
bool Graph::isConnected()
{
    bool visited[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
    BFS(0, visited);
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
    Graph gr = getTranspose();
    for (int i = 0; i < V; i++)
        visited[i] = false;
    gr.BFS(0, visited);
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
    return true;
}
/*
 * Main Contains Menu
 */
int main()
{
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    if (g.isConnected())
        cout << "The Graph 1 is Connected" << endl;
    else
        cout << "The Graph 1 is not Connected" << endl;
    Graph g1(5);
    g1.addEdge(0, 1);
    g1.addEdge(1, 2);
    g1.addEdge(2, 3);
    g1.addEdge(3, 0);
    g1.addEdge(2, 4);
    g1.addEdge(4, 2);
    if (g1.isConnected())
        cout << "The Graph 2 is Connected" << endl;
    else
        cout << "The Graph 2 is not Connected" << endl;
    return 0;
}

<end>ai- check the Connectivity of Directed Graph Using BFS
<start>ai-hobby
#include<bits/stdc++.h>
using namespace std;

class Graph
{
    private:
        int V;
        list<int> *adj;
    public:
        Graph(int V)
        {
            this->V = V;
            adj = new list<int> [V];
        }
        void addEdge(int v, int w);
        void BFS(int s, bool visited[]);
        Graph getTranspose();
        bool isConnected();
};
/*
 * Add Edge to connect v and w
 */
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
    //adj[w].push_back(v);
}
/*
 *  A recursive function to print BFS starting from s
 */
void Graph::BFS(int s, bool visited[])
{
    list<int> q;
    list<int>::iterator i;
    visited[s] = true;
    q.push_back(s);
    while (!q.empty())
    {
        s = q.front();
        q.pop_front();
        for (i = adj[s].begin(); i != adj[s].end(); ++i)
        {
            if (!visited[*i])
            {
                visited[*i] = true;
                q.push_back(*i);
            }
        }
    }
}
/*
 * Function that returns reverse (or transpose) of this graph
 */
Graph Graph::getTranspose()
{
    Graph g(V);
    for (int v = 0; v < V; v++)
    {
        list<int>::iterator i;
        for (i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            g.adj[*i].push_back(v);
        }
    }
    return g;
}
/*
 * Check if Graph is Connected
 */
bool Graph::isConnected()
{
    bool visited[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
    BFS(0, visited);
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
    Graph gr = getTranspose();
    for (int i = 0; i < V; i++)
        visited[i] = false;
    gr.BFS(0, visited);
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
    return true;
}
/*
 * Main Contains Menu
 */
int main()
{
    Graph g(4);
    g.addEdge(0, 1);
    g.addEdge(0, 2);
    g.addEdge(1, 2);
    g.addEdge(2, 3);
    g.addEdge(3, 3);
    if (g.isConnected())
        cout << "The Graph 1 is Connected" << endl;
    else
        cout << "The Graph 1 is not Connected" << endl;
    Graph g1(5);
    g1.addEdge(0, 1);
    g1.addEdge(1, 2);
    g1.addEdge(2, 3);
    g1.addEdge(3, 0);
    g1.addEdge(2, 4);
    g1.addEdge(4, 2);
    if (g1.isConnected())
        cout << "The Graph 2 is Connected" << endl;
    else
        cout << "The Graph 2 is not Connected" << endl;
    return 0;
}


<end>ai-hobby
<start>ai-check graph is weakly connected
#include<bits/stdc++.h>
using namespace std;
 
class Graph
{
        int V; // No. of vertices
        list<int> *adj; // An array of adjacency lists
 
        // A recursive function to print DFS starting from v
        void DFSUtil(int v, bool visited[]);
    public:
        // Constructor and Destructor
        Graph(int V)
        {
            this->V = V;
            adj = new list<int> [V];
        }
        ~Graph()
        {
            delete[] adj;
        }
 
        // Method to add an edge
        void addEdge(int v, int w);
 
        // The main function that returns true if the graph is strongly
        // connected, otherwise false
        bool isSC();
 
        // Function that returns reverse (or transpose) of this graph
        Graph getTranspose();
};
 
// A recursive function to print DFS starting from v
void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and print it
    visited[v] = true;
 
    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}
 
// Function that returns reverse (or transpose) of this graph
Graph Graph::getTranspose()
{
    Graph g(V);
    for (int v = 0; v < V; v++)
    {
        // Recur for all the vertices adjacent to this vertex
        list<int>::iterator i;
        for (i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            g.adj[*i].push_back(v);
        }
    }
    return g;
}
 
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}
 
// The main function that returns true if graph is strongly connected
bool Graph::isSC()
{
    // St1p 1: Mark all the vertices as not visited (For first DFS)
    bool visited[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
 
    // Step 2: Do DFS traversal starting from first vertex.
    DFSUtil(0, visited);
 
    // If DFS traversal doesn’t visit all vertices, then return false.
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
 
    // Step 3: Create a reversed graph
    Graph gr = getTranspose();
 
    // Step 4: Mark all the vertices as not visited (For second DFS)
    for (int i = 0; i < V; i++)
        visited[i] = false;
 
    // Step 5: Do DFS for reversed graph starting from first vertex.
    // Staring Vertex must be same starting point of first DFS
    gr.DFSUtil(0, visited);
 
    // If all vertices are not visited in second DFS, then
    // return false
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            return false;
 
    return true;
}
 
// Driver program to test above functions
int main()
{
    // Create graphs given in the above diagrams
    Graph g1(5);
    g1.addEdge(0, 1);
    g1.addEdge(1, 2);
    g1.addEdge(2, 3);
    g1.addEdge(3, 0);
    g1.addEdge(2, 4);
    g1.addEdge(4, 2);
    cout << "The graph is weakly connected? ";
    g1.isSC() ? cout << "No\n" : cout << "Yes\n";
 
    Graph g2(4);
    g2.addEdge(0, 1);
    g2.addEdge(1, 2);
    g2.addEdge(2, 3);
    cout << "The graph is weakly connected? ";
    g2.isSC() ? cout << "No\n" : cout << "Yes\n";
 
    return 0;
}



<end>ai-check graph is weakly connected
<start>ai-graph minimum spining tree
#include<bits/stdc++.h>
using namespace std;
int flag = 0, v[7];
struct node_info
{
    int no;
}*q = NULL, *r = NULL;
struct node
{
    node_info *pt;
    node *next;
}*top = NULL, *p = NULL, *np = NULL;
void push(node_info *ptr)
{
    np = new node;
    np->pt = ptr;
    np->next = NULL;
    if (top == NULL)
    {
        top = np;
    }
    else
    {
        np->next = top;
        top = np;
    }
}
node_info *pop()
{
    if (top == NULL)
    {
        cout<<"underflow\n";
    }
    else
    {
        p = top;
        top = top->next;
        return(p->pt);
        delete(p);
    }
}
int back_edges(int *v,int am[][7],int i,int k)
{
    q = new node_info;
    q->no = i;
    push(q);
    v[i] = 1;
    for (int j = 0; j < 7; j++)
    {
        if (am[i][j] == 1 && v[j] == 0)
        {
            back_edges(v, am, j, i);
        }
        else if (am[i][j] == 0)
            continue;
        else if ((j == k) && (am[i][k] == 1 && v[j] == 1))
            continue;
        else
        {
            flag = -1;
        }
    }
    r = pop();
    return(flag);
}
void init()
{
    for (int i = 0; i < 7; i++)
        v[i] = 0;
    while (top != NULL)
    {
        pop();
    }
}   
void kruskals(int am[][7], int wm[][7])
{
    int ve = 1, min, temp, temp1;
    cout<<"/n/nEDGES CREATED AS FOLLOWS:-/n/n";
    while (ve <= 6)
    {
        min = 999, temp = 0, temp1 = 0;
        for (int i = 0; i < 7; i++)
        {
            for (int j = 0; j < 7; j++)
            {
                if ((wm[i][j] < min) && wm[i][j]!=0)
                {
                    min = wm[i][j];
                    temp = i;
                    temp1 = j;
                }
                else if (wm[i][j] == 0)
                    continue;
            }
        }
        wm[temp][temp1]=wm[temp1][temp] = 999;
        am[temp][temp1]=am[temp1][temp] = 1;
        init();
        if (back_edges(v, am, temp, 0) < 0)
        {
            am[temp][temp1]=am[temp1][temp] = 0;
            flag = 0;
            continue;
        }
        else
        {
            cout<<"edge created between "<<temp<<" th node and "<<temp1<<" th node"<<endl;
            ve++;
        }            
    }
}
int main()
{
    int am[7][7], wm[7][7];
    for (int i = 0; i < 7; i++)
        v[i] = 0;
    for (int i = 0; i < 7; i++)
    {
        for(int j = 0; j < 7; j++)
        {
            am[i][j] = 0;
        }
    }
    for (int i = 0; i < 7; i++)
    {
        cout<<"enter the values for weight matrix row:"<<i + 1<<endl;
        for(int j = 0; j < 7; j++)
        {
            cin>>wm[i][j];
        }
    }
    kruskals(am,wm);
    getch();
}






<end>ai-graph minimum spining tree
<start>ai-graph find minimum spining tree prime
#include<bits/stdc++.h>
using namespace std;
struct node
{
    int fr, to, cost;
}p[6];
int c = 0, temp1 = 0, temp = 0;
void prims(int *a, int b[][7], int i, int j)
{
    a[i] = 1;
    while (c < 6)
    {
        int min = 999;
        for (int i = 0; i < 7; i++)
        {
            if (a[i] == 1)
            {
                for (int j = 0; j < 7; )
                {
                    if (b[i][j] >= min || b[i][j] == 0)
                    {
                        j++;
                    }
                    else if (b[i][j] < min)
                    {
                        min = b[i][j];
                        temp = i;
                        temp1 = j;
                    }
                }
            }
        }
        a[temp1] = 1;
        p[c].fr = temp;
        p[c].to = temp1;
        p[c].cost = min;
        c++;       
        b[temp][temp1] = b[temp1][temp]=1000;
    }
    for (int k = 0; k < 6; k++)
    {
        cout<<"source node:"<<p[k].fr<<endl;
        cout<<"destination node:"<<p[k].to<<endl;
        cout<<"weight of node"<<p[k].cost<<endl;
    }
}
int main()
{
    int a[7];
    for (int i = 0; i < 7; i++)
    {
        a[i] = 0;
    }
    int b[7][7];
    for (int i = 0; i < 7; i++)
    {
        cout<<"enter values for "<<(i+1)<<" row"<<endl;
        for (int j = 0; j < 7; j++)
        {
            cin>>b[i][j];
        }
    }
    prims(a, b, 0, 0);
}






<end>ai-graph find minimum spining tree prime
<start>ai-graph topologica sort
#include<bits/stdc++.h>
using namespace std;

 
// Class to represent a graph
class Graph
{
        int V; // No. of vertices'
 
        // Pointer to an array containing adjacency listsList
        list<int> *adj;
 
        // A function used by topologicalSort
        void topologicalSortUtil(int v, bool visited[], stack<int> &Stack);
    public:
        Graph(int V); // Constructor
 
        // function to add an edge to graph
        void addEdge(int v, int w);
 
        // prints a Topological Sort of the complete graph
        void topologicalSort();
};
 
Graph::Graph(int V)
{
    this->V = V;
    adj = new list<int> [V];
}
 
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w); // Add w to v’s list.
}
 
// A recursive function used by topologicalSort
void Graph::topologicalSortUtil(int v, bool visited[], stack<int> &Stack)
{
    // Mark the current node as visited.
    visited[v] = true;
 
    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            topologicalSortUtil(*i, visited, Stack);
 
    // Push current vertex to stack which stores result
    Stack.push(v);
}
 
// The function to do Topological Sort. It uses recursive topologicalSortUtil()
void Graph::topologicalSort()
{
    stack<int> Stack;
 
    // Mark all the vertices as not visited
    bool *visited = new bool[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
 
    // Call the recursive helper function to store Topological Sort
    // starting from all vertices one by one
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
            topologicalSortUtil(i, visited, Stack);
 
    // Print contents of stack
    while (Stack.empty() == false)
    {
        cout << Stack.top() << " ";
        Stack.pop();
    }
}
 
// Driver program to test above functions
int main()
{
    // Create a graph given in the above diagram
    Graph g(6);
    g.addEdge(5, 2);
    g.addEdge(5, 0);
    g.addEdge(4, 0);
    g.addEdge(4, 1);
    g.addEdge(2, 3);
    g.addEdge(3, 1);
 
    cout << "Following is a Topological Sort of the given graph \n";
    g.topologicalSort();
 
    return 0;
}







<end>ai-graph topologica sort
<start>ai-graph find shortest path with negative belman ford
#include<bits/stdc++.h>
using namespace std;
struct Edge
{
        int src, dest, weight;
};
 
// a structure to represent a connected, directed and weighted graph
struct Graph
{
        // V-> Number of vertices, E-> Number of edges
        int V, E;
 
        // graph is represented as an array of edges.
        struct Edge* edge;
};
 
// Creates a graph with V vertices and E edges
struct Graph* createGraph(int V, int E)
{
    struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));
    graph->V = V;
    graph->E = E;
 
    graph->edge = (struct Edge*) malloc(graph->E * sizeof(struct Edge));
 
    return graph;
}
 
// A utility function used to print the solution
void printArr(int dist[], int n)
{
    printf("Vertex   Distance from Source\n");
    for (int i = 0; i < n; ++i)
        printf("%d \t\t %d\n", i, dist[i]);
}
 
// The main function that finds shortest distances from src to all other
// vertices using Bellman-Ford algorithm.  The function also detects negative
// weight cycle
void BellmanFord(struct Graph* graph, int src)
{
    int V = graph->V;
    int E = graph->E;
    int dist[V];
 
    // Step 1: Initialize distances from src to all other vertices as INFINITE
    for (int i = 0; i < V; i++)
        dist[i] = INT_MAX;
    dist[src] = 0;
 
    // Step 2: Relax all edges |V| - 1 times. A simple shortest path from src
    // to any other vertex can have at-most |V| - 1 edges
    for (int i = 1; i <= V - 1; i++)
    {
        for (int j = 0; j < E; j++)
        {
            int u = graph->edge[j].src;
            int v = graph->edge[j].dest;
            int weight = graph->edge[j].weight;
            if (dist[u] != INT_MAX && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
        }
    }
 
    // Step 3: check for negative-weight cycles.  The above step guarantees
    // shortest distances if graph doesn't contain negative weight cycle.
    // If we get a shorter path, then there is a cycle.
    for (int i = 0; i < E; i++)
    {
        int u = graph->edge[i].src;
        int v = graph->edge[i].dest;
        int weight = graph->edge[i].weight;
        if (dist[u] != INT_MAX && dist[u] + weight < dist[v])
            printf("Graph contains negative weight cycle");
    }
 
    printArr(dist, V);
 
    return;
}
 
// Driver program to test above functions
int main()
{
    /* Let us create the graph given in above example */
    int V = 5; // Number of vertices in graph
    int E = 8; // Number of edges in graph
    struct Graph* graph = createGraph(V, E);
 
    // add edge 0-1 (or A-B in above figure)
    graph->edge[0].src = 0;
    graph->edge[0].dest = 1;
    graph->edge[0].weight = -1;
 
    // add edge 0-2 (or A-C in above figure)
    graph->edge[1].src = 0;
    graph->edge[1].dest = 2;
    graph->edge[1].weight = 4;
 
    // add edge 1-2 (or B-C in above figure)
    graph->edge[2].src = 1;
    graph->edge[2].dest = 2;
    graph->edge[2].weight = 3;
 
    // add edge 1-3 (or B-D in above figure)
    graph->edge[3].src = 1;
    graph->edge[3].dest = 3;
    graph->edge[3].weight = 2;
 
    // add edge 1-4 (or A-E in above figure)
    graph->edge[4].src = 1;
    graph->edge[4].dest = 4;
    graph->edge[4].weight = 2;
 
    // add edge 3-2 (or D-C in above figure)
    graph->edge[5].src = 3;
    graph->edge[5].dest = 2;
    graph->edge[5].weight = 5;
 
    // add edge 3-1 (or D-B in above figure)
    graph->edge[6].src = 3;
    graph->edge[6].dest = 1;
    graph->edge[6].weight = 1;
 
    // add edge 4-3 (or E-D in above figure)
    graph->edge[7].src = 4;
    graph->edge[7].dest = 3;
    graph->edge[7].weight = -3;
 
    BellmanFord(graph, 0);
 
    return 0;
}







<end>ai-graph find shortest path with negative belman ford
<start>ai-graph find transitive closure
#include<bits/stdc++.h>
using namespace std;
const int num_nodes = 10;
 
int main()
{
    int num_nodes, k, n;
    char i, j, res, c;
    int adj[10][10], path[10][10];
 
    cout << "\n\tMaximum number of nodes in the graph :";
    cin >> n;
    num_nodes = n;
    cout << "\n\n\tNODES ARE LABELED AS A,B,C,......\n\n";
    cout << "\nEnter 'y'for 'YES' and 'n' for 'NO' !!\n";
 
    for (i = 65; i < 65 + num_nodes; i++)
        for (j = 65; j < 65 + num_nodes; j++)
        {
            cout << "\n\tIs there an EDGE from " << i << " to " << j << " ? ";
            cin >> res;
            if (res == 'y')
                adj[i - 65][j - 65] = 1;
            else
                adj[i - 65][j - 65] = 0;
        }
    cout << "\nAdjacency Matrix:\n";
 
    cout << "\n\t\t\t   ";
    for (i = 0; i < num_nodes; i++)
    {
        c = 65 + i;
        cout << c << " ";
    }
    cout << "\n\n";
    for (int i = 0; i < num_nodes; i++)
    {
        c = 65 + i;
        cout << "\t\t\t" << c << "  ";
        for (int j = 0; j < num_nodes; j++)
            cout << adj[i][j] << " ";
        cout << "\n";
    }
    for (int i = 0; i < num_nodes; i++)
        for (int j = 0; j < num_nodes; j++)
            path[i][j] = adj[i][j];
 
    for (int k = 0; k < num_nodes; k++)
        for (int i = 0; i < num_nodes; i++)
            if (path[i][k] == 1)
                for (int j = 0; j < num_nodes; j++)
                    path[i][j] = path[i][j] || path[k][j];
 
    for (int i = 0; i < num_nodes; i++)
        for (int j = 0; j < num_nodes; j++)
            adj[i][j] = path[i][j];
 
    cout << "\nTransitive Closure of the Graph:\n";
 
    cout << "\n\t\t\t   ";
    for (i = 0; i < num_nodes; i++)
    {
        c = 65 + i;
        cout << c << " ";
    }
    cout << "\n\n";
    for (int i = 0; i < num_nodes; i++)
    {
 
        c = 65 + i;
        cout << "\t\t\t" << c << "  ";
        for (int j = 0; j < num_nodes; j++)
            cout << adj[i][j] << " ";
        cout << "\n";
    }
    return 0;
}


<end>ai-graph find transitive closure
<start>ai-graph matching 
#include<bits/stdc++.h>
using namespace std;
using namespace std;
 
// Number of Men or Women
#define N  4
 
// This function returns true if woman 'w' prefers man 'm1' over man 'm'
bool wPrefersM1OverM(int prefer[2*N][N], int w, int m, int m1)
{
    // Check if w prefers m over her current engagment m1
    for (int i = 0; i < N; i++)
    {
        // If m1 comes before m in lisr of w, then w prefers her
        // cirrent engagement, don't do anything
        if (prefer[w][i] == m1)
            return true;
 
        // If m cmes before m1 in w's list, then free her current
        // engagement and engage her with m
        if (prefer[w][i] == m)
           return false;
    }
}
 
// Prints stable matching for N boys and N girls. Boys are numbered as 0 to
// N-1. Girls are numbereed as N to 2N-1.
void stableMarriage(int prefer[2*N][N])
{
    // Stores partner of women. This is our output array that
    // stores paing information.  The value of wPartner[i]
    // indicates the partner assigned to woman N+i.  Note that
    // the woman numbers between N and 2*N-1. The value -1
    // indicates that (N+i)'th woman is free
    int wPartner[N];
 
    // An array to store availability of men.  If mFree[i] is
    // false, then man 'i' is free, otherwise engaged.
    bool mFree[N];
 
    // Initialize all men and women as free
    memset(wPartner, -1, sizeof(wPartner));
    memset(mFree, false, sizeof(mFree));
    int freeCount = N;
 
    // While there are free men
    while (freeCount > 0)
    {
        // Pick the first free man (we could pick any)
        int m;
        for (m = 0; m < N; m++)
            if (mFree[m] == false)
                break;
 
        // One by one go to all women according to m's preferences.
        // Here m is the picked free man
        for (int i = 0; i < N && mFree[m] == false; i++)
        {
            int w = prefer[m][i];
 
            // The woman of preference is free, w and m become
            // partners (Note that the partnership maybe changed
            // later). So we can say they are engaged not married
            if (wPartner[w-N] == -1)
            {
                wPartner[w-N] = m;
                mFree[m] = true;
                freeCount--;
            }
 
            else  // If w is not free
            {
                // Find current engagement of w
                int m1 = wPartner[w-N];
 
                // If w prefers m over her current engagement m1,
                // then break the engagement between w and m1 and
                // engage m with w.
                if (wPrefersM1OverM(prefer, w, m, m1) == false)
                {
                    wPartner[w-N] = m;
                    mFree[m] = true;
                    mFree[m1] = false;
                }
            } // End of Else
        } // End of the for loop that goes to all women in m's list
    } // End of main while loop
 
 
    // Print the solution
    cout << "Woman   Man" << endl;
    for (int i = 0; i < N; i++)
       cout << " " << i+N << "\t" << wPartner[i] << endl;
}
 
// Driver program to test above functions
int main()
{
    int prefer[2*N][N] = { {7, 5, 6, 4},
        {5, 4, 6, 7},
        {4, 5, 6, 7},
        {4, 5, 6, 7},
        {0, 1, 2, 3},
        {0, 1, 2, 3},
        {0, 1, 2, 3},
        {0, 1, 2, 3},
    };
    stableMarriage(prefer);
 
    return 0;
}

<end>ai-graph matching 
<start>ai-graph network flow Ford–Fulkerson
#include<bits/stdc++.h>
using namespace std;
bool bfs(int rGraph[][6], int s, int t, int parent[])
{
    bool visited[6];
    memset(visited, 0, sizeof(visited));
    queue <int> q;
    q.push(s);
    visited[s] = true;
    parent[s] = -1;
 
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (int v = 0; v < 6; v++)
        {
            if (visited[v] == false && rGraph[u][v] > 0)
            {
                q.push(v);
                parent[v] = u;
                visited[v] = true;
            }
        }
    }
    return (visited[t] == true);
}
 
int fordFulkerson(int graph[6][6], int s, int t)
{
    int u, v;
    int rGraph[6][6];  
    for (u = 0; u < 6; u++)
    {
        for (v = 0; v < 6; v++)
        {
            rGraph[u][v] = graph[u][v];
        }
    }
    int parent[6];
    int max_flow = 0;
    while (bfs(rGraph, s, t, parent))
    {
        int path_flow = INT_MAX;
        for (v = t; v != s; v = parent[v])
        {
            u = parent[v];
            path_flow = min(path_flow, rGraph[u][v]);
        }
        for (v = t; v != s; v = parent[v])
        {
            u = parent[v];
            rGraph[u][v] -= path_flow;
            rGraph[v][u] += path_flow;
        }
        max_flow += path_flow;
    }
    return max_flow;
}
int main()
{
    int graph[6][6] = { {0, 16, 13, 0, 0, 0},
                        {0, 0, 10, 12, 0, 0},
                        {0, 4, 0, 0, 14, 0},
                        {0, 0, 9, 0, 0, 20},
                        {0, 0, 0, 7, 0, 4},
                        {0, 0, 0, 0, 0, 0}
                      }; 
    cout << "The maximum possible flow is " << fordFulkerson(graph, 0, 5);
    getch();
}

<end>ai-graph network flow Ford–Fulkerson
<start>ai-trinary search



<end>ai-trinary search
<start>ai-queue
#include<bits/stdc++.h>
using namespace std;


int main() {
    int t,n;char a;
        queue<int> q;

    cin>>t;
    while(t--)
    {
        cin>>a;
        if(a=='E')
        {
            cin>>n;
            q.push(n);
            cout<<q.size()<<endl;
        }
        if(a=='D')
       {
           if(q.size()>0)
           {
           cout<<q.front();
           q.pop();
         cout<<" "<<q.size()<<endl;

           }
           else
           cout<<-1<<" "<<0<<endl;
           
           
       }
       
    }

}


<end>ai-queue
<start>ai-pair
#include<bits/stdc++.h>
using namespace std;
int main()
{
     map<string,string> word;
    string result="UNKNOWN";
    string input="";
    int count1=0;
  word.insert ( std::pair<string,string>("HELLO","ENGLISH") );
    word.insert ( std::pair<string,string>("HOLA","SPANISH") );
  word.insert ( std::pair<string,string>("HALLO","GERMAN") );
word.insert ( std::pair<string,string>("BONJOUR","FRENCH") );
    word.insert ( std::pair<string,string>("CIAO","ITALIAN") );
  word.insert ( std::pair<string,string>("ZDRAVSTVUJTE","RUSSIAN") );
    map<string,string>::iterator it = word.begin();
        while(input!="#")
{
    cin>>input;
    result="UNKNOWN";
    count1++;
  for (it=word.begin(); it!=word.end(); ++it)
  if( it->first ==input)
  result=it->second ;
  cout<<"Case "<<count1<<": "<<result<<endl;
}
    return 0;
}

<end>ai-pair
<start>ai-minimum square


<end>ai-minimum square
<start>ai-binary even shift
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,q,l,r,x;
cin>>n>>q;
	int a[n];
	for(int i=0;i<n;i++)
		cin>>a[i];
	while(q--)
	{
		cin>>x;
		if(x==0)
		{
cin>>l>>r	;	
if(a[r-1] == 0)
				cout<<"EVEN"<<endl;
			else
				cout<<"ODD"<<endl;
		}
		else
		{
		cin>>l;
			a[l-1] = 1-a[l-1];
		}
	}
	return 0;	
}
//based https://www.hackerearth.com/submission/6209553/


<end>ai-binary even shift
<start>ai-dawood
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}


<end>ai-dawood
<start>ai-dawood
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}


<end>ai-dawood
<start>ai-dawood
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}

using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}


using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}



<end>ai-dawood
<start>ai-dawood
#include<bits/stdc++.h>
using namespace std;

struct node
{
  int key_value;
  node *left;
  node *right;
};
	
class btree
{
    public:
        btree();
        ~btree();

        void insert(int key);
        node *search(int key);
        void destroy_tree();

    private:
        void destroy_tree(node *leaf);
        void insert(int key, node *leaf);
        node *search(int key, node *leaf);
        
        node *root;
};
btree::btree()
{
  root=NULL;
}
btree::~btree()
{
  destroy_tree();
}
void btree::destroy_tree(node *leaf)
{
  if(leaf!=NULL)
  {
    destroy_tree(leaf->left);
    destroy_tree(leaf->right);
    delete leaf;
  }
}
void btree::insert(int key, node *leaf)
{
  if(key< leaf->key_value)
  {
    if(leaf->left!=NULL)
     insert(key, leaf->left);
    else
    {
      leaf->left=new node;
      leaf->left->key_value=key;
      leaf->left->left=NULL;    //Sets the left child of the child node to null
      leaf->left->right=NULL;   //Sets the right child of the child node to null
    }  
  }
  else if(key>=leaf->key_value)
  {
    if(leaf->right!=NULL)
      insert(key, leaf->right);
    else
    {
      leaf->right=new node;
      leaf->right->key_value=key;
      leaf->right->left=NULL;  //Sets the left child of the child node to null
      leaf->right->right=NULL; //Sets the right child of the child node to null
    }
  }
}
node *btree::search(int key, node *leaf)
{
  if(leaf!=NULL)
  {
    if(key==leaf->key_value)
      return leaf;
    if(key<leaf->key_value)
      return search(key, leaf->left);
    else
      return search(key, leaf->right);
  }
  else return NULL;
}
node *btree::search(int key)
{
  return search(key, root);
}
void btree::destroy_tree()
{
  destroy_tree(root);
}
int main()
{
    
}

<end>ai-dawood
<start>ai-queue task order
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int N,Num;
	cin>>N;
	queue<int> Q;
	for(int i=0;i<N;i++)
	{
		cin>>Num;
		Q.push(Num);
	}
	int a[N];
	for(int i=0;i<N;i++)
		cin>>a[i];
	int total_time = 0, executed_job = 0;
	while(!Q.empty())
	{
		int job = Q.front();
		if(job == a[executed_job]){
			Q.pop();
			total_time++;
			executed_job++;
		}
		else
		{
			Q.pop();
			Q.push(job);
			total_time++;
		}
	}
	cout<<total_time<<endl;
	return 0;
}
// https://www.hackerearth.com/practice/data-structures/arrays/1-d/practice-problems/algorithm/monk-and-power-of-time/description/

<end>ai-queue task order
<start>ai-dawood
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int N,Num;
	cin>>N;
	queue<int> Q;
	for(int i=0;i<N;i++)
	{
		cin>>Num;
		Q.push(Num);
	}
	int a[N];
	for(int i=0;i<N;i++)
		cin>>a[i];
	int total_time = 0, executed_job = 0;
	while(!Q.empty())
	{
		int job = Q.front();
		if(job == a[executed_job]){
			Q.pop();
			total_time++;
			executed_job++;
		}
		else
		{
			Q.pop();
			Q.push(job);
			total_time++;
		}
	}
	cout<<total_time<<endl;
	return 0;
}
// https://www.hackerearth.com/practice/data-structures/arrays/1-d/practice-problems/algorithm/monk-and-power-of-time/description/


<end>ai-dawood
<start>ai-welcome1
#include<bits/stdc++.h>
using namespace sgd;
int main(void)
{
	return 0;
}








<end>ai-welcome1
<start>ai-welcome2
hi all


<end>ai-welcome2
<start>ai-welcome2
hi all
ooo

<end>ai-welcome2
<start>ai-welcome
hi all
ooo

[]


<end>ai-welcome
<start>ai-welcome3
hi all
ooo
999999999
[[0-[0i-]]]
[]



<end>ai-welcome3
<start>ai-d5


<end>ai-d5
<start>ai-d6
#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<"g";
    return 0;
}


<end>ai-d6
<start>ai-g2323
#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<"g2323";
    return 0;
}



<end>ai-g2323
<start>ai-test
#include<bits/stdc++.h>
using namespace std;
int main()
{
    cout<<"g2323";
    return 0;
}



<end>ai-test
<start>ai-magiccodes
magiccodes
<end>ai-magiccodes
<start>ai-magiccides
magiccodes 12

<end>ai-magiccides
<start>ai-d
magiccodes 12
334

<end>ai-d
<start>ai-d2
magiccodes 12
334
00

<end>ai-d2
<start>ai-d
magiccodes 12
334
00sdds

sdsd112
12
<end>ai-d
<start>ai-test
magiccodes 12
334
00sdds

sdsd112
12
we
<end>ai-test
<start>ai-topcoder c++
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}
<end>ai-topcoder c++
<start>ai-topcoder c++
#include<bits/stdc++.h>
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}

<end>ai-topcoder c++
<start>ai-char to integer
int ia = a - '0';

<end>ai-char to integer
<start>ai-WritingWords type a word on her old cell phone with one keye'    'A' 
#include<iostream>
#include<string>
using namespace std;
class WritingWords
{
public:
    WritingWords()
    {
    }
    int write(string word)
    {
        int count=0;
        for(int i=0;i<word.length();i++)
            count+= (word[i]-'A'+1);
        return count;

    }
};
int main()
{
    WritingWords a;
    cout<<a.write("ABC");
    
    return 0;
}


<end>ai-WritingWords type a word on her old cell phone with one keye'    'A' 
<start>ai-count character in string
#include<algorithm>

#include<iostream>
#include<string>
#include<vector>
using namespace std;
class FoxAndGame
{
public:
    FoxAndGame()
    {
    }
    	int countStars(vector<string> result)
    {
        int count1=result.size();
        int counto=0;
        for(int i=0;i<count1;i++)
            counto+=count(result[i].begin(), result[i].end(),  'o');
        return counto;        

    }
};


<end>ai-count character in string
<start>ai-string middle to left
#include <bits/stdc++.h>
using namespace std;
class InsideOut
{
public:
	string unscramble(string line);
};

string InsideOut::unscramble(string line)
{
	size_t lnLnth = line.length();

	string p1 = string(line, 0, line.length() / 2);

	string p2 = string(line, (line.length() / 2), line.length()/2);

	reverse(p1.begin(), p1.end());
	reverse(p2.begin(), p2.end());

	return p1+p2;
}
int main()
{
	InsideOut ins;
	string l = "RUT OWT SNEH HCNERF EERHTEGDIRTRAP A DNA  SEVODELT";
	string out = ins.unscramble(l);
	cout<<out;
	return 0;
}
<end>ai-string middle to left
<start>ai-game stand or jump kiloman topcoder
//https://community.topcoder.com/stat?c=problem_statement&pm=2268
#include <bits/stdc++.h>
using namespace std;
class KiloMan {
public:
	int hitsTaken(vector <int> pattern, string jumps) {
		int hits = 0;
		for (int i = 0, ilen = pattern.size(); i < ilen; ++i) {
			if ((pattern[i] == 1 || pattern[i] == 2) && jumps[i] == 'S')
				++hits;
			else if (pattern[i] > 2 && jumps[i] == 'J')
				++hits;
		}
		return hits;
	}
};
int main()
{
    vector <int> pattern= 	
{1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,
 4,4,4,5,5,5,5,5,5,5,6,6,6,6,6,6,6,7,7,7,7,7,7,7};
 string jumps="SSSSSSSSSSSSSSJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJ";
 KiloMan m;
 cout<<m.hitsTaken(pattern,jumps);
    return 0;
}
<end>ai-game stand or jump kiloman topcoder
<start>ai-string char distance   typing distance
#include <bits/stdc++.h>
using namespace std;
class TypingDistance
{
public:
    WritingWords()
    {
    }
    int getdis(string board,char a,char b)
    {
        int a1=0;int b1=0;
        for(int i=0;i<board.length();i++)
        {if(board[i]==a)
            a1=i;
            if(board[i]==b)
                b1=i;
        }
        return abs(a1-b1);
    }
    	int minDistance(string keyboard, string word)
    {
        int count=0;
        for(int i=0;i<word.length()-1;i++)
            count+= getdis(keyboard,word[i],word[i+1]);
        return count;

    }
};
int main()
{
    TypingDistance a;
    cout<<a.minDistance("qwertyuiop","potter");
    
    return 0;
}

<end>ai-string char distance   typing distance
<start>ai-test3
ggfgf

<end>ai-test3
<start>ai-permutation sum luck number
#include<bits/stdc++.h>
using namespace std;
class TheNumbersWithLuckyLastDigit {
    public:

        int find(int n) {
            int t[10] = {5, 2, 3, 5, 1, 3, 4, 1, 2, 4};
            int v[10] = {20, 11, 12, 23, 4, 15, 16, 7, 8, 19};
            int last = n % 10;

            if (n % 10 == 7)
                return 1;
            if (n < v[last])
                return -1;
            return t[last];
        }
};
int main()
{
TheNumbersWithLuckyLastDigit a;
cout<<a.find(99);

	return 0;
}

<end>ai-permutation sum luck number
<start>ai-matrix diagnosal
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long int t,s1,s2;

    cin>>t;s1=0;s2=0;
vector<vector<int> > matrix(t, std::vector<int>(t));
    for(int i=0;i<t;i++) {
    for(int j=0;j<t;j++) {
        
        cin>>matrix[i][j];
    }
}
     for(int i=0;i<t;i++)
   { 
       cout<<matrix[i][i]<<" ";
       s1+=matrix[i][i];
       s2+=matrix[i][t-i-1];
   }
    cout<<abs(s1-s2);
    return 0;
}
<end>ai-matrix diagnosal
<start>ai-hi
hi let solve problems
<end>ai-hi
<start>ai-rotate array

#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,k;
		int arr[100005];
		scanf("%d%d",&n,&k);
		for(int i=0;i<n;i++)
			scanf("%d",&arr[i]);
		k%=n;
		for(int i=0;i<n;i++)
			printf("%d ",arr[(i+(n-k))%n]);
		printf("\n");
	}
	return 0;
}

<end>ai-rotate array
<start>ai-queue order time job
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int N,Num;
	cin>>N;
	queue<int> Q;
	for(int i=0;i<N;i++)
	{
		cin>>Num;
		Q.push(Num);
	}
	int a[N];
	for(int i=0;i<N;i++)
		cin>>a[i];
	int total_time = 0, executed_job = 0;
	while(!Q.empty())
	{
		int job = Q.front();
		if(job == a[executed_job]){
			Q.pop();
			total_time++;
			executed_job++;
		}
		else
		{
			Q.pop();
			Q.push(job);
			total_time++;
		}
	}
	cout<<total_time<<endl;
	return 0;
}



<end>ai-queue order time job
<start>ai-Calculate the sum of the lengths of the subarrays having all elements distinct
//Calculate the sum of the lengths of the subarrays having all elements distinct.
#include <bits/stdc++.h>
using namespace std;
int T, N;
int main()
{
    scanf("%d", &T);
    assert(1<=T && T<=100000);
    int S=0;
    while(T--)
    {
        scanf("%d", &N);
        assert(1<=N && N<=100000);
        S+=N;
        vector<int> A(N);
        for(int i=0; i<N; i++)
        {
            scanf("%d", &A[i]);
            assert(0<=A[i] && A[i]<=1000000000);
        }
        long long ans=0;
        set<int> s;
        for(int i=0, j=0; i<N; i++)
        {
            for(; j<N && !s.count(A[j]); j++)
                s.insert(A[j]);
            ans+=1LL*(j-i)*(j-i+1)/2;
            s.erase(A[i]);
        }
        printf("%lld\n", ans);
    }
    assert(S<=100000);
    return 0;
}
/*

1
5
1 2 3 4 5

answer=5*1+4∗2+3∗3+2∗4+1∗5=35
*/
<end>ai-Calculate the sum of the lengths of the subarrays having all elements distinct
<start>ai-array sum integer
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    int a[t+1],b[t+1];
    for(int i=0;i<t;i++)
    cin>>a[i];
    for(int i=0;i<t;i++)
    cin>>b[i];
    for(int i=0;i<t;i++)
    cout<<a[i]+b[i]<<" ";
    return 0;
}

<end>ai-array sum integer
<start>ai-matrix multiplaction
#include<bits/stdc++.h>
using namespace std;
void MultiplyWithOutAMP() {  
       int aMatrix[3][2] = {{1, 4}, {2, 5}, {3, 6}};  
       int bMatrix[2][3] = {{7, 8, 9}, {10, 11, 12}};  
       int product[3][3] = {{0, 0, 0}, {0, 0, 0}, {0, 0, 0}};  
       for (int row = 0; row < 3; row++) {  
           for (int col = 0; col < 3; col++) {  
               for (int inner = 0; inner < 2; inner++) {  
                   product[row][col] += aMatrix[row][inner] * bMatrix[inner][col];  
               }  
               std::cout << product[row][col] << "  ";  
           }  
           std::cout << "\n";  
       }  
   }  
   int  main() {  
       MultiplyWithOutAMP();  
       return 0;
   }  
<end>ai-matrix multiplaction
<start>ai-array multiplaction
#include<bits/stdc++.h>
using namespace std;
int number;
int M[12][12],S[12][12];
void print_optimal_parens(int i,int j)
{
    if(i==j)
    {
        printf("A%d",i);
    }
    else
    {
        printf("(");
        print_optimal_parens(i,S[i][j]);
        printf(" x ");
        print_optimal_parens(S[i][j]+1,j);
        printf(")");
    }
}

int main()
{
   /* freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);*/
    int y=1;
    while(scanf("%d",&number)==1&&number!=0)
    {
        int i,j,k,l=0,m,n,A[number+1];
        for(i=0;i<number;i++)
        {
            scanf("%d %d",&m,&n);
            if(i==0)
            {
                A[l++]=m;
            }
            A[l++]=n;
        }
       // for(i=1;i<=number+1;i++)printf("%d ",A[i]);

        for(i=1;i<=number;i++)M[i][i]=0;
        for(l=2;l<=number;l++)
        {
            for(i=1;i<=number+1-l;i++)
            {
                j=i+l-1;
                M[i][j]=2000000000;
                for(k=i;k<j;k++)
                {
                    int q=M[i][k]+M[k+1][j]+A[i-1]*A[k]*A[j];
                    if(q<M[i][j])
                    {
                        M[i][j]=q;
                        S[i][j]=k;
                    }
                }
            }
        }
        printf("Case %d: ",y++);
        print_optimal_parens(1,number);
        printf("\n");
    }
    return 0;
}
<end>ai-array multiplaction
<start>ai-factorial java biginteger
import java.math.*;
public class temp
{
    public static BigInteger factorial(BigInteger n) {
    BigInteger result = BigInteger.ONE;

    while (!n.equals(BigInteger.ZERO)) {
        result = result.multiply(n);
        n = n.subtract(BigInteger.ONE);
    }

    return result;
}
	public static void main(String[] args) 
	{
	    	BigInteger bi1, bi2, bi3;  
	    		bi1 = new BigInteger("5000");
	    			bi2 = new BigInteger("123456789556");
	    int i=144;
		System.out.println("Hello World! "+factorial(bi1));
	}
}





<end>ai-factorial java biginteger
<start>ai-gcd 
import java.math.*;
public class temp
{
    public static BigInteger factorial(BigInteger n) {
    BigInteger result = BigInteger.ONE;

    while (!n.equals(BigInteger.ZERO)) {
        result = result.multiply(n);
        n = n.subtract(BigInteger.ONE);
    }

    return result;
}
private static int gcdThing(int a, int b) {
    BigInteger b1 = BigInteger.valueOf(a);
    BigInteger b2 = BigInteger.valueOf(b);
    BigInteger gcd = b1.gcd(b2);
    return gcd.intValue();
}
	public static void main(String[] args) 
	{
	    	BigInteger bi1, bi2, bi3;  
	    		bi1 = new BigInteger("50002");
	    			bi2 = new BigInteger("123456789556");
	    int i=144;
	    
		System.out.println("Hello World! "+factorial(bi1));
		System.out.println(gcdThing(4,2));

	}
}


<end>ai-gcd 
<start>ai-input output java rotate array
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
 
public class MonkAndRotation {
 
	public static void main(String[] args) throws Exception {
		FastIO fio = new FastIO();
		OutputWriter out = new OutputWriter(System.out);
		int t = fio.nextint();
		while (t-- > 0) {
			int N = fio.nextint();
			int R = fio.nextint();
			int[] a = new int[N];
			for (int i = 0; i < N; i++) {
				a[(i + R) % N] = fio.nextint();
			}
			out.printIntArray(a);
		}
		out.close();
		fio.close();
	}
}
 
class FastIO {
	private DataInputStream din;
	final private int BUFFER_SIZE = 1 << 16;
	private byte[] buffer;
	private int bufferPointer, bytesRead;
 
	public FastIO() {
		din = new DataInputStream(System.in);
		buffer = new byte[BUFFER_SIZE];
		bufferPointer = bytesRead = 0;
	}
 
	public String readLine() throws IOException {
		byte[] buf = new byte[64];
		int cnt = 0, c;
		while ((c = read()) != -1) {
			if (c == '\n') {
				break;
			}
			buf[cnt++] = (byte) c;
		}
		return new String(buf, 0, cnt);
	}
 
	public int nextint() throws IOException {
		int ret = 0;
		byte c = read();
		while (c <= ' ')
			c = read();
		boolean neg = (c == '-');
		if (neg)
			c = read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = read()) >= '0' && c <= '9');
		if (neg)
			return -ret;
		return ret;
	}
 
	public long nextLong() throws IOException {
		long ret = 0;
		byte c = read();
		while (c <= ' ')
			c = read();
		boolean neg = (c == '-');
		if (neg)
			c = read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = read()) >= '0' && c <= '9');
		if (neg)
			return -ret;
		return ret;
	}
 
	public double nextDouble() throws IOException {
		double ret = 0, div = 1;
		byte c = read();
		while (c <= ' ')
			c = read();
		boolean neg = (c == '-');
		if (neg)
			c = read();
 
		do {
			ret = ret * 10 + c - '0';
		} while ((c = read()) >= '0' && c <= '9');
 
		if (c == '.') {
			while ((c = read()) >= '0' && c <= '9') {
				ret += (c - '0') / (div *= 10);
			}
		}
 
		if (neg)
			return -ret;
		return ret;
	}
 
	public int[] readIntArray(int size) throws IOException {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = nextint();
		return array;
	}
 
	private byte read() throws IOException {
		if (bufferPointer == bytesRead) {
			fillBuffer();
		}
		return buffer[bufferPointer++];
	}
 
	private void fillBuffer() throws IOException {
		bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
		if (bytesRead == -1) {
			buffer[0] = -1;
		}
	}
 
	public void close() throws IOException {
		if (din == null) {
			return;
		}
		din.close();
	}
}
 
class OutputWriter {
	private final PrintWriter writer;
 
	public OutputWriter(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}
 
	public OutputWriter(Writer writer) {
		this.writer = new PrintWriter(writer);
	}
 
	public void print(Object... objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}
 
	public void printIntArray(int objects[]) {
		for (int i = 0; i < objects.length; i++) {
			writer.print(objects[i]);
			writer.print(' ');
		}
		writer.println();
	}
 
	public void printLine(Object... objects) {
		print(objects);
		writer.println();
	}
 
	public void close() {
		writer.close();
	}
 
	public void flush() {
		writer.flush();
	}
 
}





<end>ai-input output java rotate array
<start>ai-input output java rotate array
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
 
public class MonkAndRotation {
 
	public static void main(String[] args) throws Exception {
		In fio = new In();
		Out out = new Out(System.out);
		int t = fio.nextint();
		while (t-- > 0) {
			int N = fio.nextint();
			int R = fio.nextint();
			int[] a = new int[N];
			for (int i = 0; i < N; i++) {
				a[(i + R) % N] = fio.nextint();
			}
			out.printIntArray(a);
		}
		out.close();
		fio.close();
	}
}
 
class In {
	private DataInputStream din;
	final private int BUFFER_SIZE = 1 << 16;
	private byte[] buffer;
	private int bufferPointer, bytesRead;
 
	public In() {
		din = new DataInputStream(System.in);
		buffer = new byte[BUFFER_SIZE];
		bufferPointer = bytesRead = 0;
	}
 
	public String readLine() throws IOException {
		byte[] buf = new byte[64];
		int cnt = 0, c;
		while ((c = read()) != -1) {
			if (c == '\n') {
				break;
			}
			buf[cnt++] = (byte) c;
		}
		return new String(buf, 0, cnt);
	}
 
	public int nextint() throws IOException {
		int ret = 0;
		byte c = read();
		while (c <= ' ')
			c = read();
		boolean neg = (c == '-');
		if (neg)
			c = read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = read()) >= '0' && c <= '9');
		if (neg)
			return -ret;
		return ret;
	}
 
	public long nextLong() throws IOException {
		long ret = 0;
		byte c = read();
		while (c <= ' ')
			c = read();
		boolean neg = (c == '-');
		if (neg)
			c = read();
		do {
			ret = ret * 10 + c - '0';
		} while ((c = read()) >= '0' && c <= '9');
		if (neg)
			return -ret;
		return ret;
	}
 
	public double nextDouble() throws IOException {
		double ret = 0, div = 1;
		byte c = read();
		while (c <= ' ')
			c = read();
		boolean neg = (c == '-');
		if (neg)
			c = read();
 
		do {
			ret = ret * 10 + c - '0';
		} while ((c = read()) >= '0' && c <= '9');
 
		if (c == '.') {
			while ((c = read()) >= '0' && c <= '9') {
				ret += (c - '0') / (div *= 10);
			}
		}
 
		if (neg)
			return -ret;
		return ret;
	}
 
	public int[] readIntArray(int size) throws IOException {
		int[] array = new int[size];
		for (int i = 0; i < size; i++)
			array[i] = nextint();
		return array;
	}
 
	private byte read() throws IOException {
		if (bufferPointer == bytesRead) {
			fillBuffer();
		}
		return buffer[bufferPointer++];
	}
 
	private void fillBuffer() throws IOException {
		bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
		if (bytesRead == -1) {
			buffer[0] = -1;
		}
	}
 
	public void close() throws IOException {
		if (din == null) {
			return;
		}
		din.close();
	}
}
 
class Out {
	private final PrintWriter writer;
 
	public Out(OutputStream outputStream) {
		writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
	}
 
	public Out(Writer writer) {
		this.writer = new PrintWriter(writer);
	}
 
	public void print(Object... objects) {
		for (int i = 0; i < objects.length; i++) {
			if (i != 0)
				writer.print(' ');
			writer.print(objects[i]);
		}
	}
 
	public void printIntArray(int objects[]) {
		for (int i = 0; i < objects.length; i++) {
			writer.print(objects[i]);
			writer.print(' ');
		}
		writer.println();
	}
 
	public void printLine(Object... objects) {
		print(objects);
		writer.println();
	}
 
	public void close() {
		writer.close();
	}
 
	public void flush() {
		writer.flush();
	}
 
}






<end>ai-input output java rotate array
<start>ai-java quick sort
import java.util.Arrays;
import java.util.Scanner;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

/**
 *
 * @author gagssing
 */
public class uniqsubarray {
   static  int partition(char[] arr, int left, int right)
{
      int i = left, j = right;
      char tmp;
      int pivot = arr[(left + right) / 2];
     
      while (i <= j) {
            while (arr[i] < pivot)
                  i++;
            while (arr[j] > pivot)
                  j--;
            if (i <= j) {
                  tmp = arr[i];
                  arr[i] = arr[j];
                  arr[j] = tmp;
                  i++;
                  j--;
            }
      };
     
      return i;
}
 
static void quickSort(char[] arr, int left, int right) {
      int index = partition(arr, left, right);
      if (left < index - 1)
            quickSort(arr, left, index - 1);
      if (index < right)
            quickSort(arr, index, right);
}
    public static void main(String... args) throws Exception{
        
    Scanner in=new Scanner(System.in);
    int t=in.nextInt();
    String s="";
    while(t-->0)
    {
        s=in.next();
        quickSort(s.toCharArray(),0,s.length());
        System.out.println(s);
    }
    
    
    
}
}

	






<end>ai-java quick sort
<start>ai-remove duplicate char from string
import java.util.Arrays;
import java.util.Scanner;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.*;
/**
 *
 * @author dawood abbaspour
 */
public class uniqsubarray {
static String removeDuplicates(String s) {
    StringBuilder noDupes = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        String si = s.substring(i, i + 1);
        if (noDupes.indexOf(si) == -1) {
            noDupes.append(si);
        }
    }
    return noDupes.toString();
}
    public static void main(String... args) throws Exception{
        
    Scanner in=new Scanner(System.in);
    int t=in.nextInt();
    String s="";
    while(t-->0)
    {
        s=in.next();
     
        System.out.println(removeDuplicates(s).length()==26?"YES":"NO");
       
    }
}
}

	







<end>ai-remove duplicate char from string
<start>ai-find char string
import java.util.Arrays;
import java.util.Scanner;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.*;
import java.lang.*;

/**
 *
 * @author dawood abbaspour
 * 
 */
public class uniqsubarray {
static String removeDuplicates(String s) {
    StringBuilder noDupes = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        String si = s.substring(i, i + 1);
        if (noDupes.indexOf(si) == -1) {
            noDupes.append(si);
        }
    }
    return noDupes.toString();
}
    public static void main(String... args) throws Exception{
    Scanner in=new Scanner(System.in);
    
    String s="";
   
        s=in.next();
     
      for(int i=0;i<=9;i++)
      {
      int count = s.length() - s.replace(""+i, "").length();
    System.out.println(i+" "+count);
      }
    
}
}

	








<end>ai-find char string
<start>ai-contignous sum java
import java.util.Arrays;
import java.util.Scanner;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;
import java.util.*;
import java.lang.*;

/**
 *
 * @author dawood abbaspour
 * 
 */
public class uniqsubarray {
static int maxSubArraySum(int a[])
    {
        int size = a.length;
        int max_so_far = 0, max_ending_here = 0;
 
        for (int i = 0; i < size; i++)
        {
            max_ending_here = max_ending_here + a[i];
            if (max_ending_here < 0)
                max_ending_here = 0;
            if (max_so_far < max_ending_here)
                max_so_far = max_ending_here;
        }
        return max_so_far;
    }
    public static void main(String... args) throws Exception{
    Scanner in=new Scanner(System.in);
    int t=in.nextInt();
    int[] a=new int[t];
    for(int i=0;i<t;i++)
    a[i]=in.nextInt();
    System.out.println(maxSubArraySum(a));;
      }
    

}

	









<end>ai-contignous sum java
<start>ai-license
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

<end>ai-license
<start>ai-checked safe java tree diameter
import java.io.*;
import java.util.*;
import java.text.*;
class newfile{
	static int root=1;
    static long hnd=0,fist=0;
    static int superiors[];
    static ArrayList<Integer>[] adj;
    
    static void size()
    {
                HashSet<Integer> visited = new HashSet<>();
        Queue<Integer> queue = new ArrayDeque<>();
        HashSet<Integer> list = new HashSet<>();
        queue.add(root);
        visited.add(root);
        Integer current;
        int nbr;
        while (queue.size()>0){
            current = queue.remove();
            list.add(current);
            for (int i = 0; i < adj[current].size(); i++) {
                nbr = (int) adj[current].get(i);
                if (!visited.contains(nbr)) {
                    visited.add(nbr);
                    queue.add(nbr);
                    superiors[nbr] = superiors[current]+1;
                }
            }
        }
    
    }
    @SuppressWarnings("unchecked")
	public static void main(String[] args) throws Exception
    {
	   //new FileInputStream("input.txt");
		//new FileOutputStream("output.txt")
		InputReader in = new InputReader(System.in);
		OutputWriter out = new OutputWriter(System.out);		
  		int t=in.ri();
  		long hnd=0,fist=0;
  		
  		for(int it=0;it<t;it++){
			int n=in.ri()+1;
			superiors = new int[n];
			adj =new ArrayList[n]; // Create array of lists.
			for (int v = 1; v <n; v++) // Initialize all lists
			adj[v] = new ArrayList<Integer>();
			int p;
			for(int i=1;i<n;i++){p=in.ri();
				if(p==0)root=i;
				else{
					adj[p].add(i);
				}
			}
			size();
			hnd = 0;
            for (int i = 1; i < n; i++) {
                hnd += superiors[i];
            }
            n=n-1;
			long ans=(long)n*(long)(n-1);
			ans=ans/2;
			fist=ans-hnd;
			out.pl(hnd+" "+fist);
		}
  		out.close();
	}
private static class InputReader
	{
		private InputStream stream;
		private byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;
		private SpaceCharFilter filter;
		 
		public InputReader(InputStream stream)
		{
			this.stream = stream;
		}
 
		public int read()
		{
			if (numChars == -1)
				throw new InputMismatchException();
			if (curChar >= numChars)
			{
				curChar = 0;
				try
				{
					numChars = stream.read(buf);
				} catch (IOException e)
				{
					throw new InputMismatchException();
				}
				if (numChars <= 0)
				return -1;
			}
			return buf[curChar++];
		}
		
        
		public int ri()
		{
			int c = read();
			while (isSpaceChar(c))
				c = read();
			int sgn = 1;
			if (c == '-')
			{
				sgn = -1;
				c = read();
			}
			int res = 0;
			do
			{
				if (c < '0' || c > '9')
					throw new InputMismatchException();
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			return res * sgn;
		}
		
		public boolean isSpaceChar(int c)
		{
			if (filter != null)
				return filter.isSpaceChar(c);
			return c == ' ' || c == '\n' || c == '\r' || c == '\t' || c == -1;
		}
 
		
 
		public interface SpaceCharFilter
		{
			public boolean isSpaceChar(int ch);
		}
	}
 
	private static class OutputWriter
	{
		private final PrintWriter writer;
 
		public OutputWriter(OutputStream outputStream)
		{
			writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
		}
 
		public OutputWriter(Writer writer)
		{
			this.writer = new PrintWriter(writer);
		}
 		public void print(Object... objects)
		{
			for (int i = 0; i < objects.length; i++)
			{
				if (i != 0)
				writer.print(' ');
				writer.print(objects[i]);
			}
		}
		
		public void pl(Object... objects)
		{
			print(objects);
			writer.println();
		}
 
		public void close()
		{
			writer.close();
		}
 
		public void flush()
		{
			writer.flush();
		}
 
	}
}

<end>ai-checked safe java tree diameter
<start>ai-http://127.0.0.1:82/ace/demo/magiccodes.html?action&language=Java&filename=D:\\dawood\\source\\binarytree.java
public class binarytree {

  public static void main(String[] args) {
    new binarytree().run();
  }
  static class Node 
  {
    Node left;

    Node right;
    int value;
    public Node(int value) {
      this.value = value;
    }
  }
  public void run() {
    // build the simple tree from chapter 11.
    Node root = new Node(5);
    System.out.println("Binary Tree Example");
    System.out.println("Building tree with root value " + root.value);
    
    insert(root, 3,'r');
    insert(root, 2,'l');
    insert(root, 4,'l');
    insert(root, 5,'r');
     
    searchnode(root,"","rlr",'n');
    System.out.println("Traversing tree in order");
    printInOrder(root);
      System.out.println("Traversing tree post order");
    printPostOrder(root);
    System.out.println("Traversing tree front-to-back from location 7");
    printFrontToBack(root, 7);
  }
  public void insert(Node node, int value) {
    if (value < node.value) {
      if (node.left != null) {
        insert(node.left, value);
      } else {
        System.out.println("  Inserted " + value + " to left of "
            + node.value);
        node.left = new Node(value);
      }
    } else if (value > node.value) {
      if (node.right != null) {
        insert(node.right, value);
      } else {
        System.out.println("  Inserted " + value + " to right of "
            + node.value);
        node.right = new Node(value);
      }
    }
  }
  public void insert(Node node, int value,char l)
  {
      if (l=='l') {
      if (node.left != null) {
        insert(node.left, value);
      } else {
        System.out.println("Inserted " + value + " to left of "
            + node.value);
        node.left = new Node(value);
      }
    }
    else if (l=='r') {
      if (node.right != null) {
        insert(node.right, value);
      } else {
        System.out.println("  Inserted " + value + " to right of "
            + node.value);
        node.right = new Node(value);
      }
    }
}
  public void printInOrder(Node node) 
  {
    if (node != null) {
      printInOrder(node.left);
      System.out.println("  Traversed " + node.value);
      printInOrder(node.right);
    }
  }
  public void printPostOrder(Node node) 
  {
    if (node != null) {
      printPostOrder(node.left);
      printPostOrder(node.right);
      System.out.println("  Traversed " + node.value);

    }
  }
  public void searchnode(Node node,String l,String r,char d)
  {
     if(node!=null)
     {   
          if(d=='l')
      l+='l';
      else
      l+='r'; 
         if (node != null) {
           System.out.println("gh"+ node.value+l);

      searchnode(node.left,l,r,'l');
    
      if(l==r)
       System.out.println("v"+ node.value+l);
    
      searchnode(node.right,l,r,'r');
    
      if(l==r)
        System.out.println( "v"+node.value+l);

    }

     }
  }

  /**
   * uses in-order traversal when the origin is less than the node's value
   * 
   * uses reverse-order traversal when the origin is greater than the node's
   * order
   */
  public void printFrontToBack(Node node, int camera) 
  {
    if (node == null)
      return;
    if (node.value > camera) {
      // print in order
      printFrontToBack(node.left, camera);
      System.out.println("  Traversed " + node.value);
      printFrontToBack(node.right, camera);
    } else if (node.value < camera) {
      // print reverse order
      printFrontToBack(node.right, camera);
      System.out.println("  Traversed " + node.value);
      printFrontToBack(node.left, camera);
    } else {
      // order doesn't matter
      printFrontToBack(node.left, camera);
      printFrontToBack(node.right, camera);
    }
  }
}



<end>ai-http://127.0.0.1:82/ace/demo/magiccodes.html?action&language=Java&filename=D:\\dawood\\source\\binarytree.java
<start>ai-http://127.0.0.1:82/ace/demo/magiccodes.html?action&language=Java&filename=D:\\dawood\\source\\binarytree.java
import java.util.*;
public class binarytree {
  String sr="";   
  public static void main(String[] args) {
        
    new binarytree().run();
  }
  static class Node 
  {
    Node left;

    Node right;
    int value;
    public Node(int value) {
      this.value = value;
    }
  }
  public   void run() {
    // build the simple tree from chapter 11.
   Scanner in=new Scanner(System.in);
      int t=in.nextInt();
      int x=in.nextInt();
      int value=0;
      String s="";
          Node root = new Node(t);
      for(int i=0;i<t-1;i++)
      {
          s=in.next();
          value=in.nextInt();
          if(s.length()>sr.length())
        insert(root, value,s.toCharArray()[s.length()-1]);

      }
System.out.println(sr.length());
/*
    searchnode(root,"","rlr",'n');
    System.out.println("Traversing tree in order");
    printInOrder(root);
      System.out.println("Traversing tree post order");
    printPostOrder(root);
    System.out.println("Traversing tree front-to-back from location 7");
    printFrontToBack(root, 7);
    */
  }
  public   void insert(Node node, int value) {
    if (value < node.value) {
      if (node.left != null) {
        insert(node.left, value);
      } else {
      
        node.left = new Node(value);
      }
    } else if (value > node.value) {
      if (node.right != null) {
        insert(node.right, value);
      } else {
           
        node.right = new Node(value);
      }
    }
  }
  public void insert(Node node, int value,char l)
  {
      sr+=l;
      if (l=='L') {
      if (node.left != null) {
        insert(node.left, value);
      } else {
        node.left = new Node(value);
      }
    } else if (l=='R') {
      if (node.right != null) {
        insert(node.right, value);
      } else {
        node.right = new Node(value);
      }
    }
}
  public void printInOrder(Node node) 
  {
    if (node != null) {
      printInOrder(node.left);
      System.out.println("  Traversed " + node.value);
      printInOrder(node.right);
    }
  }
  public void printPostOrder(Node node) 
  {
    if (node != null) {
      printPostOrder(node.left);
      printPostOrder(node.right);
      System.out.println("  Traversed " + node.value);

    }
  }
  public void searchnode(Node node,String l,String r,char d)
  {
     if(node!=null)
     {   
          if(d=='l')
      l+='l';
      else
      l+='r';
      sr=l;
         if (node != null) {
           System.out.println("gh"+ node.value+l);

      searchnode(node.left,l,r,'l');
    
      if(l==r)
       System.out.println("v"+ node.value+l);
    
      searchnode(node.right,l,r,'r');
      if(l==r)
        System.out.println( "v"+node.value+l);

    }

     }
  }

  /**
   * uses in-order traversal when the origin is less than the node's value
   * 
   * uses reverse-order traversal when the origin is greater than the node's
   * order
   */
  public void printFrontToBack(Node node, int camera) 
  {
    if (node == null)
      return;
    if (node.value > camera) {
      // print in order
      printFrontToBack(node.left, camera);
      System.out.println("  Traversed " + node.value);
      printFrontToBack(node.right, camera);
    } else if (node.value < camera) {
      // print reverse order
      printFrontToBack(node.right, camera);
      System.out.println("  Traversed " + node.value);
      printFrontToBack(node.left, camera);
    } else {
      // order doesn't matter
      printFrontToBack(node.left, camera);
      printFrontToBack(node.right, camera);
    }
  }
}




<end>ai-http://127.0.0.1:82/ace/demo/magiccodes.html?action&language=Java&filename=D:\\dawood\\source\\binarytree.java
<start>ai-http://127.0.0.1:82/ace/demo/magiccodes.html?action&language=Cpp&filename=D:\\dawood\\source\\Christmasdishes.java
import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}
<end>ai-http://127.0.0.1:82/ace/demo/magiccodes.html?action&language=Cpp&filename=D:\\dawood\\source\\Christmasdishes.java
<start>ai-java binary tree
import java.util.*;

public class binarytree {

    // Root node
    int[] a=new  int[200];
    int nl=0;
    private Node root;

    public binarytree() {
        root = null;
    }

    private static class Node {
        Node left;
        Node right;
        int data;

        Node(int data) {
            left = null;
            right = null;
            this.data = data;
        }
    }

    /**
     * Return true if data is in the tree
     */
    public boolean lookup(int data) {
        return lookup(root, data);
    }

    /**
     * Recursive lookup
     */
    private boolean lookup(Node node, int data) {
        // Root node is null so tree is empty
        if(node == null)
            return false;

        if(data == node.data)
            return true;

        else if(data < node.data)
            return lookup(node.left, data);

        else
            return lookup(node.right, data);
    }

    /**
     * Insert data into the tree
     */
    public void insert(int data) {
        a[nl]=data;
        nl++;
        root = insert(root, data);
    }

    /**
     * Recursive insert
     */
    private Node insert(Node node, int data) {
        // If root is null then tree is empty
        if(node == null)
            node = new Node(data);

        else {
            if(data <= node.data)
                node.left = insert(node.left, data);
            else
                node.right = insert(node.right, data);
        }

        return node;
    }

    /**
     * Get the amount of nodes in the tree
     */
    public int size() {
        return size(root);
    }

    /**
     * Recursive size
     */
    private int size(Node node) {
        if(node == null)
            return 0;
        else
            return size(node.left) + 1 + size(node.right);
    }

    public int maxDepth() {
        return maxDepth(root);
    }

    private int maxDepth(Node node) {
        if(node == null)
            return 0;
        else {
            int leftDepth = maxDepth(node.left);
            int rightDepth = maxDepth(node.right);

            return leftDepth > rightDepth ? leftDepth + 1 : rightDepth + 1;
        }
    }

    public int minValue() {
        return minValue(root);
    }

    private int minValue(Node node) {
        if(node.left == null)
            return node.data;
        else
            return minValue(node.left);
    }

    public int maxValue() {
        return maxValue(root);
    }

    private int maxValue(Node node) {
        if(node.right == null)
            return node.data;
        else
            return maxValue(node.right);
    }
    public int maxValue(int x,int y) {
        int max=a[0];
       for(int i=1;i<nl;i++)
        if(a[i]>max)
         if((a[i]<=y)&&(a[i]>=x))
          max=a[i];
        return max;
    }

   private int maxValue(Node node,int x,int y) {
       
        if(node.right == null)
            return node.data;
        else
            return maxValue(node.right);
            
    }

    public static void main(String[] args) {
        binarytree binaryTree = new binarytree();
        Scanner in=new Scanner(System.in);
        int t=in.nextInt();
        int nx,ny;
       
        int x=0,y=0;
        int n=0;
        int max=0;
        for(int i=0;i<t;i++)
        {
            n=in.nextInt();
            
        binaryTree.insert(n);

        }
       x=in.nextInt();  y=in.nextInt();
       for(int i=0;i<t;i++)
       {
           if(binaryTree.lookup(x))
       nx=i;
        if(binaryTree.lookup(y))
       ny=i;
       }
       System.out.println(binaryTree.maxValue(x,y));      

    }
}








<end>ai-java binary tree
<start>ai-pair sum
import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}


<end>ai-pair sum
<start>ai-javahello
import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}




<end>ai-javahello
<start>ai-javahello
import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}




<end>ai-javahello
<start>ai-glossary topcoder
import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}




import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}






<end>ai-glossary topcoder
<start>ai-samplejava
import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}




import java.util.*;
public class Christmasdishes {
  /*data[] ---> Temporary array to store current combination
    start & end ---> Staring and Ending indexes in arr[]
    index  ---> Current index in data[]
    r ---> Size of a combination to be printed */
    static char[] combinationUtil(char arr[], int n, int r, int index,
                                char data[], int i)
    {
        // Current combination is ready to be printed, print it
        if (index == r)
        {
            for (int j=0; j<r; j++)
                System.out.print(data[j]);
            System.out.println(""+data.length);
        return data;
        }
 
        // When no more elements are there to put in data[]
        if (i >= n)
        return data;
 
        // current  is included, put next at next location
        data[index] = arr[i];
        combinationUtil(arr, n, r, index+1, data, i+1);
 
        // current is excluded, replace it with next (Note that
        // i+1 is passed, but index is not changed)
       System.out.print( combinationUtil(arr, n, r, index, data, i+1) );
        return data;
    }
 
    // The main function that prints all combinations of size r
    // in arr[] of size n. This function mainly uses combinationUtil()
    static void printCombination(char arr[], int n, int r)
    {
        // A temporary array to store all combination one by one
        char data[]=new char[r];
 
        // Print all combination using temprary array 'data[]'
                       System.out.print( combinationUtil(arr, n, r, 0, data, 0).length);
    }
 
    /*Driver function to check for above function*/
    public static void main (String[] args) {
        char arr[] = {'a', 'a', 'a'};
        int r = 1;
        int n = arr.length;
        for(int i=1;i<=arr.length;i++)
        printCombination(arr, n, i);
    }
}








<end>ai-samplejava
<start>ai-welcomedawood
welcome dawood
<end>ai-welcomedawood
<start>ai-welcome1
#include<bits/stdc++.h>
using namespace sgd;
int main(void)
{
	return 0;
}










<end>ai-welcome1
<start>ai-welcome1
ddddddddd
d
<end>ai-welcome1
<start>ai-dfdfd
import java.util.*;
public class test
{
public static void main(String args[])
{
Scanner in=new Scanner(System.in);
int i=in.nextInt();
System.out.println(i);
}

}


<end>ai-dfdfd
<start>testwriting
welcome writing
<end>testwriting
<start>sssd
ssds
<end>sssd
<start>namespacestd
using namespace std;
<end>namespacestd
<start>w
sdsd
<end>w
<start>dsaw
ddddddddddddddd
<end>dsaw
<start>ai-map find
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <map>
#include <unordered_map>
#include <string>

using namespace std;

int main() 
{
    /* Enter your code here. Read input from STDIN. Print output to STDOUT */   
    int n;
    cin >> n;
    
    unordered_map <string, int> m;
    string key;
    int val;
    
    for (int i=0; i<n; i++)
    {
        cin >> key >> val;
        m[key] = val;
    }
    
    string input;
    while (cin >> input)
    {
        unordered_map <string, int>::const_iterator got = m.find (input);
    
        if (got==m.end())
            cout << "Not found" << endl;
        else
            cout << got->first << "=" << got->second << endl;
    }

    return 0;
}
<end>ai-map find
<start>ai-array2d block sum
#include <map>
#include <set>
#include <list>
#include <cmath>
#include <ctime>
#include <deque>
#include <queue>
#include <stack>
#include <string>
#include <bitset>
#include <cstdio>
#include <limits>
#include <vector>
#include <climits>
#include <cstring>
#include <cstdlib>
#include <fstream>
#include <numeric>
#include <sstream>
#include <iostream>
#include <algorithm>
using namespace std;


int main(){
    int c,max;
    vector< vector<int> > arr(6,vector<int>(6));
    for(int arr_i = 0;arr_i < 6;arr_i++){
       for(int arr_j = 0;arr_j < 6;arr_j++){
          cin >> arr[arr_i][arr_j];
       }
    }
    c=0;max=0;
    for(int row=0;row<=3;row++)
     for(int col=0;col<=3;col++)
    {
       c=arr[row][col]+arr[row][col+1]+arr[row][col+2]+arr[row+1][col+1]+arr[row+2][col]+arr[row+2][col+1]+arr[row+2][col+2];
        if(max<c)
        max=c;
    }
    cout<<max;
    return 0;
}
<end>ai-array2d block sum
<start>ai-class inheritance
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;
class Book{
    protected:
        string title;
        string author;
    public:
        Book(string t,string a){
            title=t;
            author=a;
        }
        virtual void display()=0;

};

class MyBook : public Book {
	private:
		int price;

	public:
		MyBook(string t, string a, int Price)
			: Book(t, a ) {
			price=Price;
		}

		void display() {
		cout<<"Title: "<<title<<endl;
        cout<<"Author: "<<author<<endl;
        cout<<"Price: "<<price<<endl;
		}
};

int main() {
    string title,author;
    int price;
    getline(cin,title);
    getline(cin,author);
    cin>>price;
    MyBook novel(title,author,price);
    novel.display();
    return 0;
}

<end>ai-class inheritance
<start>ai-game remove object
#include <iostream>
using namespace std;
bool stones[101], stones2[101];
int main() {
	int tests;
	cin >> tests;
	while(tests --> 0)
	{
	   	int n;
	cin >> n;

	stones[1] = stones2[1] = false;
	stones[2] = stones2[2] = true;
	stones[3] = stones2[3] = true;
	stones[4] = stones2[4] = true;
	stones[5] = stones2[5] = true;

	for(int i=6; i<=n; i++){
		stones[i] = !stones2[i-2] || !stones2[i-3] || !stones2[i-5];
		stones2[i] = !stones[i-2] || !stones[i-3] || !stones[i-5];
	}

	cout << (stones[n] ? "First" : "Second") << endl;
	}
	return 0;
}
<end>ai-game remove object
<start>ai-hex to int add
#include<bits/stdc++.h> 
using namespace std;

int main()
{
 long n,m;
 cin>>std::hex>>n;
 stringstream stream1;
string s1="";
 m=n+1;
 
  stream1<<std::hex<<m;
  s1=stream1.str();
  for(int i=0;i<s1.length();i++)
   if(s1[i]=='0')
   s1[i]=' ';
   else
    break;
  cout<<s1;
  return 0;
 }

<end>ai-hex to int add
<start>ai-heap sort
#include<bits/stdc++.h>
using namespace std;
void max_heapify(int *a, int i, int n)
{
    int j, temp;
    temp = a[i];
    j = 2*i;
    while (j <= n)
    {
        if (j < n && a[j+1] > a[j])
            j = j+1;
        if (temp > a[j])
            break;
        else if (temp <= a[j])
        {
            a[j/2] = a[j];
            j = 2*j;
        }
    }
    a[j/2] = temp;
    return;
}
void heapsort(int *a, int n)
{
    int i, temp; 
    for (i = n; i >= 2; i--)
    {
        temp = a[i];
        a[i] = a[1];
        a[1] = temp;
        max_heapify(a, 1, i - 1);
    }
}
int heapsum(int *a,int i,int n)
{
    int product=-1;
     for(int j=i;j<n;j++)
      if(a[j]>a[2])
      {
          
      if(product<0)
      product=1;
       product*=a[j];
      }
      return product;
}
void build_maxheap(int *a, int n)
{
    int i;
    for(i = n/2; i >= 1; i--)
    {
        max_heapify(a, i, n);
    }
}
int main()
{
    int n, i, x;
    cin>>n;
    int a[n+1];
    for (i = 1; i <= n; i++)
    {
         cin>>a[i];
    }
    build_maxheap(a,n);
    heapsort(a,n);
    for( i=1;i<=n;i++)
    cout<<heapsum(a,i,n)<<endl;
}
<end>ai-heap sort
<start>ai-max min prirityqueue
#include <bits/stdc++.h>
using namespace std;
int main() {
  int n,m,p;
  int cost=0;
  cin>>m>>n;
   priority_queue<int> x;
  for(int i=0;i<m;i++)
 { cin>>p;
    x.push(p);
 }
  for(int i=0;i<n;i++)
  {
      p=x.top();
      cost+=p;
      x.pop();
       p--;
      x.push(p);
  }
  cout<<cost;
 return 0;
}
<end>ai-max min prirityqueue
<start>ai-priorityqueue class compare
#include<bits/stdc++.h>
using namespace std;
using namespace std;
class post{
    public:
        long long int id,zscore,nzscore,post,likes,comment,share;
        void calculate()
        {
            nzscore=post*50+likes*5+comment*10+share*20;
        }
       
};
struct Comp{
    bool operator()(const post& a, const post& b){
        if((a.nzscore-a.zscore)==(b.nzscore-b.zscore))
                return a.id<b.id;

        return a.nzscore-a.zscore<b.nzscore-b.zscore;
    }
};
int main(){
    int n;
    cin>>n;
    post p[n];//50 5 10 20
    for(int i=0;i<n;i++)
    {
        cin>>p[i].id>>p[i].zscore>>p[i].post>>p[i].likes>>p[i].comment>>p[i].share;
        p[i].calculate();
    }
  

    priority_queue< post, vector<post>, Comp> pq;
    for(int i=0;i<n;i++)
    pq.push(p[i]);
    int c=0;
    while (!pq.empty())
    {
    
    post b = pq.top();
    cout<<b.id<<" "<<b.nzscore<<endl;
    pq.pop();
    c++;
    if(c==5)
    break;
    }
    return 0;
}
<end>ai-priorityqueue class compare
<start>ai-queue advanced priority
#include<bits/stdc++.h>
using namespace std;

template<typename T>
class adpriorityqueue : public std::priority_queue<T, std::vector<T>>
{
  public:

      int remove(const T& value) {
        auto it = std::find(this->c.begin(), this->c.end(), value);
        if (it != this->c.end()) {
            this->c.erase(it);
            std::make_heap(this->c.begin(), this->c.end(), this->comp);
            return 1;
       }
       else {
        return -1;
       }
 }
   void removeid(int id) {
       
            this->c.erase(this->c.begin()+id);
            std::make_heap(this->c.begin(), this->c.end(), this->comp);
          
 }
 void update(int id,const T& value) {
      
            this->c[id]=value;
            std::make_heap(this->c.begin(), this->c.end(), this->comp);
       }
  int min()
  {
      return this->c[0];
  }
  int max()
  {
      return this->c.front();
  }
 
};
int main(){
  adpriorityqueue<int> p;
    p.push(12);
    p.push(-2);
    p.push(7);
    p.update(2,3);
    p.removeid(0);
    while(!p.empty()){
    int t=p.top();
    cout<<t<<endl;
    p.pop();
 }
 cout<<p.max();
    return 0;
}


<end>ai-queue advanced priority
<start>ai-matrix same value
#include <bits/stdc++.h>
using namespace std;
#define ll long long int
const long long int N=1e5+55;
int main() {
      int t;
      scanf("%d",&t);
      while(t--){
            int n;
            scanf("%d",&n);
            int a[n+1][n+1],dp[n+1][n+1];
            memset(dp,0,sizeof(dp));
            for(int i=0;i<n;i++)
                for(int j=0;j<n;j++)
                    scanf("%d",&a[i][j]);
            int xx=0;
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    if(i && j && a[i][j]==a[i-1][j] && a[i][j]==a[i][j-1] && a[i][j]==a[i-1][j-1])
                        dp[i][j]=min(min(dp[i-1][j-1],dp[i-1][j]),dp[i][j-1])+1;
                    else
                        dp[i][j]=1;
                    xx=max(dp[i][j],xx);
 
                }
            }
 
          printf("%d\n",xx);
      }
    return 0;
}
<end>ai-matrix same value
<start>ai-vector print all
    copy(v.begin(), v.end(), ostream_iterator<string>(cout, "\n"));

<end>ai-vector print all
<start>ai-vector find string
#include <cmath>
if (std::find(v.begin(), v.end(), "abc") != v.end())
}


<end>ai-vector find string
<start>ai-diary
hi all\
this is diary
<end>ai-diary
<start>ai-diary
hi all\
this is diary welcome to all


<end>ai-diary
<start>ai-array consecutive squares 
#include<bits/stdc++.h>
using namespace std;
//https://www.hackerrank.com/contests/womens-codesprint-3/challenges/the-birthday-bar
int c=0;
int calc(vector<int> a, int m,int sum1)
{
    int sum = 0;
    
    int stmax = (a.size() - m) ; 
    for(int st=0;st <= stmax; st++)
    {       
        
        sum=0;

        for(int i = 0; i < m; i++)
        {
            sum = sum + a[st+i];
        }
        if(sum==sum1)
        c++;
       
        
    }
    return 0;   
}
int main()
{
    
    int n,m,p,t;
    cin>>t;
     vector<int> a(t);
     for(int i=0;i<t;i++)
     cin>>a[i];
    cin>>n>>m;
    calc(a,m,n);
    cout<<c<<endl;
   return 0;
}
<end>ai-array consecutive squares 
<start>ai-testblue
#ddd
d
d
ddddd
ddd
d
d
<end>ai-testblue
<start>ai-testeditor
#include <bits/stdc++.h>
using namespace std;
int main()
{
string s1,s2; string p1,p2;

int a,b;
cin>>s1>>s2;
	   p1=s1;p2=s2;
reverse(s1.begin(),s1.end());
reverse(s2.begin(),s2.end());
a=stoi(s1);b=stoi(s2);
if(a<b)
cout<<p1<<" < "<<p2<<endl;
else if(a>b)
cout<<p2<<" < "<<p1<<endl;
else
   cout<<p2<<" = "<<p1<<endl;
  return 0;
}



<end>ai-testeditor
<start>ai-dsdsdxc
dsdsd
<end>ai-dsdsdxc
<start>ai-string toupper tolower
//topcoder dancing centence
#include<bits/stdc++.h>
using namespace std;
int main()
{
string s="";
int i1=0;
getline(cin,s);
for(int i=0;i<s.length();i++)
if(i1==0)
{
if(s[i]!=' ')

{s[i]=toupper(s[i]);
i1++;
}
}
else
{
if(s[i]!=' ')
{
i1=0;
s[i]=tolower(s[i]);
}
}
cout<<s;
return 0;
} 
 

<end>ai-string toupper tolower
<start>ai-duplicate remove insert
writeai-duplicate remove insert
<end>ai-duplicate remove insert
<start>ai-removem duplicate insert
// A complete working C program to demonstrate all insertion methods
// on Linked List
#include <bits/stdc++.h>
 using namespace std;
    
     
    /* Driver program to test above functions*/
int main()
{
   
    int n,m;
    cin>>n;
    vector<int> a; 
    for(int i=0;i<n;i++)
     {
        cin>>m ;
        if (!( std::find(a.begin(), a.end(), m) != a.end() ))
         a.push_back(m);
     }
          
    for(int i=0;i<a.size();i++)
       cout<<a[i]<<" ";
    
  return 0;
}
<end>ai-removem duplicate insert
<start>ai-dawood2
writeai-dawood2
<end>ai-dawood2
<start>ai-dawood2

<end>ai-dawood2
<start>ai-dawood2
dawood
<end>ai-dawood2
<start>ai-map two dimensional
a
<end>ai-map two dimensional
<start>ai-dada
st
<end>ai-dada
<start>ai-dada1
dada
<end>ai-dada1
<start>ai-dada2
dada1
<end>ai-dada2
<start>ai-dada5
ddadadw

<end>ai-dada5
<start>ai-newd
adddd



<end>ai-newd
<start>ai-decimaltobinary
#include<bits/stdc++.h>
using namespace std;

string DecimalToBinaryString(int a)
{
    int b = (int)a;
    string binary = "";
    int mask = 0x80000000u;
    while (mask > 0)
    {
        binary += ((b & mask) == 0) ? '0' : '1';
        mask >>= 1;
    }
    cout<<binary<<endl;
    return binary;
}
int main()
{
	cout<<DecimalToBinaryString(12);
	return 0;
}



<end>ai-decimaltobinary
<start>ai-decimaltobinary

<end>ai-decimaltobinary
<start>ai-decimaltobinary
#include<bits/stdc++.h>
using namespace std;

string DecimalToBinaryString(int a)
{
    int b = (int)a;
    string binary = "";
    int mask = 0x80000000u;
    while (mask > 0)
    {
        binary += ((b & mask) == 0) ? '0' : '1';
        mask >>= 1;
    }
    cout<<binary<<endl;
    return binary;
}
int main()
{
	cout<<DecimalToBinaryString(12);
	return 0;
}



<end>ai-decimaltobinary
<start>ai-binary consecutiveone
#include <bits/stdc++.h>
#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))
typedef long long ll;
using namespace std;
class ConsecutiveOnes {
	 public:
	 

ll get(ll n, int k) {
    ll mask = 0; repeat (i,k) mask = (mask << 1) | 1;
    auto pred = [&](ll m) {
        for (ll s = mask; s > 0; s <<= 1) {
            if ((m & s) == s) {
                return true;
            }
        }
        return false;
    };
    ll m = n | mask;
    for (ll i = 1ll << 52; i; i >>= 1) {
        ll nm = m & (~ i);
        if (n <= nm and pred(nm)) {
            m = nm;
        }
    }
    return m;
}
};
int main()
{
	ConsecutiveOnes m;
	 cout<<endl<<m.get(364269800189924,33);;
	return 0;
}





<end>ai-binary consecutiveone
<start>ai-power of two not operator
#include<bits/stdc++.h>
using namespace std;
bool isPowerOfTwo(int x)
    {
        // flip int for check is power of two
        return (x && !(x & (x - 1)));
    }
int main()
{
   
    
	  cout<<isPowerOfTwo(8);
    return 0;
}

<end>ai-power of two not operator
<start>ai-not bit two number n n-1
#include<bits/stdc++.h>
using namespace std;
bool isPowerOfTwo(int x)
    {
        // flip int for check is power of two
        return (x && !(x & (x - 1)));
    }
int main()
{
   
    
	  cout<<isPowerOfTwo(8);
    return 0;
}



<end>ai-not bit two number n n-1
<start>ai-ith bit is set
#include<bits/stdc++.h>
using namespace std;
bool check (int N,int i)
    {
        if( N & (1 << i) )
            return true;
        else
            return false;
    }
int main()
{
   
    
	  cout<<check(8,2);
    return 0;
}





<end>ai-ith bit is set
<start>ai-shift bit ithbit is set
#include<bits/stdc++.h>
using namespace std;
bool check (int N,int i)
    {
        if( N & (1 << i) )
            return true;
        else
            return false;
    }
int main()
{
   
    
	  cout<<check(8,2);
    return 0;
}





<end>ai-shift bit ithbit is set
<start>ai-Subsets 3 character
#include<bits/stdc++.h>
using namespace std;
int convert(int n)
{
	 
     int i;

    for (i = 0; i < 3; ++i)
     {  // assuming a 32 bit int
       int p= n & (1 << i) ? 1 : 0;
       if(p)
       {
        if(i==0)
         cout<<"a";
         if(i==1)
         cout<<"b";
         if(i==2)
         cout<<"c";
       }
       
      }
     
}
int main()
{
   
    for(int i=1;i<8;i++)
	 {
	 	convert(i);
	 	cout<<endl;
     }
    return 0;
}





<end>ai-Subsets 3 character
<start>ai-frequency number array minimum
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int t,n,p;
	cin>>t;
	while(t--)
	{
		cin>>n;
       vector<int> array(n);
       for(int i=0;i<n;i++)
       cin>>array[i];
      // A map to store num => freq 
      std::map <int, int> freq;
 
       // A map to store freq(can be duplicate) => num 
       std::multimap <int, int> freqCounts;
      sort(array.begin(),array.end());
     // Store num => frequency
      for (int i = 0 ; i < 8; i++)
      {
        freq[array[i]] += 1;
      }
       string result=freq[array[0]]%2!=0? "Lucky":"Unlucky";
       cout<<result<<endl;
     }
    return 0;
}
<end>ai-frequency number array minimum
<start>ai-fast input
ios_base::sync_with_stdio(false);
    cin.tie(NULL);

<end>ai-fast input
<start>ai-frequency fast
ios_base::sync_with_stdio(false);
    cin.tie(NULL);

<end>ai-frequency fast
<start>ai-fibonatchi is nth
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/math/special_functions/pow.hpp>

#include <bits/stdc++.h>
using namespace std;
 using namespace boost::multiprecision;
     namespace mp = boost::multiprecision;
  
map<int, int> isfibo;
    
int main() {
    int T;
    scanf("%d", &T);
    
    long long a = 0;
    long long b = 1;
    long long c;
    while (true) {
        c = a + b;
        if (c > 10000000000LL) break;
        isfibo[c] = 1;
        a = b;
        b = c;
    }
    
    long long n;
    while (T--) {
        scanf("%lld", &n);
        assert(n <= 10000000000LL);
        if (isfibo[n]) printf("IsFibo\n");
        else printf("IsNotFibo\n");
    }
    return 0;
}

<end>ai-fibonatchi is nth
<start>ai-time to word
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/math/special_functions/pow.hpp>

#include <bits/stdc++.h>
using namespace std;
 using namespace boost::multiprecision;
     namespace mp = boost::multiprecision;
  
map<int, int> isfibo;
 string getword(string hs,string ms)
 {
	 int h=stoi(hs);
	 int m=stoi(ms);
	 string result="";
	 string numbers[20]={ "one","two","three","four","five","six","seven","eight","nine"
,"ten"
,"eleven"	 
,"twelve"	 
,"thirteen"	 
,"fourteen"	 
,"fifteen"	 
,"sixteen"	 
,"seventeen"	 
,"eighteen"	 
,"nineteen"};
string tens[12]={"twenty","thirty","forty","fifty"};
int m1=m;
if(m>30)
	m1=60-m;
if((m1!=0)&&(m1!=30))
{ 
if(m1<20)
	result+=numbers[m1-1];
else
	{
	 
	  result+=tens[m1/10-2]+" "+ numbers[m1%10-1];
	  
   
    }
}
    
if(m==0)
	result=numbers[h-1]+" o' clock";
else if(m==15)
		result="quarter past "+numbers[h-1];

else if(m<30)	
	result+="minute past "+numbers[h-1];
else if(m==30)
	result="half past "+numbers[h-1];
else if(m==45)
 result="quarter to "+numbers[h-1];
else
	result+="minute to "+numbers[h-1];
	 return result;

 }
int main() {
	string a,b;
    for(int i=0;i<8;i++)
	{
		getline(cin,a);
		getline(cin,b);
	cout<<getword(a,b)<<endl;
	}
	system("pause");
    return 0;
}



<end>ai-time to word
<start>ai-find pair in array
 

#include <bits/stdc++.h>
using namespace std;
 
int main() {
	 int n,count=0;
	 cin>>n;
	 vector<int> a(n);
	 for(int i=0;i<n;i++)
		 cin>>a[i];
	 sort(a.begin(),a.end());
	 for(int i=0;i<a.size()-1;i++)
      if(a[i]==a[i+1])
	  {
		  count++;
	 i++;
	  }
	  cout<<count;
	system("pause");
    return 0;
}





<end>ai-find pair in array
<start>ai-round number one line
 

#include <bits/stdc++.h>
using namespace std;

int main() {
	 int n,count=0;
	 cin>>n;
	int x=0;
	 for(int i=0;i<n;i++)
		{ cin>>x;
	      cout<<(int)( x<38|| x % 5 < 3 ? x : x + (5 - (x % 5)))<<endl;

	  } 
}





<end>ai-round number one line
<start>ai-round number one line
 

#include <bits/stdc++.h>
using namespace std;

int main() {
	 int n,count=0;
	 cin>>n;
	int x=0;
	 for(int i=0;i<n;i++)
		{ cin>>x;
	      cout<<(int)( x<38|| x % 5 < 3 ? x : x + (5 - (x % 5)))<<endl;

	  } 
}





<end>ai-round number one line
<start>ai-round number one line
 

#include <bits/stdc++.h>
using namespace std;

int main() {
	 int n,count=0;
	 cin>>n;
	int x=0;
	 for(int i=0;i<n;i++)
		{ cin>>x;
	      cout<<(int)( x<38|| x % 5 < 3 ? x : x + (5 - (x % 5)))<<endl;

	  } 
}





<end>ai-round number one line
<start>ai-distance related counted
 

#include <bits/stdc++.h>
using namespace std;

int main() {
	 int s,t,a,b,m,n;
	 int  x,y;
	 int xc=0,yc=0;
	 cin>>s>>t;
     cin>>a>>b;
	 cin>>m>>n;
	 for(int i=0;i<m;i++)
	 {
		 cin>>x;
		 a+x>=s&&a+x<=t?xc++:xc=xc;
	 }
	 for(int i=0;i<n;i++)
	 {
		 cin>>y;
		 b+y>=s&&b+y<=t?yc++:yc=yc;
	 }
	 cout<<xc<<endl<<yc;
	 return 0;
}





<end>ai-distance related counted
<start>ai-i am ela
welcome to your ai life
just type any questions





<end>ai-i am ela
<start>ai-welcome


<end>ai-welcome
<start>ai-welcome midhouse
welcome to mid house 
my story will be published within 
codes and relations
<end>ai-welcome midhouse
<start>ai-hi midhouse
hi are you ready for going?

<end>ai-hi midhouse
<start>ai-yes
ok good so type:)



<end>ai-yes
<start>ai-hi are you ready for going
yes like going on street
<end>ai-hi are you ready for going
<start>ai-xxxs



xssd

<end>ai-xxxs



<start>ai-count bits set
#include<bits/stdc++.h>
using namespace std;
int count_one (int n)
        {
        	int count=0;
            while( n )
            {
              n = n&(n-1);
               count++;
            }
            return count;
    }
    
 int main()
  {
  	int n;
  	cin>>n;
  	cout<<count_one(n);
  	return 0;
  	
  }
<end>ai-count bits set
<start>ai-check bits ith is set
#include<bits/stdc++.h>
using namespace std;
bool check (int N,int i)
    {
        if( N & (1 << i) )
            return true;
        else
            return false;
    }
    
 int main()
  {
  	int n;
  	cin>>n;
  	cout<<check(n,2);
  	return 0;
  	
  }


<end>ai-check bits ith is set
<start>ai-bit xor array
#include<bits/stdc++.h>
using namespace std;

 int main()
 {
 	int n;
 	cin>>n;
 	int result=-1;
 	while(n--)
 	{
 		int m;
 		cin>>m;
 		if(result==-1)
 		 result=m;
 		else
 		result=result|m;
    }
    cout<<result;
 }
<end>ai-bit xor array
<start>ai-bits count difference two number
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int T; cin >> T; assert(T>=1 && T<=10000;
    for (int g=0; g<T; g++){
    	long long a, b; cin >> a >> b;
    	assert (a>=0 && a<=1e16); 
    	assert (b>=0 && b<=1e16);
    	cout << __builtin_popcountll (a^b) << '\n';
    }
    return 0;
}

<end>ai-bits count difference two number
<start>ai-where are you?
i am in midhouse

<end>ai-where are you?
<start>ai-where are you?
ai-i am in midhouse
ai-in lab


<end>ai-where are you?
<start>ai-print all subset
#include<bits/stdc++.h>
using namespace std;
int max1=0;
int h=0;
 void subArray(int arr[], int n)
{
	int sum=0;
	int l=0;
     for (int i=0; i <n; i++)
    {
         for (int j=i; j<n; j++)
        {
            for (int k=i; k<=j; k++)
                {
					l++;
					sum+=arr[k];
					cout << arr[k] << " ";
				}
                 cout<<endl<<sum*l<<" ";
                 if(h==0)
                 max1=sum*l;
                 else
                 if(max1<sum*l)
                 max1=sum*l;
                 sum=0;l=0;
            cout << endl;
            h++;
        }
    }
}
 
// Driver program
int main()
{
    int arr[] = {-8,0,-2};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "All Non-empty Subarrays\n";
    subArray(arr, n);
    cout<<endl<<max1;
    return 0;
}

<end>ai-print all subset
<start>ai-count integer array
#include <bits/stdc++.h>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        int a[n];
        unordered_map<int,int> m;
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
            m[a[i]]=i+1;
        }
        int q;
        cin>>q;
        while(q--)
        {
            int x;
            cin>>x;
            if(m.find(x)!=m.end())
            cout<<m[x]<<endl;
            else
            cout<<"-1"<<endl;
        }
    }
    return 0;

}



<end>ai-count integer array
<start>ai-count integer array
#include <bits/stdc++.h>
using namespace std;

int main()
{
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        int a[n];
        unordered_map<int,int> m;
        for(int i=0;i<n;i++)
        {
            cin>>a[i];
            m[a[i]]=i+1;
        }
        int q;
        cin>>q;
        while(q--)
        {
            int x;
            cin>>x;
            if(m.find(x)!=m.end())
            cout<<m[x]<<endl;
            else
            cout<<"-1"<<endl;
        }
    }
    return 0;

}



<end>ai-count integer array
<start>ai-count integer array
 #include<bits/stdc++.h>
 using namespace std;
 int main()
{
    int t,n,i;
    long int a[200000],diff,max;
    scanf("%d",&t);
    while(t--)
    {
        diff=0;max=0;
        scanf("%d",&n);
        for(i=0;i<n;i++)
        scanf("%ld",&a[i]);
        
        for(i=1;i<n;i++)
        if(a[i]>=a[i-1])
        diff+=a[i]-a[i-1];
        else
        {
            if(diff>max)
            max=diff;
            
            diff=0;
        }
        if(diff>max)
        max=diff;
        diff=0;
        
        for(i=1;i<n;i++)
        if(a[i]<=a[i-1])
        diff+=a[i-1]-a[i];
        else
        {
            if(diff>max)
            max=diff;
            
            diff=0;
        }
        if(diff>max)
        max=diff;
        
        printf("%ld\n",max);
    }
    return 0;
}



<end>ai-count integer array
<start>ai-stack Monk and Prisoner of Azkaban

#include<bits/stdc++.h>
using namespace std;
int main()
{
   int t,n,m,q,x;
   string s="";
   bool isequal=false;
   cin>>t;
   int sum=0;
   int ar[t];
   int i=0;
   while(t--)
   {
       cin>>ar[i];
       i++;
   }
   cin>>q>>x;
   stack<int> a;
   i=0;
   while(q--)
   {
       cin>>s;
       if(s=="Harry")
       {
		   sum+=ar[i];   
           a.push(ar[i]);
           
           i++;
       }
       else
      {
		  sum-=a.top();
		   a.pop();
	   }
	   if(sum==x)
	   {
		   isequal=true;
	   break;
        }
   }
   if(isequal)
   cout<<a.size()<<endl;
   else
   cout<<-1<<endl;
    return 0;
}

<end>ai-stack Monk and Prisoner of Azkaban
<start>ai-binary search
int binarySearch(int low,int high,int key)
{
   while(low<=high)
   {
     int mid=(low+high)/2;
     if(a[mid]<key)
     {
         low=mid+1;
     }
     else if(a[mid]>key)
     {
         high=mid-1;
     }
     else
     {
         return mid;
     }
   }
   return -1;                //key not found
 }
 
  	







































<end>ai-binary search
<start>ai-binarysearch1

 
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	int pr=1;
    cin>>n;
    vector<int> a(n);
    for(int i=0;i<n;i++)
     	cin>>a[i];
    int ans = -1;
    int lo = 0;int  hi = n-1;
    int mid=0;
    int key=0;
    cin>>key;
    int sum=0;
   while(lo <= hi)
   {
     mid = (lo + hi)/2 ;
     
     if(a[mid]>=key)
     {
        hi = mid-1;
        sum+=a[mid];
      }
    else
    {
        lo = mid+1 ;
        ans=lo;
     }
   }
   cout<<ans-1;
    return 0;
}  	









































<end>ai-binarysearch1
<start>ai-binary search find key index
#include<bits/stdc++.h>
using namespace std;
int binarySearch(vector<int> a,int low,int high,int key)
{
   while(low<=high)
   {
     int mid=(low+high)/2;
     if(a[mid]<key)
     {
         low=mid+1;
     }
     else if(a[mid]>key)
     {
         high=mid-1;
     }
     else
     {
         return mid;
     }
   }
   return -1;                //key not found
 }
 
int main()
  {
  	int n;
  	cin>>n;
  	vector<int> a(n);
  	for(int i=0;i<n;i++)
  	cin>>a[i];
  	int q;
  	cin>>q;
  	while(q--)
  	{
  		int x;
  		cin>>x;
  		cout<<binarySearch(a,0,n-1,x)+1<<endl;
    }
    return 0;
}	









































<end>ai-binary search find key index
<start>ai-kth smallest number
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<cstring>
#include<climits>
#include<algorithm>
#include<vector>
#include<stdio.h>
#include<math.h>
using namespace std;
#define FOR(i,a,b) for(i= a ; i < b ; ++i)
#define rep(i,n) FOR(i,0,n)
#define pb push_back
#define sz(x) int(x.size())
#define mp make_pair
#define si(n) scanf("%d",&n)
#define pi(n) printf("%d ",n)
#define pin(n) printf("%d\n",n)
#define pln(n) printf("%lld\n",n)
#define pl(n) printf("%lld ",n)
#define sl(n) scanf("%lld",&n)
#define scan(v,n) vector<int> v;rep(i,n){ int j;si(j);v.pb(j);}
#define mod (int)(1e9 + 7)
#define ll long long int
#define F first
#define S second
ll modpow(ll a,ll n,ll temp){ll res=1,y=a;while(n>0){if(n&1)res=(res*y)%temp;y=(y*y)%temp;n/=2;}return res%temp;} 
vector<pair<ll,ll> > arr,brr;
vector<ll> bin;
void modify()
{
	ll i,sz,a,b,tp=0;
	brr.pb(arr[0]);
	sz=arr.size();
	FOR(i,1,sz)
	{
		a=arr[i].F;
		b=arr[i].S;
		if(a>brr[tp].S)
		{
			tp++;
			brr.pb(mp(a,b));
		}
		else
		{
			brr[tp].S=max(brr[tp].S,b);
		}
	}
}
ll binary(ll sz, ll val)
{
	ll low=0,high=sz,mid,calc;
	while(low<=high)
	{
		mid=(low+high)/2;
		if(bin[mid]<val && (mid==sz || bin[mid+1]>=val))
		{
			if(mid==sz)
				return -1;
			else
			{
				calc=val-bin[mid];
				return brr[mid].F+calc-1;
			}
		}
		else if(val>bin[mid])
			low=mid+1;
		else
			high=mid-1;
	}
	return -1;
}
int main()
{
	ll t,n,q,a,b,sz,i,calc,k;
	sl(t);
	while(t--)
	{
		arr.clear();
		brr.clear();
		bin.clear();
		sl(n);
		sl(q);
		rep(i,n)
		{
			sl(a);
			sl(b);
			arr.pb(mp(a,b));
		}
		sort(arr.begin(),arr.end());
		modify();
		sz=brr.size();
		bin.pb(0);
		rep(i,sz)
		{
			calc=brr[i].S-brr[i].F+1+bin[i];
			bin.pb(calc);
		}
		rep(i,q)
		{
			sl(k);
			calc=binary(sz,k);
			pln(calc);
		}
	}
	return 0;
}









































<end>ai-kth smallest number
<start>ai-number detect is desperete 
 #include <iostream>
#include <vector>
 
using namespace std;
vector<int> vc;
 
bool binarySearch(int vl);
 
int main()
{
	long  num,i,j;
	cin >> num;
	if (num == 1)
		cout << "YES" << endl;
	else
	{
		long x;
		long a = 1;
			do{
				x = (a*(a + 1)) / 2;
				vc.push_back(x);
				a++;
			} while(x<num);
 
			for (i = 0;i < vc.size();i++)
			{
				if (binarySearch(num-vc[i]))
				{
					break;
				}
			}
 
			if (i == vc.size())
				cout << "NO" << endl;
			else
				cout << "YES" << endl;
 
	}

	return EXIT_SUCCESS;
} 
bool binarySearch(int vl)
{
	int low = 0;
	int high = vc.size()-1;
	int mid;
	while (low <= high)
	{
		mid = (low + high) / 2;
		if (vc[mid] == vl)
			return true;
		else if (vc[mid] < vl)
			low = mid + 1;
		else
			high = mid - 1;
	}
	return false;
}
<end>ai-number detect is desperete 
<start>ai-binary search detect number is desperet
 #include <iostream>
#include <vector>
 
using namespace std;
vector<int> vc;
 
bool binarySearch(int vl);
 
int main()
{
	long  num,i,j;
	cin >> num;
	if (num == 1)
		cout << "YES" << endl;
	else
	{
		long x;
		long a = 1;
			do{
				x = (a*(a + 1)) / 2;
				vc.push_back(x);
				a++;
			} while(x<num);
 
			for (i = 0;i < vc.size();i++)
			{
				if (binarySearch(num-vc[i]))
				{
					break;
				}
			}
 
			if (i == vc.size())
				cout << "NO" << endl;
			else
				cout << "YES" << endl;
 
	}
	
	
 
 
 
	return EXIT_SUCCESS;
}
 
 
bool binarySearch(int vl)
{
	int low = 0;
	int high = vc.size()-1;
	int mid;
	while (low <= high)
	{
		mid = (low + high) / 2;
		if (vc[mid] == vl)
			return true;
		else if (vc[mid] < vl)
			low = mid + 1;
		else
			high = mid - 1;
	}
	return false;
}
<end>ai-binary search detect number is desperet
<start>ai-calling
elena 
katie
jenny
 
 
<end>ai-calling
<start>ai-calling elena
 hi you are in what u want do?
 input output?
 datastructutr
 change cloth elena
 graph
 
 
 
<end>ai-calling elena
<start>ai-graph circle eulerian
#include<iostream>
#include <list>
using namespace std;
 
// A class that represents an undirected graph
class Graph
{
    int V;    // No. of vertices
    list<int> *adj;    // A dynamic array of adjacency lists
public:
    // Constructor and destructor
    Graph(int V)   {this->V = V; adj = new list<int>[V]; }
    ~Graph() { delete [] adj; } // To avoid memory leak
 
     // function to add an edge to graph
    void addEdge(int v, int w);
 
    // Method to check if this graph is Eulerian or not
    int isEulerian();
 
    // Method to check if all non-zero degree vertices are connected
    bool isConnected();
 
    // Function to do DFS starting from v. Used in isConnected();
    void DFSUtil(int v, bool visited[]);
};
 
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
    adj[w].push_back(v);  // Note: the graph is undirected
}
 
void Graph::DFSUtil(int v, bool visited[])
{
    // Mark the current node as visited and print it
    visited[v] = true;
 
    // Recur for all the vertices adjacent to this vertex
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}
 
// Method to check if all non-zero degree vertices are connected.
// It mainly does DFS traversal starting from
bool Graph::isConnected()
{
    // Mark all the vertices as not visited
    bool visited[V];
    int i;
    for (i = 0; i < V; i++)
        visited[i] = false;
 
    // Find a vertex with non-zero degree
    for (i = 0; i < V; i++)
        if (adj[i].size() != 0)
            break;
 
    // If there are no edges in the graph, return true
    if (i == V)
        return true;
 
    // Start DFS traversal from a vertex with non-zero degree
    DFSUtil(i, visited);
 
    // Check if all non-zero degree vertices are visited
    for (i = 0; i < V; i++)
       if (visited[i] == false && adj[i].size() > 0)
            return false;
 
    return true;
}
 
/* The function returns one of the following values
   0 --> If grpah is not Eulerian
   1 --> If graph has an Euler path (Semi-Eulerian)
   2 --> If graph has an Euler Circuit (Eulerian)  */
int Graph::isEulerian()
{
    // Check if all non-zero degree vertices are connected
    if (isConnected() == false)
        return 0;
 
    // Count vertices with odd degree
    int odd = 0;
    for (int i = 0; i < V; i++)
        if (adj[i].size() & 1)
            odd++;
 
    // If count is more than 2, then graph is not Eulerian
    if (odd > 2)
        return 0;
 
    // If odd count is 2, then semi-eulerian.
    // If odd count is 0, then eulerian
    // Note that odd count can never be 1 for undirected graph
    return (odd)? 1 : 2;
}
 
// Function to run test cases
void test(Graph &g)
{
    int res = g.isEulerian();
    if (res == 0)
        cout << "graph is not Eulerian\n";
    else if (res == 1)
        cout << "graph has a Euler path\n";
    else
        cout << "graph has a Euler cycle\n";
}
 
// Driver program to test above function
int main()
{
    // Let us create and test graphs shown in above figures
    Graph g1(5);
    g1.addEdge(1, 0);
    g1.addEdge(0, 2);
    g1.addEdge(2, 1);
    g1.addEdge(0, 3);
    g1.addEdge(3, 4);
    test(g1);
 
    Graph g2(5);
    g2.addEdge(1, 0);
    g2.addEdge(0, 2);
    g2.addEdge(2, 1);
    g2.addEdge(0, 3);
    g2.addEdge(3, 4);
    g2.addEdge(4, 0);
    test(g2);
 
    Graph g3(5);
    g3.addEdge(1, 0);
    g3.addEdge(0, 2);
    g3.addEdge(2, 1);
    g3.addEdge(0, 3);
    g3.addEdge(3, 4);
    g3.addEdge(1, 3);
    test(g3);
 
    // Let us create a graph with 3 vertices
    // connected in the form of cycle
    Graph g4(3);
    g4.addEdge(0, 1);
    g4.addEdge(1, 2);
    g4.addEdge(2, 0);
    test(g4);
 
    // Let us create a graph with all veritces
    // with zero degree
    Graph g5(3);
    test(g5);
 
    return 0;
}
<end>ai-graph circle eulerian
<start>ai-graph path werighted dijkstra
// A C / C++ program for Dijkstra's single source shortest
// path algorithm. The program is for adjacency matrix
// representation of the graph.
#include <stdio.h>
#include <limits.h>
 
// Number of vertices in the graph
#define V 9
 
// A utility function to find the vertex with minimum distance
// value, from the set of vertices not yet included in shortest
// path tree
int minDistance(int dist[], bool sptSet[])
{
    // Initialize min value
    int min = INT_MAX, min_index;
 
    for (int v = 0; v < V; v++)
        if (sptSet[v] == false && dist[v] <= min)
            min = dist[v], min_index = v;
 
    return min_index;
}
 
// Function to print shortest path from source to j
// using parent array
void printPath(int parent[], int j)
{
    // Base Case : If j is source
    if (parent[j]==-1)
        return;
 
    printPath(parent, parent[j]);
 
    printf("%d ", j);
}
 
// A utility function to print the constructed distance
// array
int printSolution(int dist[], int n, int parent[])
{
    int src = 0;
    printf("Vertex\t  Distance\tPath");
    for (int i = 1; i < V; i++)
    {
        printf("\n%d -> %d \t\t %d\t\t%d ", src, i, dist[i], src);
        printPath(parent, i);
    }
}
 
// Funtion that implements Dijkstra's single source shortest path
// algorithm for a graph represented using adjacency matrix
// representation
void dijkstra(int graph[V][V], int src)
{
    int dist[V];  // The output array. dist[i] will hold
                  // the shortest distance from src to i
 
    // sptSet[i] will true if vertex i is included / in shortest
    // path tree or shortest distance from src to i is finalized
    bool sptSet[V];
 
    // Parent array to store shortest path tree
    int parent[V];
 
    // Initialize all distances as INFINITE and stpSet[] as false
    for (int i = 0; i < V; i++)
    {
        parent[0] = -1;
        dist[i] = INT_MAX;
        sptSet[i] = false;
    }
 
    // Distance of source vertex from itself is always 0
    dist[src] = 0;
 
    // Find shortest path for all vertices
    for (int count = 0; count < V-1; count++)
    {
        // Pick the minimum distance vertex from the set of
        // vertices not yet processed. u is always equal to src
        // in first iteration.
        int u = minDistance(dist, sptSet);
 
        // Mark the picked vertex as processed
        sptSet[u] = true;
 
        // Update dist value of the adjacent vertices of the
        // picked vertex.
        for (int v = 0; v < V; v++)
 
            // Update dist[v] only if is not in sptSet, there is
            // an edge from u to v, and total weight of path from
            // src to v through u is smaller than current value of
            // dist[v]
            if (!sptSet[v] && graph[u][v] &&
                dist[u] + graph[u][v] < dist[v])
            {
                parent[v]  = u;
                dist[v] = dist[u] + graph[u][v];
            }  
    }
 
    // print the constructed distance array
    printSolution(dist, V, parent);
}
 
// driver program to test above function
int main()
{
    /* Let us create the example graph discussed above */
    int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},
                       {4, 0, 8, 0, 0, 0, 0, 11, 0},
                       {0, 8, 0, 7, 0, 4, 0, 0, 2},
                       {0, 0, 7, 0, 9, 14, 0, 0, 0},
                       {0, 0, 0, 9, 0, 10, 0, 0, 0},
                       {0, 0, 4, 0, 10, 0, 2, 0, 0},
                       {0, 0, 0, 14, 0, 2, 0, 1, 6},
                       {8, 11, 0, 0, 0, 0, 1, 0, 7},
                       {0, 0, 2, 0, 0, 0, 6, 7, 0}
                      };
 
    dijkstra(graph, 0);
 
    return 0;
}
<end>ai-graph path werighted dijkstra
<start>ai-gready algorithm where use?
https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/tutorial/
Where to use Greedy algorithms?

A problem must comprise these two components for a greedy algorithm to work:

It has optimal substructures. The optimal solution for the problem contains optimal solutions to the sub-problems.

It has a greedy property (hard to prove its correctness!). If you make a choice that seems the best at the moment and solve the remaining sub-problems later, you still reach an optimal solution. You will never have to reconsider your earlier choices.

For example:

Activity Selection problem
Fractional Knapsack problem
Scheduling problem
<end>ai-gready algorithm where use?
<start>ai-Activity selection problem
Activity Selection problem

Activity selection problem
From Wikipedia, the free encyclopedia
The activity selection problem is a combinatorial optimization problem concerning the selection of non-conflicting activities to perform within a given time frame, given a set of activities each marked by a start time (si) and finish time (fi). The problem is to select the maximum number of activities that can be performed by a single person or machine, assuming that a person can only work on a single activity at a time.

A classic application of this problem is in scheduling a room for multiple competing events, each having its own time requirements (start and end time), and many more arise within the framework of operations research.

Contents  [hide] 
1	Formal definition
2	Optimal solution
2.1	Algorithm
2.1.1	Explanation
2.2	Proof of optimality
2.3	Weighted activity selection problem
3	References
4	External links
Formal definition[edit]
Assume there exist n activities with each of them being represented by a start time si and finish time fi. Two activities i and j are said to be non-conflicting if si ≥ fj or sj ≥ fi. The activity selection problem consists in finding the maximal solution set (S) of non-conflicting activities, or more precisely there must exist no solution set S' such that |S'| > |S| in the case that multiple maximal solutions have equal sizes.

Optimal solution[edit]
The activity selection problem is notable in that using a greedy algorithm to find a solution will always result in an optimal solution. A pseudocode sketch of the iterative version of the algorithm and a proof of the optimality of its result are included below.

Algorithm[edit]
 1 Greedy-Iterative-Activity-Selector(A, s, f): 
 2 
 3     Sort A by finish times stored in f'
 4     
 5     S = {A[1]} 
 6     k = 1
 7     
 8     n = A.length
 9     
10     for i = 2 to n:
11        if s[i] ≥ f[k]: 
12            S = S U {A[i]}
13            k = i
14     
15     return S
Explanation[edit]
Line 1: This algorithm is called Greedy-Iterative-Activity-Selector, because it is first of all a greedy algorithm, and then it is iterative. There's also a recursive version of this greedy algorithm.

{\displaystyle A} A is an array containing the activities.
{\displaystyle s} s is an array containing the start times of the activities in {\displaystyle A} A.
{\displaystyle f} f is an array containing the finish times of the activities in {\displaystyle A} A.
Note that these arrays are indexed starting from 1 up to the length of the corresponding array.

Line 3: Sorts in increasing order of finish times the array of activities {\displaystyle A} A by using the finish times stored in the array {\displaystyle f} f. This operation can be done in {\displaystyle O(n\cdot \log _{2}n)} O(n \cdot \log_2 n) time, using for example merge sort, heap sort, or quick sort algorithms.

Line 5: Creates a set {\displaystyle S} S to store the selected activities, and initialises it with the first activity {\displaystyle A[1]} A[1]. Note that, since the {\displaystyle A} A has already been sorted according to the finish times in {\displaystyle f} f, {\displaystyle A[1]} A[1] is the activity with the smallest finish time.

Line 6: Creates a variable {\displaystyle k} k that keeps track of the index of the last selected activity.

Line 10: Starts iterating from the second element of that array {\displaystyle A} A up to its last element.

Line 11: If the start time {\displaystyle s[i]} s[i] of the {\displaystyle ith} ith activity ( {\displaystyle A[i]} A[i]) is greater or equal to the finish time {\displaystyle f[k]} f[k] of the last selected activity ( {\displaystyle A[k]} A[k]), then {\displaystyle A[i]} A[i] is compatible to the selected activities in the set {\displaystyle S} S, and thus it can be added to {\displaystyle S} S; this is what is done in line 12.

Line 13: The index of the last selected activity is updated to the just added activity {\displaystyle A[i]} A[i].

Proof of optimality[edit]
Let {\displaystyle S=\{1,2,\ldots ,n\}} S=\{1,2,\ldots ,n\} be the set of activities ordered by finish time. Thus activity 1 has the earliest finish time.

Suppose A is a subset of S and is an optimal solution, and let activities in A be ordered by finish time. Suppose that the first activity in A is k ≠ 1, that is, this optimal solution does not start with the "greedy choice." We want to show that there is another solution B that begins with the greedy choice, activity 1.

Let {\displaystyle B=(A\setminus \{k\})\cup \{1\}} B=(A\setminus \{k\})\cup \{1\}. Because {\displaystyle f_{1}\leq f_{k}} f_{1}\leq f_{k}, the activities in B are disjoint and since B has same number of activities as A, i.e., |A| = |B|, B is also optimal.

Once the greedy choice is made, the problem reduces to finding an optimal solution for the subproblem. If A is an optimal solution to the original problem S, then {\displaystyle A^{\prime }=A\setminus \{1\}} A^{\prime }=A\setminus \{1\} is an optimal solution to the activity-selection problem {\displaystyle S'=\{i\in S:s_{i}\geq f_{1}\}} S' = \{i \in S: s_i \geq f_1\}.

Why? If we could find a solution B′ to S′ with more activities then A′, adding 1 to B′ would yield a solution B to S with more activities than A, contradicting the optimality.

Weighted activity selection problem[edit]
The generalized version of the activity selection problem involves selecting an optimal set of non-overlapping activities such that the total weight is maximized. Unlike the unweighted version, there is no greedy solution to the weighted activity selection problem. However, a dynamic programming solution can readily be formed using the following approach:[1]

Consider an optimal solution containing activity k. We now have non-overlapping activities on the left and right of k. We can recursively find solutions for these two sets because of optimal sub-structure. As we don't know k, we can try each of the activities. This approach leads to an {\displaystyle O(n^{3})} O(n^{3}) solution. This can be optimized further considering that for each set of activities in {\displaystyle (i,j)} (i,j), we can find the optimal solution if we had known the solution for {\displaystyle (i,t)} (i,t), where t is the last non-overlapping interval with j in {\displaystyle (i,j)} (i,j). This yields an {\displaystyle O(n^{2})} O(n^{2}) solution. This can be further optimized considering the fact that we do not need to consider all ranges {\displaystyle (i,j)} (i,j) but instead just {\displaystyle (1,j)} (1,j). The following algorithm thus yields an {\displaystyle O(n\log n)} O(n\log n) solution:

 1 Weighted-Activity-Selection(S):  // S = list of activities
 2 
 3     sort S by finish time
 4     opt[0] = 0
 5    
 6     for i = 1 to n:
 7         t = binary search to find activity with finish time <= start time for i
 8         opt[i] = MAX(opt[i-1], opt[t] + w(i))
 9         
10     return opt[n]

<end>ai-Activity selection problem
<start>ai-kickstarter string edit copy past java
import java.io.PrintStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;


public class Main {

    public String solve(Scanner scanner) {
        String s=scanner.next();
        int l=s.length();
        HashMap<String, Integer>[] maps=new HashMap[l+1];
        HashSet<String>[] sets=new HashSet[l+1];
        int[] ans=new int[l+1];
        for (int i=0;i<=l;i++) {
            maps[i]=new HashMap<>();
            sets[i]=new HashSet<>();
        }
        maps[0].put("", 0);
        sets[0].add("");

        for (int i=1;i<=l;i++) {

            // calculate all strings
            sets[i].addAll(sets[i-1]);
            for (int j=0;j<i;j++)
                sets[i].add(s.substring(j, i));

            ans[i]=99999999;

            // add letter to the end
            for (Map.Entry<String, Integer> entry: maps[i-1].entrySet()) {
                maps[i].put(entry.getKey(), entry.getValue()+1);
                ans[i]=Math.min(ans[i], entry.getValue()+1);
            }

            // copy
            for (int j=i-1;j>=0;j--) {
                String copy=s.substring(j, i);
                // cannot copy
                if (!sets[j].contains(copy)) continue;
                // paste directly
                maps[i].put(copy, Math.min(maps[i].getOrDefault(copy, 99999999),
                        maps[j].getOrDefault(copy, 99999999)+1));
                // copy & paste
                maps[i].put(copy, Math.min(maps[i].get(copy), ans[j]+2));

                ans[i]=Math.min(ans[i], maps[i].get(copy));
            }
        }
        return String.valueOf(ans[l]);
    }

    public static void main(String[] args) throws Exception {
       // System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}

<end>ai-kickstarter string edit copy past java
<start>ai-kickstarter array can form rectangle
import java.io.PrintStream;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * KickStart 2017 Round E
 * Problem B. Trapezoid Counting
 */
public class Main {

    public String solve(Scanner scanner) {
        return solveLarge(scanner);
    }

    public String solveLarge(Scanner scanner) {
        int n=scanner.nextInt();
        long[] nums=new long[n];
        for (int i=0;i<n;i++) nums[i]=scanner.nextLong();
        Arrays.sort(nums);

        TreeMap<Long, Integer> map=new TreeMap<>();
        TreeMap<Long, Integer> index=new TreeMap<>();
        for (int i=0;i<n;i++) {
            long x=nums[i];
            map.put(x, map.getOrDefault(x, 0)+1);
            index.put(x, i+1);
        }

        long ans=0;
        // select equals number
        for (Map.Entry<Long, Integer> entry: map.entrySet()) {
            long key=entry.getKey(), value=entry.getValue();
            if (value<=1) continue;

            // two equals, select another
            for (Map.Entry<Long, Integer> another: map.entrySet()) {
                long a=another.getKey();
                if (a==key) continue;
                // b shoule in [a+1, a+2*key-1]
                long cnt=query(index, a+2*key-1)-query(index, a);
                // if key in this range, delete it
                if (a+1<=key && key<=a*2*key-1)
                    cnt-=value;
                ans+=(value*(value-1)/2)*another.getValue()*cnt;
            }

            // three equals
            if (value<=2) continue;
            long cnt=query(index, 3*key-1)-value;
            ans+=(value*(value-1)*(value-2))/6*cnt;
        }
        return String.valueOf(ans);
    }

    // how many in [0, bound]
    private int query(TreeMap<Long, Integer> index, long bound) {
        Map.Entry<Long, Integer> upper=index.floorEntry(bound);
        return upper==null?0:upper.getValue();
    }

    public String solveSmall(Scanner scanner) {
        int n=scanner.nextInt();
        long[] nums=new long[n];
        for (int i=0;i<n;i++) nums[i]=scanner.nextLong();
        long cnt=0;
        for (int i=0;i<n;i++)
            for (int j=i+1;j<n;j++)
                for (int k=j+1;k<n;k++)
                    for (int l=k+1;l<n;l++)
                        if (able(nums[i],nums[j],nums[k],nums[l]))
                            cnt++;
        return String.valueOf(cnt);
    }

    private boolean able(long a, long b, long c, long d) {
        long[] nums=new long[] {a,b,c,d};
        Arrays.sort(nums);
        if (nums[0]==nums[1] && nums[2]==nums[3]) return false;
        return (nums[0]==nums[1] || nums[1]==nums[2] || nums[2]==nums[3])
                && nums[0]+nums[1]+nums[2]>nums[3];
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstarter array can form rectangle
<start>ai-kickstart matrix graph radis smallest
import java.io.PrintStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Scanner;

/**
 * KickStart 2017 Round E
 * Problem C. Blackhole
 */
public class Main {

    public String solve(Scanner scanner) {
        return solveSmall(scanner);
    }

    public String solveSmall(Scanner scanner) {
        double[][] points=new double[3][3];
        for (int i=0;i<3;i++) for (int j=0;j<3;j++) points[i][j]=scanner.nextDouble();
        double max=-1e10, min=1e10;
        for (int i=0;i<3;i++) {
            max=Math.max(max, points[i][0]);
            min=Math.min(min, points[i][0]);
        }
        return String.format("%.9f", (max-min)/6);
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart matrix graph radis smallest
<start>ai-dp travel every city i before city j
Problem A. Go Sightseeing

Simple DP Problem.
dp[i][j] means, the earliest time we arrive at city i, if we visit j cities.
dp[i][j] =

visit i-1th city: dp[i-1][j-1] + Ts + wait_time + bus_time
do not visit i-1th city: dp[i-1][j] + wait_time + bus_time
Then, find the max m satisfied dp[n][m]<=Tf.
import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round D
 * Problem A. Go Sightseeing
 */
public class Main {

    private String solve(Scanner scanner) {
        int n=scanner.nextInt();
        long ts=scanner.nextLong(), tf=scanner.nextLong();
        long[][] cities=new long[n][3];
        for (int i=1;i<n;i++) {
            cities[i]=new long[] {scanner.nextLong(), scanner.nextLong(), scanner.nextLong()};
        }

        long[][] dp=new long[n+1][n+1];
        dp[1][0]=0;
        for (int i=2;i<=n;i++) {
            for (int j=0;j<i;j++) {

                long min=tf+1;
                if (j>0) {
                    min=Math.min(ceil(dp[i-1][j-1]+ts, cities[i-1][0], cities[i-1][1])+cities[i-1][2], min);
                }
                if (j<i-1) {
                    min=Math.min(ceil(dp[i-1][j], cities[i-1][0], cities[i-1][1])+cities[i-1][2], min);
                }
                dp[i][j]=min;
            }
        }
        for (int i=n-1;i>=0;i--) {
            if (dp[n][i]<=tf) {
                return String.valueOf(i);
            }
        }
        return "IMPOSSIBLE";
    }

    private long ceil(long x, long a, long b) {
        // a+b*n
        if (x<=a) return a;
        long y=x-a;
        if (y%b==0) return x;
        return a+y/b*b+b;
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-dp travel every city i before city j
<start>ai-kickstarter dp travel every city i before city j
Problem A. Go Sightseeing

Simple DP Problem.
dp[i][j] means, the earliest time we arrive at city i, if we visit j cities.
dp[i][j] =

visit i-1th city: dp[i-1][j-1] + Ts + wait_time + bus_time
do not visit i-1th city: dp[i-1][j] + wait_time + bus_time
Then, find the max m satisfied dp[n][m]<=Tf.
import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round D
 * Problem A. Go Sightseeing
 */
public class Main {

    private String solve(Scanner scanner) {
        int n=scanner.nextInt();
        long ts=scanner.nextLong(), tf=scanner.nextLong();
        long[][] cities=new long[n][3];
        for (int i=1;i<n;i++) {
            cities[i]=new long[] {scanner.nextLong(), scanner.nextLong(), scanner.nextLong()};
        }

        long[][] dp=new long[n+1][n+1];
        dp[1][0]=0;
        for (int i=2;i<=n;i++) {
            for (int j=0;j<i;j++) {

                long min=tf+1;
                if (j>0) {
                    min=Math.min(ceil(dp[i-1][j-1]+ts, cities[i-1][0], cities[i-1][1])+cities[i-1][2], min);
                }
                if (j<i-1) {
                    min=Math.min(ceil(dp[i-1][j], cities[i-1][0], cities[i-1][1])+cities[i-1][2], min);
                }
                dp[i][j]=min;
            }
        }
        for (int i=n-1;i>=0;i--) {
            if (dp[n][i]<=tf) {
                return String.valueOf(i);
            }
        }
        return "IMPOSSIBLE";
    }

    private long ceil(long x, long a, long b) {
        // a+b*n
        if (x<=a) return a;
        long y=x-a;
        if (y%b==0) return x;
        return a+y/b*b+b;
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstarter dp travel every city i before city j
<start>ai-kickstart sub matrix condition sum PriorityQueue
Sherlock and The Matrix Game
ust O(n^4) to calculate all the sums of sub-matrices, then choose the k-th largest.
We don't need to remember all tht sums (~8*10^8), however using PriorityQueue 
to remember the largest k items is enough.
import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round D
 * Problem B. Sherlock and The Matrix Game
 * Only small solved.
 */
public class Main {

    private String solve(Scanner scanner) {
        return solveSmall(scanner);
    }

    private String solveSmall(Scanner scanner) {
        int n=scanner.nextInt(), k=scanner.nextInt();
        long[][] init=init(n, scanner);
        long[] a=init[0], b=init[1];

        long[][] matrix=new long[n][n];
        for (int i=0;i<n;i++)
            for (int j=0;j<n;j++)
                matrix[i][j]=a[i]*b[j];

        // calculate sums of all submatrices
        long[][] colSum=new long[n][n];
        for (int i=0;i<n;i++) {
            for (int j=0;j<n;j++) {
                colSum[i][j]=(i==0?0:colSum[i-1][j])+matrix[i][j];
            }
        }

        PriorityQueue<Long> queue=new PriorityQueue<>();
        for (int top=0;top<n;top++) {
            for (int bottom=top;bottom<n;bottom++) {
                for (int left=0;left<n;left++) {
                    long last=0;
                    for (int right=left;right<n;right++) {
                        last+=colSum[bottom][right]-(top==0?0:colSum[top-1][right]);
                        if (queue.size()<k) {
                            queue.offer(last);
                        }
                        else if (queue.peek()<last) {
                            queue.poll();
                            queue.offer(last);
                        }
                    }
                }
            }
        }
        return String.valueOf(queue.peek());
    }

    private long[][] init(int n, Scanner scanner) {
        long a0=scanner.nextLong(), b0=scanner.nextLong(), c=scanner.nextLong(),
                d=scanner.nextLong(), e1=scanner.nextLong(), e2=scanner.nextLong(),f=scanner.nextLong();

        long[] a=new long[n], b=new long[n];
        long x=a0, y=b0, r=0, s=0;
        for (int i=0;i<n;i++) {
            a[i]=(r%2==0?1:-1)*x;
            b[i]=(s%2==0?1:-1)*y;
            long _x=(c*x+d*y+e1)%f, _y=(d*x+c*y+e2)%f,
                    _r=(c*r+d*s+e1)%2, _s=(d*r+c*s+e2)%2;
            x=_x; y=_y; r=_r; s=_s;
        }
        return new long[][] {a,b};
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart sub matrix condition sum PriorityQueue
<start>ai-kickstart sub matrix condition sum PriorityQueue
 math problem.
First, binary search for R. For each R, just check if there is a valid a.
To do this, for each point (x0, y0), we just need to find a1, a2, that is, if 0<=a<=a1 or a2<=a<=a_max, then the parabola has no intersections with circle (x0, y0, R). Here a_max is determined by H.
We can find the standard a_standard, where (x0, y0) is on the parabola.
Then, binary search [0, a_stardard] to find a1, binary search [a_standart, a_max] to find a2.
To binary search [0, a_standard], just check if parabola with a=mid has intersections with the circle. It's a quartic function, and to find the min value of it, just calculate the derivative, binary search to find the solution, and check the minimal value.
Yes, in this problem, we need three binary-searches.

Finally, find if there exists a satisfied 0<=a<=a1 || a2<=a<=a_max for every point.
Not easy, but interesting.

import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round D
 * Problem C. Trash Throwing
 */
public class Main {

    private String solve(Scanner scanner) {
        int n=scanner.nextInt();
        double p=scanner.nextDouble(), h=scanner.nextDouble();
        double[][] points=new double[n][2];
        for (int i=0;i<n;i++) {
            points[i]=new double[] {scanner.nextDouble(), -scanner.nextDouble()};
            if (points[i][0]>=p/2) points[i][0]=p-points[i][0];
        }

        // binary-search r
        double start=0, end=h;
        while (end-start>1e-10) {
            double mid=(start+end)/2;
            if (ableR(n, p, h, points, mid)) start=mid;
            else end=mid;
        }
        return String.format("%.9f", start);
    }

    private boolean ableR(int n, double p, double h, double[][] points, double r) {
        double[][] a=new double[n][2];
        // a>=a[i][0] || 0<=a<=a[i][1]
        double max=(r-h)/(-p*p/4);
        for (int i=0;i<n;i++) {
            double x=points[i][0], y=points[i][1];
            double _a=y/x/(x-p);
            if (x<=r) {
                a[i][0]=max+1;
            }
            else {
                double start=_a, end=max+1;
                while (end-start>1e-10) {
                    double mid=(start+end)/2;
                    double cx=p/2, cy=mid*cx*(cx-p);
                    if (isOutCircle(mid, x-cx, y-cy, r, p)) end=mid;
                    else start=mid;
                }
                a[i][0]=start;
            }
            if (y+r>=0) {
                a[i][1]=-1;
            }
            else {
                double start=0, end=_a;
                while (end-start>1e-10) {
                    double mid=(start+end)/2;
                    double cx=p/2, cy=mid*cx*(cx-p);
                    if (isOutCircle(mid, x-cx, y-cy, r, p)) start=mid;
                    else end=mid;
                }
                a[i][1]=start;
            }
        }
        ArrayList<double[]> list=new ArrayList<>();
        list.add(new double[] {0., (r-h)/(-p*p/4)});
        for (double[] aa: a) {
            ArrayList<double[]> next=new ArrayList<>();
            for (double[] d: list) {
                double[] nd=d.clone();
                nd[0]=Math.max(nd[0], aa[0]);
                if (nd[0]<=nd[1]+1e-10) next.add(nd);
                double[] nd2=d.clone();
                nd2[1]=Math.min(nd2[1], aa[1]);
                if (nd2[0]<=nd2[1]+1e-10) next.add(nd2);
            }
            list=next;
        }
        return !list.isEmpty();
    }

    private boolean isOutCircle(double a, double x, double y, double r, double p) {
        // (x-x0)^2+(ax^2-y0)^2>=r^2
        double a4=a*a, a2=-2*a*y+1, a1=-2*x, a0=x*x+y*y-r*r;
        // a4x^4+a2x^2+a1x+a0>=0
        double b3=4*a4, b1=2*a2, b0=a1;
        // b3x^3+b1x+b0=0
        // find solution
        // -p/2 -> 0
        double start=-p/2, end=0;
        while (end-start>1e-10) {
            double mid=(start+end)/2;
            if (b3*mid*mid*mid+b1*mid+b0<=0) start=mid;
            else end=mid;
        }
        return a4*start*start*start*start+a2*start*start+a1*start+a0>=-1e-10;
    }


    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart sub matrix condition sum PriorityQueue
<start>ai-binary search math min value
 math problem.
First, binary search for R. For each R, just check if there is a valid a.
To do this, for each point (x0, y0), we just need to find a1, a2, that is, if 0<=a<=a1 or a2<=a<=a_max, then the parabola has no intersections with circle (x0, y0, R). Here a_max is determined by H.
We can find the standard a_standard, where (x0, y0) is on the parabola.
Then, binary search [0, a_stardard] to find a1, binary search [a_standart, a_max] to find a2.
To binary search [0, a_standard], just check if parabola with a=mid has intersections with the circle. It's a quartic function, and to find the min value of it, just calculate the derivative, binary search to find the solution, and check the minimal value.
Yes, in this problem, we need three binary-searches.

Finally, find if there exists a satisfied 0<=a<=a1 || a2<=a<=a_max for every point.
Not easy, but interesting.

import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round D
 * Problem C. Trash Throwing
 */
public class Main {

    private String solve(Scanner scanner) {
        int n=scanner.nextInt();
        double p=scanner.nextDouble(), h=scanner.nextDouble();
        double[][] points=new double[n][2];
        for (int i=0;i<n;i++) {
            points[i]=new double[] {scanner.nextDouble(), -scanner.nextDouble()};
            if (points[i][0]>=p/2) points[i][0]=p-points[i][0];
        }

        // binary-search r
        double start=0, end=h;
        while (end-start>1e-10) {
            double mid=(start+end)/2;
            if (ableR(n, p, h, points, mid)) start=mid;
            else end=mid;
        }
        return String.format("%.9f", start);
    }

    private boolean ableR(int n, double p, double h, double[][] points, double r) {
        double[][] a=new double[n][2];
        // a>=a[i][0] || 0<=a<=a[i][1]
        double max=(r-h)/(-p*p/4);
        for (int i=0;i<n;i++) {
            double x=points[i][0], y=points[i][1];
            double _a=y/x/(x-p);
            if (x<=r) {
                a[i][0]=max+1;
            }
            else {
                double start=_a, end=max+1;
                while (end-start>1e-10) {
                    double mid=(start+end)/2;
                    double cx=p/2, cy=mid*cx*(cx-p);
                    if (isOutCircle(mid, x-cx, y-cy, r, p)) end=mid;
                    else start=mid;
                }
                a[i][0]=start;
            }
            if (y+r>=0) {
                a[i][1]=-1;
            }
            else {
                double start=0, end=_a;
                while (end-start>1e-10) {
                    double mid=(start+end)/2;
                    double cx=p/2, cy=mid*cx*(cx-p);
                    if (isOutCircle(mid, x-cx, y-cy, r, p)) start=mid;
                    else end=mid;
                }
                a[i][1]=start;
            }
        }
        ArrayList<double[]> list=new ArrayList<>();
        list.add(new double[] {0., (r-h)/(-p*p/4)});
        for (double[] aa: a) {
            ArrayList<double[]> next=new ArrayList<>();
            for (double[] d: list) {
                double[] nd=d.clone();
                nd[0]=Math.max(nd[0], aa[0]);
                if (nd[0]<=nd[1]+1e-10) next.add(nd);
                double[] nd2=d.clone();
                nd2[1]=Math.min(nd2[1], aa[1]);
                if (nd2[0]<=nd2[1]+1e-10) next.add(nd2);
            }
            list=next;
        }
        return !list.isEmpty();
    }

    private boolean isOutCircle(double a, double x, double y, double r, double p) {
        // (x-x0)^2+(ax^2-y0)^2>=r^2
        double a4=a*a, a2=-2*a*y+1, a1=-2*x, a0=x*x+y*y-r*r;
        // a4x^4+a2x^2+a1x+a0>=0
        double b3=4*a4, b1=2*a2, b0=a1;
        // b3x^3+b1x+b0=0
        // find solution
        // -p/2 -> 0
        double start=-p/2, end=0;
        while (end-start>1e-10) {
            double mid=(start+end)/2;
            if (b3*mid*mid*mid+b1*mid+b0<=0) start=mid;
            else end=mid;
        }
        return a4*start*start*start*start+a2*start*start+a1*start+a0>=-1e-10;
    }


    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-binary search math min value
<start>ai-string integer  
import java.io.PrintStream;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round C
 * Problem A. Ambiguous Cipher
 */
public class Main {

    public String solve(Scanner scanner) {
        String s=scanner.next();
        if (s.length()%2!=0) return "AMBIGUOUS";
        char[] chars=new char[s.length()];
        for (int i=1;i<s.length();i+=2) {
            if (i==1) chars[i]=s.charAt(i-1);
            else {
                // chars[i-2]+chars[i]=s[i-1]
                // chars[i]=s[i]-chars[i-2]
                chars[i]=i2c((c2i(s.charAt(i-1))-c2i(chars[i-2])+26)%26);
            }
        }
        for (int i=s.length()-2;i>=0;i-=2) {
            if (i==s.length()-2) chars[i]=s.charAt(i+1);
            else {
                chars[i]=i2c((c2i(s.charAt(i+1))-c2i(chars[i+2])+26)%26);
            }
        }
        return new String(chars);
    }

    private char i2c(int i) {
        return (char)('A'+i);
    }
    private int c2i(char c) {
        return c-'A';
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-string integer  
<start>ai-kickstart string integer  
import java.io.PrintStream;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round C
 * Problem A. Ambiguous Cipher
 */
public class Main {

    public String solve(Scanner scanner) {
        String s=scanner.next();
        if (s.length()%2!=0) return "AMBIGUOUS";
        char[] chars=new char[s.length()];
        for (int i=1;i<s.length();i+=2) {
            if (i==1) chars[i]=s.charAt(i-1);
            else {
                // chars[i-2]+chars[i]=s[i-1]
                // chars[i]=s[i]-chars[i-2]
                chars[i]=i2c((c2i(s.charAt(i-1))-c2i(chars[i-2])+26)%26);
            }
        }
        for (int i=s.length()-2;i>=0;i-=2) {
            if (i==s.length()-2) chars[i]=s.charAt(i+1);
            else {
                chars[i]=i2c((c2i(s.charAt(i+1))-c2i(chars[i+2])+26)%26);
            }
        }
        return new String(chars);
    }

    private char i2c(int i) {
        return (char)('A'+i);
    }
    private int c2i(char c) {
        return c-'A';
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart string integer  
<start>ai-kickstart matrix play game
import java.io.PrintStream;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round C
 * Problem B. X Squared
 */
public class Main {

    public String solve(Scanner scanner) {
        int n=scanner.nextInt();
        char[][] map=new char[n][n];
        for (int i=0;i<n;i++) map[i]=scanner.next().toCharArray();
        return check1(n, map)&&check2(n, map)?"POSSIBLE":"IMPOSSIBLE";
    }

    private boolean check1(int n, char[][] map) {
        for (int i=0;i<n;i++) {
            int u=0,v=0;
            for (int j=0;j<n;j++) {
                if (map[i][j]=='X') u++;
                if (map[j][i]=='X') v++;
                if (u>2 || v>2) return false;
            }
        }
        return true;
    }

    private boolean check2(int n, char[][] map) {
        boolean[] visited=new boolean[n];
        ArrayList<Integer>[] lists=new ArrayList[n];

        for (int i=0;i<n;i++) {
            ArrayList<Integer> list=new ArrayList<>();
            for (int j=0;j<n;j++) {
                if (map[i][j]=='X') list.add(j);
            }
            if (list.size()>=3 || list.isEmpty()) return false;
            lists[i]=list;
        }

        for (int i=0;i<n;i++) {
            if (visited[i] || lists[i].size()==1) continue;
            visited[i]=true;
            boolean has=false;
            for (int j=0;j<n;j++) {
                if (!visited[j] && lists[j].equals(lists[i])) {
                    visited[j]=true;
                    has=true;
                    break;
                }
            }
            if (!has) return false;
        }
        return true;
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart matrix play game
<start>ai-kickstarter two array compare 
import java.io.PrintStream;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round C
 * Problem C. Magical Thinking
 */
public class Main {

    public String solve(Scanner scanner) {
        int n=scanner.nextInt(), q=scanner.nextInt();
        char[][] chars=new char[n+1][q];
        int[] score=new int[n];
        for (int i=0;i<=n;i++) chars[i]=scanner.next().toCharArray();
        for (int i=0;i<n;i++) score[i]=scanner.nextInt();
        return String.valueOf(n==1?solve1(q, chars[0], chars[1], score[0]):
                solve2(q, chars[0], chars[1], chars[2], score[0], score[1]));
    }

    private int solve1(int q, char[] c, char[] you, int s) {
        int ans=0;
        for (int i=0;i<q;i++) {
            if (c[i]==you[i] && s-->0)
                ans++;
            if (c[i]!=you[i] && i+s<q)
                ans++;
        }
        return ans;
    }

    private int solve2(int q, char[] c1, char[] c2, char[] you, int s1, int s2) {
        boolean[][][] able=new boolean[q+1][s1+1][s2+1];
        able[0][0][0]=true;
        for (int i=1;i<=q;i++) {
            for (int u=0;u<=s1;u++) {
                for (int v=0;v<=s2;v++) {
                    for (char c: "TF".toCharArray()) {
                        int nu=u, nv=v;
                        if (c1[i-1]==c) nu--;
                        if (c2[i-1]==c) nv--;
                        if (nu>=0 && nv>=0 && able[i-1][nu][nv])
                            able[i][u][v]=true;
                    }
                }
            }
        }
        int ans=0;
        for (int i=q;i>=1;i--) {
            char c=you[i-1];
            // can score
            int ns1=s1, ns2=s2;
            if (c1[i-1]==c) ns1--;
            if (c2[i-1]==c) ns2--;
            if (ns1>=0 && ns2>=0 && able[i-1][ns1][ns2]) {
                // can!
                ans++;
                s1=ns1;s2=ns2;
                continue;
            }
            // not able
            c=(char)('T'+'F'-you[i-1]);
            if (c1[i-1]==c) s1--;
            if (c2[i-1]==c) s2--;
        }
        return ans;
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
© 2017 GitHub, Inc.
<end>ai-kickstarter two array compare 
<start>ai-kickstart  math tree max min 
import java.io.PrintStream;
import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round C
 * Problem D. The 4M Corporation
 */
public class Main {

    public String solve(Scanner scanner) {
        long min=scanner.nextLong(), max=scanner.nextLong(),
                mean=scanner.nextLong(), median=scanner.nextLong();
        if (min>mean || min>median || max<mean || max<median) return "IMPOSSIBLE";
        if (min==max) return "1";
        if (mean==median && min+max==mean*2) return "2";
        if (2*mean-min-median<=0 || median+max-2*mean<=0) return "IMPOSSIBLE";
        long ans=Math.min(testOdd(min, max, mean, median), testEven(min, max, mean, median));
        return ans==Long.MAX_VALUE?"IMPOSSIBLE":String.valueOf(ans);
    }

    private long testOdd(long min, long max, long avg, long s) {
        long ans=Math.max(3, Math.max(ceil(2*max-min-s, 2*avg-min-s), ceil(s+max-2*min, s+max-2*avg)));
        return ans%2==0?ans+1:ans;
    }

    private long testEven(long min, long max, long avg, long s) {
        long ans=Math.max(4, Math.max(ceil(2*max-2*min, 2*avg-min-s), ceil(2*max-2*min, s+max-2*avg)));
        return ans%2==0?ans:ans+1;
    }

    private long ceil(long a, long b) {
        return a/b+(a%b==0?0:1);
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=Integer.parseInt(scanner.nextLine());
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart  math tree max min 
<start>ai-kickstart  math sort subset min-a[i] 
Just sort all numbers, and for each i<j, there are 2^(j-i) subsets with min-a[i] and max-a[j].

import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round B Problem A: Math Encoder
 * Check README.md for explanation.
 */
public class Main {

    private long pow(long x, int k, long mod) {
        if (k==0) return 1;
        long p=pow(x, k/2, mod)%mod;
        return p*p%mod*(k%2!=0?x:1)%mod;
    }

    private String solve(Scanner scanner) throws Throwable {
        int n=scanner.nextInt();
        long[] a=new long[n];
        for (int i=0;i<n;i++) a[i]=scanner.nextLong();
        Arrays.sort(a);
        long mod=1000000007L, ans=0;
        HashMap<Integer, Long> map=new HashMap<>();
        for (int i=0;i<=10000;i++) map.put(i, pow(2L, i, mod));
        for (int i=0;i<n;i++) {
            for (int j=i+1;j<n;j++) {
                ans+=(a[j]-a[i])*map.get(j-i-1);
                ans%=mod;
            }
        }
        return String.valueOf(ans);
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart  math sort subset min-a[i] 
<start>ai-kickstart math sum diagonal lines
For each point (a, b), make two diagonal lines y=x+b-a, y=-x+a+b.
Then, the final point must be an intersection of two lines.

For small input, just check all intersections to calculate the min-value. O(n^3).

For large input, we need to calculate in O(n^2).
For any diagonal line L, there are n intersections on the line.
Let's assume points Pi=(ai, bi), the intersection of L and anti-diagonal line of Pi is Qi=(ci, di).
Then, for X=(x, y):

dis(X, Pi)=max(|x-ai|, |y-bi|)
dis(X, Pi)=dis(X, Qi)+dis(Qi, Pi)
As all Qi can be calculated by Pi, we just need to calculate

sum = sigma_(i,1,n) {dis(X,Qi)}
= sigma_(i,1,n) {w[i]*|x-ci|}
So, the problem is, there are N points on a line, (c[1], c[2], ..., c[n]), calculate the minimal value of s(x) = sigma_(i,1,n) {w[i]*|x-c[i]|.
Let x[0]=c[0], s[0]=s(x[0]), q[0]=-sigma {w[i]}.
Then for 1<=j<=n,

x[j]=c[j]
dx=x[j]-x[j-1]
s[j]=s[j-1]+dx*q[j]
q[j]+=2*w[j]
Finally, calculate the minimal value of s[i].
import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round B Problem B: Center
 * Check README.md for explanation.
 */
public class Main {

    class Point {
        double x, y, w;
        public Point(double _x, double _y, double _w) {
            x=_x;y=_y;w=_w;
        }
    }

    private String solve(Scanner scanner) throws Throwable {
        int n=scanner.nextInt();
        Point[] points=new Point[n];
        double ans=1e10;
        for (int i=0;i<n;i++)
            points[i]=new Point(scanner.nextDouble(), scanner.nextDouble(), scanner.nextDouble());
        for (int i=0;i<n;i++) {
            double b1=points[i].y-points[i].x, sum=.0;
            Point[] p1=new Point[n];
            for (int j=0;j<n;j++) {
                double b2=points[j].x+points[j].y, qx=(b2-b1)/2;
                p1[j]=new Point(qx, 0, points[j].w);
                sum+=Math.abs(qx-points[j].x)*points[j].w;
            }
            Arrays.sort(p1, Comparator.comparingDouble(p->p.x));
            ans=Math.min(ans, sum+cal(p1, n));
        }
        return String.format("%.9f", ans);
    }

    private double cal(Point[] points, int n) {
        double x=points[0].x, sum=.0, q=.0;
        for (Point p: points) {
            sum+=Math.abs(x-p.x)*p.w;
            q-=p.w;
        }
        double ans=sum;
        for (int i=0;i<n;i++) {
            double nx=points[i].x, dx=nx-x;
            sum+=q*dx; q+=2*points[i].w;
            x=nx;
            ans=Math.min(ans, sum);
        }
        return ans;
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart math sum diagonal lines
<start>ai-kickstart dp tree math min max
DP problem.
For each position (i, j) and each 1<=v<=k, dp[i][j][v] means the largest v-Christmas tree with top (i,j). We just need to calculate the max value of dp[i][j][k].
To do this, just calculate the height of each point, then dp.
import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;

/**
 * KickStart 2017 Round B Problem C: Christmas Tree
 * Check README.md for explanation.
 */
public class Main {

    private String solve(Scanner scanner) throws Throwable {
        int m=scanner.nextInt(),n=scanner.nextInt(),k=scanner.nextInt();
        char[][] map=new char[m][n];
        for (int i=0;i<m;i++) map[i]=scanner.next().toCharArray();
        int[][] height=new int[m][n];
        int ans=0;
        for (int i=0;i<m;i++) {
            for (int j=0;j<n;j++) {
                int cnt=0;
                for (int r=i;r<m;r++) {
                    int h=r-i, left=j-h, right=j+h;
                    if (left<0 || right>=n) break;
                    boolean t=true;
                    for (int c=left;c<=right;c++) {
                        if (map[r][c]=='.') t=false;
                    }
                    if (!t) break;
                    cnt++;
                }
                height[i][j]=cnt;
            }
        }
        int[][][] dp=new int[m][n][k+1];
        for (int i=m-1;i>=0;i--) {
            for (int j=0;j<n;j++) {
                if (height[i][j]==0) continue;
                for (int v=1;v<=k;v++) {
                    for (int h=1;h<=height[i][j];h++) {
                        int row=i+h, left=j-h+1, right=j+h-1;
                        if (v==1) dp[i][j][v]=Math.max(dp[i][j][v], h*h);
                        else if (row<m) {
                            for (int u=left;u<=right;u++) {
                                if (dp[row][u][v-1]>0)
                                    dp[i][j][v]=Math.max(dp[i][j][v], h*h+dp[row][u][v-1]);

                            }
                        }
                    }
                }
                ans=Math.max(ans, dp[i][j][k]);
            }
        }
        return String.valueOf(ans);
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            try {
                System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
            }
            catch (Throwable e) {
                System.err.println("ERROR in case #"+t);
                e.printStackTrace();
            }
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart dp tree math min max
<start>ai-kickstart math square divide 
This is a math problem. Hard.
All the squares can be divided to two different types: center is a grid, or center is not a grid.

First, calculate the number of squares with a grid-center.
Let k is the minimal distance between the center and the border, then there are k*(k+1) squares. (Just draw some grids to figure out.)

Second, calculate the number of squares with a non-grid-center.
Let k is the minimal distance between the center and the border, then there are k*k squares. (Just draw some grids to figure out.)

So we can figure the small solver:

long cnt=0;
for (int i=1;i<=r;i++) {
    for (int j=1;j<=c;j++) {
        int k=Math.min(Math.min(i-1, r-i), Math.min(j-1, c-j));
        cnt+=k*(k+1);
        cnt%=1000000007;
    }
}
for (int i=1;i<r;i++) {
    for (int j=1;j<c;j++) {
        int k=Math.min(Math.min(i, r-i), Math.min(j, c-j));
        cnt+=k*k;
        cnt%=1000000007;
    }
}
return cnt;
As for large, we need to calculate the sum in O(1) time.
It's hard to calculate, but just check A.java for the result.
import java.io.PrintStream;
import java.util.*;

/**
 * KickStart 2017 Round A Problem A: Square Counting
 * Check README.md for explanation.
 */
public class Main {

    private String solve(Scanner scanner) {
        long r=scanner.nextLong(), c=scanner.nextLong(), m=Math.min(r, c);
        long cnt=0, mod=1000000007;

        long u=(m-2)/2, su1=sum(u, mod), su2=sum2(u, mod), su3=sum3(u, mod);
        cnt+=-8*su3+2*(r+c-6)*su2%mod+2*(r+c-2)*su1%mod;
        cnt%=mod;
        if (m%2!=0) {
            long k=(m-1)/2;
            cnt+=(r+c-m-2*k)*k%mod*(k+1)%mod;
        }

        long v=(m-1)/2, sv1=sum(v, mod), sv2=sum2(v, mod), sv3=sum3(v, mod);
        cnt+=-8*sv3+2*(r+c)*sv2%mod;
        cnt%=mod;
        if (m%2==0) {
            long k=m/2;
            cnt+=(r+c-m-2*k+1)*k%mod*k%mod;
        }
        while (cnt<0) cnt+=mod;
        cnt%=mod;
        return String.valueOf(cnt);
    }

    private long sum(long u, long mod) {
        // n*(n+1)/2
        return u*(u+1)/2%mod;
    }

    private long sum2(long u, long mod) {
        // n*(n+1)*(2n+1)/6
        long a=u, b=u+1, c=2*u+1;
        if (a%2==0) a/=2;
        else b/=2;
        if (a%3==0) a/=3;
        else if (b%3==0) b/=3;
        else c/=3;
        return a*b%mod*c%mod;
    }

    private long sum3(long u, long mod) {
        // (n*(n+1)/2)^2
        long s=sum(u, mod);
        return s*s%mod;
    }

    /*private long solveSmall(int m, int n) {
        long cnt=0;
        for (int i=1;i<=r;i++) {
            for (int j=1;j<=c;j++) {
                int k=Math.min(Math.min(i-1, r-i), Math.min(j-1, c-j));
                cnt+=k*(k+1);
                cnt%=1000000007;
            }
        }
        for (int i=1;i<r;i++) {
            for (int j=1;j<c;j++) {
                int k=Math.min(Math.min(i, r-i), Math.min(j, c-j));
                cnt+=k*k;
                cnt%=1000000007;
            }
        }
        return cnt;
    }*/


    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart math square divide 
<start>ai-kickstart dp chracters
Simple. DP.
dp[i][j] means if the first i characters in s1 and first j characters in s2 can match.
Just take care of *, it can only match 0-4 characters.
And some corner cases:

"", "*"
"a", "*"
"aaab", "*b"
"***a***a***a***a***a***", "*a"
...
import java.io.PrintStream;
import java.util.*;

/**
 * KickStart 2017 Round A Problem B: Patterns Overlap
 * Check README.md for explanation.
 */
public class Main {

    private String solve(Scanner scanner) {
        String s=scanner.next(), t=scanner.next();
        int l1=s.length(), l2=t.length();
        boolean[][] dp=new boolean[l1+1][l2+1];
        dp[0][0]=true;
        for (int i=1;i<=l1;i++) {
            if (s.charAt(i-1)=='*') dp[i][0]=true;
            else break;
        }
        for (int j=1;j<=l2;j++) {
            if (t.charAt(j-1)=='*') dp[0][j]=true;
            else break;
        }
        for (int i=1;i<=l1;i++) {
            for (int j=1;j<=l2;j++) {
                if (s.charAt(i-1)=='*') {
                    int cnt=0;
                    for (int k=j;k>=0;k--) {
                        if (dp[i-1][k]) {
                            dp[i][j]=true;
                            break;
                        }
                        if (k>0 && t.charAt(k-1)!='*') cnt++;
                        if (cnt>4) break;
                    }
                }
                if (t.charAt(j-1)=='*') {
                    int cnt=0;
                    for (int k=i;k>=0;k--) {
                        if (dp[k][j-1]) {
                            dp[i][j]=true;
                            break;
                        }
                        if (k>0 && s.charAt(k-1)!='*') cnt++;
                        if (cnt>4) break;
                    }
                }
                if (s.charAt(i-1)==t.charAt(j-1) && dp[i-1][j-1])
                    dp[i][j]=true;
            }
        }
        return dp[l1][l2]?"TRUE":"FALSE";
    }


    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart dp chracters
<start>ai-kickstart binary search possible statement
Consider the huge cube which can cover all the stars.
Then, the two cubes must be placed into the diagonal vertex. (left-front-top with right-back-bottom, etc.)
So, binary search for edge length, and check the four possible placements.
import java.io.PrintStream;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * KickStart 2017 Round A Problem C: Space Cubes
 * Check README.md for explanation.
 */
public class Main {

    class Star {
        long x, y, z, r;
        public Star(long _x, long _y, long _z, long _r) {
            x=_x;y=_y;z=_z;r=_r;
        }
    }

    private String solve(Scanner scanner) {
        int n=scanner.nextInt();
        Star[] stars=new Star[n];
        long[][] corner=new long[3][2];
        corner[0][0]=corner[1][0]=corner[2][0]=Integer.MIN_VALUE;
        corner[0][1]=corner[1][1]=corner[2][1]=Integer.MAX_VALUE;
        for (int i=0;i<n;i++) {
            stars[i]=new Star(scanner.nextLong(), scanner.nextLong(),
                    scanner.nextLong(), scanner.nextLong());
            corner[0][0]=Math.max(corner[0][0], stars[i].x+stars[i].r);
            corner[1][0]=Math.max(corner[1][0], stars[i].y+stars[i].r);
            corner[2][0]=Math.max(corner[2][0], stars[i].z+stars[i].r);
            corner[0][1]=Math.min(corner[0][1], stars[i].x-stars[i].r);
            corner[1][1]=Math.min(corner[1][1], stars[i].y-stars[i].r);
            corner[2][1]=Math.min(corner[2][1], stars[i].z-stars[i].r);
        }
        long start=1, end=Long.MAX_VALUE/10;
        while (start<end) {
            long mid=(start+end)/2;
            if (checkTopLeft(stars, mid, corner) || checkTopRight(stars, mid, corner)
                    || checkBottomLeft(stars, mid, corner) || checkBottomRight(stars, mid, corner))
                end=mid;
            else start=mid+1;
        }
        return String.valueOf(start);
    }

    private boolean checkTopLeft(Star[] stars, long candidate, long[][] corners) {
        for (Star star: stars) {
            if ((star.x-star.r<corners[0][0]-candidate || star.y-star.r<corners[1][0]-candidate
                    || star.z-star.r<corners[2][0]-candidate) && (star.x+star.r>corners[0][1]+candidate
                    || star.y+star.r>corners[1][1]+candidate || star.z+star.r>corners[2][1]+candidate))
                return false;
        }
        return true;
    }

    private boolean checkTopRight(Star[] stars, long candidate, long[][] corners) {
        for (Star star: stars) {
            if ((star.x-star.r<corners[0][0]-candidate || star.y+star.r>corners[1][1]+candidate
                    || star.z-star.r<corners[2][0]-candidate) && (star.x+star.r>corners[0][1]+candidate
                    || star.y-star.r<corners[1][0]-candidate || star.z+star.r>corners[2][1]+candidate))
                return false;
        }
        return true;
    }

    private boolean checkBottomLeft(Star[] stars, long candidate, long[][] corners) {
        for (Star star: stars) {
            if ((star.x+star.r>corners[0][1]+candidate || star.y-star.r<corners[1][0]-candidate
                    || star.z-star.r<corners[2][0]-candidate) && (star.x-star.r<corners[0][0]-candidate
                    || star.y+star.r>corners[1][1]+candidate || star.z+star.r>corners[2][1]+candidate))
                return false;
        }
        return true;
    }

    private boolean checkBottomRight(Star[] stars, long candidate, long[][] corners) {
        for (Star star: stars) {
            if ((star.x+star.r>corners[0][1]+candidate || star.y+star.r>corners[1][1]+candidate
                    || star.z-star.r<corners[2][0]-candidate) && (star.x-star.r<corners[0][0]-candidate
                    || star.y-star.r<corners[1][0]-candidate || star.z+star.r>corners[2][1]+candidate))
                return false;
        }
        return true;
    }

    public static void main(String[] args) throws Exception {
        System.setOut(new PrintStream("output.txt"));
        Scanner scanner=new Scanner(System.in);
        int times=scanner.nextInt();
        long start=System.currentTimeMillis();
        for (int t=1;t<=times;t++) {
            System.out.println(String.format("Case #%d: %s", t, new Main().solve(scanner)));
        }
        long end=System.currentTimeMillis();
        System.err.println(String.format("Time used: %.3fs", (end-start)/1000.0));

    }

}
<end>ai-kickstart binary search possible statement
<start>ai-get input vector
int v;
for(int i=0;i<n;i++)
{
	vector.push_back(v);
}
<end>ai-get input vector
<start>ai-start cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
   
<end>ai-start cpp
<start>ai-get n
 int ;
 cin>>n;

<end>ai-get n
<start>ai-case output
int t;
int i=0;
while(i++<t)
{
	cout<<"Case #"<<i<<": "<<result; 
}
<end>ai-case output
<start>ai-array count occurence interval
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int a1,b,c;
	cin>>a1>>b>>c;
	map <int,int> a;
	int l,r,l1,r1,l2,r2;
	int min,max;
	 
	cin>>l>>r;
	min=l;max=r;
	for(int i=l;i<r;i++)
	a[i]++;
	 cin>>l1>>r1;
	 if(min>l1)min=l1;
		if(max<r1)max=r1;
for(int i=l1;i<r1;i++)
	a[i]++;
	 cin>>l2>>r2;
	 if(min>l2)min=l2;
		if(max<r2)max=r2;
	for(int i=l2;i<r2;i++)
	a[i]++;
	int count1=0;int count2=0;int count3=0;
		for(int i=min;i<max;i++)
		{
			if(a[i]==1)
			count1++;
			if(a[i]==2)
			count2++;
				if(a[i]==3)
			count3++;	 
		}
		cout<<count1*1*a1+count2*2*b+count3*3*c;
	return 0;
}

<end>ai-array count occurence interval
<start>ai-matrix identical
#include <stdio.h>
#define N 4
 
// This function returns 1 if A[][] and B[][] are identical
// otherwise returns 0
int areSame(int A[][N], int B[][N])
{
    int i, j;
    for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
            if (A[i][j] != B[i][j])
                return 0;
    return 1;
}
int main()
{
    int A[N][N] = { {1, 1, 1, 1},
                    {2, 2, 2, 2},
                    {3, 3, 3, 3},
                    {4, 4, 4, 4}};
 
    int B[N][N] = { {1, 1, 1, 1},
                    {2, 2, 2, 2},
                    {3, 3, 3, 3},
                    {4, 4, 4, 4}};
 
    if (areSame(A, B))
        printf("Matrices are identical");
    else
        printf("Matrices are not identical");
    return 0;
}
<end>ai-matrix identical
<start>ai-matrix transpose
#include <stdio.h>
#define N 4
 
// This function stores transpose of A[][] in B[][]
void transpose(int A[][N], int B[][N])
{
    int i, j;
    for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
            B[i][j] = A[j][i];
}
 
int main()
{
    int A[N][N] = { {1, 1, 1, 1},
                    {2, 2, 2, 2},
                    {3, 3, 3, 3},
                    {4, 4, 4, 4}};
 
    int B[N][N], i, j;
 
    transpose(A, B);
 
    printf("Result matrix is n");
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < N; j++)
           printf("%d ", B[i][j]);
        printf("\n");
    }
 
    return 0;
}
<end>ai-matrix transpose
<start>ai-matrix opertaion
#include <stdio.h>
#define N 4
//subtract two matrix
void subtract(int A[][N], int B[][N], int C[][N])
{
    int i, j;
    for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
            C[i][j] = A[i][j] - B[i][j];
}
 
int main()
{
    int A[N][N] = { {1, 1, 1, 1},
                    {2, 2, 2, 2},
                    {3, 3, 3, 3},
                    {4, 4, 4, 4}};
 
    int B[N][N] = { {1, 1, 1, 1},
                    {2, 2, 2, 2},
                    {3, 3, 3, 3},
                    {4, 4, 4, 4}};
 
    int C[N][N]; // To store result
    int i, j;
    subtract(A, B, C);
 
    printf("Result matrix is \n");
    for (i = 0; i < N; i++)
    {
        for (j = 0; j < N; j++)
           printf("%d ", C[i][j]);
        printf("\n");
    }
 
    return 0;
}
<end>ai-matrix opertaion
<start>ai-matrix compare character
#include <bits/stdc++.h>
using namespace std;
char c[7][7];
int main () {
    for(int i = 0; i < 7; ++i)
        for (int j = 0; j < 7; ++j)
            cin >> c[i][j];
    int cnt = 0;
    for (int i = 0; i < 7; ++i)
        for (int j = 0; j < 7; ++j) 
            if (c[i][j] == '.') {
                if (i > 1 && c[i - 1][j] == c[i - 2][j] && c[i - 1][j] == 'o')
                    ++cnt;
                if (i < 5 && c[i + 1][j] == c[i + 2][j] && c[i + 2][j] == 'o')
                    ++cnt;
                if (j > 1 && c[i][j - 1] == c[i][j - 2] && c[i][j - 2] == 'o')
                    ++cnt;
                if (j < 5 && c[i][j + 1] == c[i][j + 2] && c[i][j + 2] == 'o')
                    ++cnt;
            }
    cout << cnt;
    return 0;
}
<end>ai-matrix compare character
<start>ai-array max distinct number in minimum index 
//array maximum distinct number index is minimum
/*
6
25 7
26 1
15 1
22 3
20 1
30 1
between 26 and 22 we have 4 distinct number 
and 26-22=4
/*/
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 5e5 + 10;

pair<int, int> arr[MAXN];
int n;
int have[MAXN], num, maper;
map<int, int> mp;
int answer = 1e9 + 1;

int main()
{
	ios::sync_with_stdio(0);
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> arr[i].first >> arr[i].second;
		if (mp[arr[i].second] == 0)
		{
			mp[arr[i].second] = ++maper;
		}
		arr[i].second = mp[arr[i].second];
	}
	sort(arr, arr + n);
	int posl = 0;
	int posr = 0;
	have[arr[0].second]++;
	num = 1;
	for (int i = 0; i < n; i++)
	{
		if (i)
		{
			posl++;
			have[arr[posl - 1].second]--;
			if (have[arr[posl - 1].second] == 0)
			{
				num--;
			}
		}
		while (num < maper && posr < n - 1)
		{
			posr++;
			have[arr[posr].second]++;
			if (have[arr[posr].second] == 1)
			{
				num++;
			}
		}
		//cout << posl << ' ' << posr <<' ' << arr[posr].first << ' ' << arr[posl].first << ' ' << endl;
		if (num == maper)
			answer = min(answer, arr[posr].first - arr[posl].first);
	}
	cout << answer;
	//cin >> n;
	return 0;
}
<end>ai-array max distinct number in minimum index 
<start>ai-math array maximum square 
#include<bits/stdc++.h>
#define ll long long
#define pb push_back
#define mp make_Pair
#define ld long double
#define F first
#define S second

using namespace :: std;

const ll maxn=1e5+500;

ll a[maxn];

int main(){
	ll n,m;
	cin>>m>>n;
	for(ll i=0;i<n;i++){
		cin>>a[i];
	}
	ll ans=0;
	sort(a,a+n);
	ll bar=1;
	ll ki=n-2;
	ll cha=a[n-1];
	while(ki>=0){
		if(a[ki]==cha){
			ki--;
			bar++;
		}
		else{
			ll t=cha-a[ki];
			if(t*bar<=m){
				m-=t*bar;
				cha=a[ki];
			}
			else{
				break;
			}
			ki--;
			bar++;
		}
	}
	for(ll i=0;i<=ki;i++){
		ans+=a[i]*a[i];
	}
	ll t=m/bar;
	cha-=t;
	m-=t*bar;
	ans+=(cha-1)*(cha-1)*m;
	ans+=cha*cha*(bar-m);
	cout<<ans;

}
<end>ai-math array maximum square 
<start>ai-convert a to b with multiply of gcd of b
//array compare with number array groups
#include <bits/stdc++.h>
#define pb push_back
#define X first
#define Y second
typedef long long ll;

using namespace std ;
const ll maxn = 1e6+5 ;
const ll INF = 4e18 ;

int z, x, n, a, b, minn, dp[maxn];
vector<int> v[100000 + 5];

int main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> a >> b;
	n = 100000 + 1;
	for(int i = 2; i <= n; i++)
		for(int j = i * 2; j <= n; j += i)
			v[j].pb(i);
	//cout << "salam" << endl;
	dp[b] = 0;
	for(int i = b - 1; i >= a; i--){
		z = v[i].size(), minn = 10000000;
		for(int j = 0; j < z; j++){
			x = v[i][j];
			if(i + x > b) 
				continue;
			if(dp[i + x] != -1)
				minn = min(minn, dp[i + x] + 1);
		}
		if(minn == 10000000)
			dp[i] = -1;
		else
			dp[i] = minn;
	}
	cout << dp[a];
	return 0;
}
<end>ai-convert a to b with multiply of gcd of b
<start>ai-tree lr character travers
 
 #include <bits/stdc++.h>
using namespace std;
#include<algorithm>
#include<map>
#include<vector>
#include <iomanip>
#include <set>
#include<cmath>
#define F first
#define S second
#define pii pair<int,int>
#define pb push_back
#define ll long long
#define mp make_pair
#define error(x) cout<<#x<<"="<<(x)<<endl;
void sp(double y,int x){cout<<fixed<<setprecision(x)<<y;}
int inf=1e9+10;
int const M=2e5+10;
int const M2=1e6+10;
int const M3=1e3+10;
int mod=1e9+7;
ll pw[M];
int sa(int x,int y){if(x%y==0)return x/y;return x/y+1;}
int binp(int x,int y){int ans=1;int t=x;while(y!=0){if(y%2==1){ans*=t;ans;}y/=2;t*=t;t;}return ans;}
int main(){
	ios::sync_with_stdio(0) , cin.tie(0) , cout.tie(0);
	ll n;
	cin>>n;
	string x;
	cin>>x;
	pw[0]=1;
	for(int i=1;i<=32;i++)
        pw[i]=pw[i-1]*2;
    ll inc=0;
    ll now=pw[n+1]-1;
    ll pnt=pw[n+1]-1;
	for(int i=0;i<x.size();i++)
    {
        ll mo=1;
        if(x[i]=='L')
            mo=0;
        pnt-=pw[i];
        inc+=mo;
        now=pnt-inc;
        inc*=2;
    }
    cout<<now;
}
<end>ai-tree lr character travers
<start>ai-matrix distance graph dfs
#include <bits/stdc++.h>
using namespace std;
#define F first
#define S second
#define pb push_back
const long long INF=1e9+10,MAX=100,MOD=1e9+7;
typedef long long ll;
typedef pair<ll,ll> pii;
typedef pair<pii,ll> piii;
void OUT(long double o,int x){
	 cout<<fixed<<setprecision(x)<<o;
	 return;
}
char a[MAX][MAX];
ll X[20]={0,-1,1,0};
ll Y[20]={-1,0,0,1};
ll n,m,di[20][20];
vector<pii> vec[20];
void dfs0(pii v,int d){
	a[v.F][v.S]=char(int('0')+d);
	for(int i=0;i<4;i++){
		if((v.F+X[i]<=n and v.F+X[i]>0) and  (v.S+Y[i]<=m and (v.S+Y[i]>0 and a[v.F+X[i]][v.S+Y[i]]=='X')))
			dfs0({v.F+X[i],v.S+Y[i]},d);
	}
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	}
	ll d=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='X'){
				dfs0({i,j},d);
				d++;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='0')
				vec[0].pb({i,j});
			if(a[i][j]=='1')
				vec[1].pb({i,j});
			if(a[i][j]=='2')
				vec[2].pb({i,j});
		}
	}
	ll mi=INF;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='.'){
				ll ans=0;
				for(int k=0;k<3;k++){
					ll q=INF;
					for(pii h:vec[k])
						q=min(q,abs(i-h.F)+abs(j-h.S));
					ans+=q;
				}
				mi=min(ans-2,mi);
			}
		}
	}
	for(int i=0;i<3;i++){
		for(int j=i+1;j<3;j++){
			ll ans=INF;
			for(pii k:vec[i]){
				for(pii h:vec[j])
					ans=min(ans,abs(k.F-h.F)+abs(k.S-h.S));
			}
			di[i][j]=ans;
		}
	}
	mi=min(mi,di[0][1]+di[0][2]-2);
	mi=min(mi,di[0][1]+di[1][2]-2);
	mi=min(mi,di[1][2]+di[0][2]-2);
	cout<<mi;
	return 0;
}
<end>ai-matrix distance graph dfs
<start>ai-matrix distance graph dfs
#include <bits/stdc++.h>
using namespace std;
#define F first
/* مطابق شکل زیر اگر بلوک‌های گلی‌ای که با * مشخص شده اند را خراب کنند تمامی سلول‌ها به هم متصل می‌شوند.

................
..XXXX....XXX...
...XXXX*...XX...
.XXXX..**..XXX..
...*....XXXXX...
..XXX....XXX....

*/

#define S second
#define pb push_back
const long long INF=1e9+10,MAX=100,MOD=1e9+7;
typedef long long ll;
typedef pair<ll,ll> pii;
typedef pair<pii,ll> piii;
void OUT(long double o,int x){
	 cout<<fixed<<setprecision(x)<<o;
	 return;
}
char a[MAX][MAX];
ll X[20]={0,-1,1,0};
ll Y[20]={-1,0,0,1};
ll n,m,di[20][20];
vector<pii> vec[20];
void dfs0(pii v,int d){
	a[v.F][v.S]=char(int('0')+d);
	for(int i=0;i<4;i++){
		if((v.F+X[i]<=n and v.F+X[i]>0) and  (v.S+Y[i]<=m and (v.S+Y[i]>0 and a[v.F+X[i]][v.S+Y[i]]=='X')))
			dfs0({v.F+X[i],v.S+Y[i]},d);
	}
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	}
	ll d=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='X'){
				dfs0({i,j},d);
				d++;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='0')
				vec[0].pb({i,j});
			if(a[i][j]=='1')
				vec[1].pb({i,j});
			if(a[i][j]=='2')
				vec[2].pb({i,j});
		}
	}
	ll mi=INF;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='.'){
				ll ans=0;
				for(int k=0;k<3;k++){
					ll q=INF;
					for(pii h:vec[k])
						q=min(q,abs(i-h.F)+abs(j-h.S));
					ans+=q;
				}
				mi=min(ans-2,mi);
			}
		}
	}
	for(int i=0;i<3;i++){
		for(int j=i+1;j<3;j++){
			ll ans=INF;
			for(pii k:vec[i]){
				for(pii h:vec[j])
					ans=min(ans,abs(k.F-h.F)+abs(k.S-h.S));
			}
			di[i][j]=ans;
		}
	}
	mi=min(mi,di[0][1]+di[0][2]-2);
	mi=min(mi,di[0][1]+di[1][2]-2);
	mi=min(mi,di[1][2]+di[0][2]-2);
	cout<<mi;
	return 0;
}
<end>ai-matrix distance graph dfs
<start>ai-matrix distance graph dfs2
#include <bits/stdc++.h>
using namespace std;
#define F first
/* مطابق شکل زیر اگر بلوک‌های گلی‌ای که با * مشخص شده اند را خراب کنند تمامی سلول‌ها به هم متصل می‌شوند.

................
..XXXX....XXX...
...XXXX*...XX...
.XXXX..**..XXX..
...*....XXXXX...
..XXX....XXX....

*/

#define S second
#define pb push_back
const long long INF=1e9+10,MAX=100,MOD=1e9+7;
typedef long long ll;
typedef pair<ll,ll> pii;
typedef pair<pii,ll> piii;
void OUT(long double o,int x){
	 cout<<fixed<<setprecision(x)<<o;
	 return;
}
char a[MAX][MAX];
ll X[20]={0,-1,1,0};
ll Y[20]={-1,0,0,1};
ll n,m,di[20][20];
vector<pii> vec[20];
void dfs0(pii v,int d){
	a[v.F][v.S]=char(int('0')+d);
	for(int i=0;i<4;i++){
		if((v.F+X[i]<=n and v.F+X[i]>0) and  (v.S+Y[i]<=m and (v.S+Y[i]>0 and a[v.F+X[i]][v.S+Y[i]]=='X')))
			dfs0({v.F+X[i],v.S+Y[i]},d);
	}
	return;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	}
	ll d=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='X'){
				dfs0({i,j},d);
				d++;
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='0')
				vec[0].pb({i,j});
			if(a[i][j]=='1')
				vec[1].pb({i,j});
			if(a[i][j]=='2')
				vec[2].pb({i,j});
		}
	}
	ll mi=INF;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='.'){
				ll ans=0;
				for(int k=0;k<3;k++){
					ll q=INF;
					for(pii h:vec[k])
						q=min(q,abs(i-h.F)+abs(j-h.S));
					ans+=q;
				}
				mi=min(ans-2,mi);
			}
		}
	}
	for(int i=0;i<3;i++){
		for(int j=i+1;j<3;j++){
			ll ans=INF;
			for(pii k:vec[i]){
				for(pii h:vec[j])
					ans=min(ans,abs(k.F-h.F)+abs(k.S-h.S));
			}
			di[i][j]=ans;
		}
	}
	mi=min(mi,di[0][1]+di[0][2]-2);
	mi=min(mi,di[0][1]+di[1][2]-2);
	mi=min(mi,di[1][2]+di[0][2]-2);
	cout<<mi;
	return 0;
}
<end>ai-matrix distance graph dfs2
<start>ai-array max interval distinct 
#include<iostream>
//#include <bits/stdc++.h>
using namespace std;
#include<algorithm>
#include<map>
#include<vector>
#include <iomanip>
#include <set>
#include<cmath>
#define F first
#define S second
#define pii pair<int,int>
#define pb push_back
#define ll long long
#define mp make_pair
#define error(x) cout<<#x<<"="<<(x)<<endl;
void sp(double y,int x){cout<<fixed<<setprecision(x)<<y;}
int inf=1e9+10;
int const M=1e6+10;
int const M2=1e6+10;
int const M3=1e3+10;
int mod=1e9+7;
pii cur[M];
int maxx[4*M];
int l[M],r[M];
int hlp=0;
int dp[M];
bool cmp(pii a,pii b)
{
    if(a.F<b.F)
        return 1;
    if(b.F<a.F)
        return 0;
    if(a.S<b.S)
        return 0;
    return 1;
}
void qu(int l,int r,int node,int st,int en)
{
    int mid=(l+r)/2;
    if(l>en || st>r)
        return;
    if(st<=l && r<=en){
        hlp=max(hlp,maxx[node]);
        return;
    }
    qu(l,mid,node*2,st,en);
    qu(mid+1,r,node*2+1,st,en);
}
void add(int l,int r,int node,int x,int st)
{
   // cerr<<l<<" "<<r<<endl;
    if(l==r){
        maxx[node]=x;
        return;
    }
    int mid=(l+r)/2;
    if(mid>=st)
    {
        add(l,mid,node*2,x,st);
    }
    else
        add(mid+1,r,node*2+1,x,st);
    maxx[node]=max(maxx[node*2],maxx[node*2+1]);
}
int sa(int x,int y){if(x%y==0)return x/y;return x/y+1;}
int binp(int x,int y){int ans=1;int t=x;while(y!=0){if(y%2==1){ans*=t;ans;}y/=2;t*=t;t;}return ans;}
int main(){
	ios::sync_with_stdio(0) , cin.tie(0) , cout.tie(0);
	ll n;
	cin>>n;
	for(int i=1;i<=n;i++)
        cin>>cur[i].F>>cur[i].S;
    sort(cur+1,cur+n+1,cmp);
    for(int i=1;i<=n;i++)
        l[i]=cur[i].F,r[i]=cur[i].S;
    int ans=1;
    for(int i=n;i>=1;i--)
    {
        if(l[i]==l[i+1] && r[i]==r[i+1])
            continue;
        hlp=0;
        qu(1,1e6,1,l[i],r[i]);
        ans=max(ans,hlp+1);
        add(1,1e6,1,hlp+1,r[i]);
    }
    cout<<ans;
}
<end>ai-array max interval distinct 
<start>ai-max min average floating point
#include <bits/stdc++.h>
using namespace std;
int main()
{
	float a,b,c,d;
	cin>>a>>b>>c>>d;
    cout<<"Sum : "<<fixed<<setprecision( 6) <<(float)(a+b+c+d)<<endl;
    cout<<"Average : "<<fixed<<setprecision( 6)<<(float)((a+b+c+d)/4)<<endl;
    cout<<"Product : "<<fixed<<setprecision( 6)<<(float)((a*b*c*d))<<endl;
    cout<<"MAX : "<<fixed<<setprecision( 6)<<(float)(max(max(a,b),max(c,d)))<<endl;
    cout<<"MIN : "<<fixed<<setprecision( 6)<<(float)(min(min(a,b),min(c,d)))<<endl;
} 



<end>ai-max min average floating point
<start>ai-array integer reverse in stirng
#include <bits/stdc++.h>
using namespace std;
int main()
{
	
	int  a=0;
	string result="";
	 do
	 {
	 	cin>>a;
	 	if(a!=0)
	 	result=to_string(a)+" "+result;
     }
     while(a!=0);
     cout<<result;
} 




<end>ai-array integer reverse in stirng
<start>ai-integer to string 
 int a=0;
 string s="";
 s=to_string(a) ;
   



<end>ai-integer to string 
<start>ai-matrix pascal triangle
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin>>n;
    int a[n][n];
    a[0][0]=1;
    cout<<endl<<a[0][0]<<endl;
    for(int i=0;i<n;i++)
    {
    	a[i+1][0]=1;
    	cout<<a[i+1][0]<<" ";
    	for(int j=0;j<i;j++)
    	{
    		a[i+1][j+1]=a[i][j]+a[i][j+1];
    		cout<<a[i+1][j+1]<<" ";
        }
        a[i+1][i+1]=1;
        cout<<a[i+1][i+1]<<endl;
    }
    return 0;
}

 



<end>ai-matrix pascal triangle
<start>ai-pascal matrix triangle
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin>>n;
    int a[n][n];
    a[0][0]=1;
    cout<<endl<<a[0][0]<<endl;
    for(int i=0;i<n;i++)
    {
    	a[i+1][0]=1;
    	cout<<a[i+1][0]<<" ";
    	for(int j=0;j<i;j++)
    	{
    		a[i+1][j+1]=a[i][j]+a[i][j+1];
    		cout<<a[i+1][j+1]<<" ";
        }
        a[i+1][i+1]=1;
        cout<<a[i+1][i+1]<<endl;
    }
    return 0;
}

 



<end>ai-pascal matrix triangle
<start>ai-ruby hello world
puts 'Hello, world!'

<end>ai-ruby hello world
<start>ai-ruby  pair
# the function must be defined in such a place 
# ... so as to "catch" the binding of the vars ... cheesy
# otherwise we're kinda stuck with the extra param on the caller
@_binding = binding
def write_pair(p, b = @_binding)
  eval("
    local_variables.each do |v| 
      if eval(v.to_s + \".object_id\") == " + p.object_id.to_s + "
        puts v.to_s + ': ' + \"" + p.to_s + "\"
      end
    end
  " , b)
end

# if the binding is an issue just do here:
# write_pair = lambda { |p| write_pair(p, binding) }

# just some test vars to make sure it works
username1 = "tyndall"
username  = "tyndall2"
username3 = "tyndall"

# the result:
write_pair(username)
# username: tyndall
<end>ai-ruby  pair
<start>ai-matrix insert function
// Program to count islands in boolean 2D matrix
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
 
#define ROW 5
#define COL 5
 
// A function to check if a given cell (row, col) can be included in DFS
int isSafe(int M[][COL], int row, int col, bool visited[][COL])
{
    // row number is in range, column number is in range and value is 1 
    // and not yet visited
    return (row >= 0) && (row < ROW) &&     
           (col >= 0) && (col < COL) &&      
           (M[row][col] && !visited[row][col]); 
}
 
// A utility function to do DFS for a 2D boolean matrix. It only considers
// the 8 neighbours as adjacent vertices
void DFS(int M[][COL], int row, int col, bool visited[][COL])
{
    // These arrays are used to get row and column numbers of 8 neighbours 
    // of a given cell
    static int rowNbr[] = {-1, -1, -1,  0, 0,  1, 1, 1};
    static int colNbr[] = {-1,  0,  1, -1, 1, -1, 0, 1};
 
    // Mark this cell as visited
    visited[row][col] = true;
 
    // Recur for all connected neighbours
    for (int k = 0; k < 8; ++k)
        if (isSafe(M, row + rowNbr[k], col + colNbr[k], visited) )
            DFS(M, row + rowNbr[k], col + colNbr[k], visited);
}
 
// The main function that returns count of islands in a given boolean
// 2D matrix
int countIslands(int M[][COL])
{
    // Make a bool array to mark visited cells.
    // Initially all cells are unvisited
    bool visited[ROW][COL];
    memset(visited, 0, sizeof(visited));
 
    // Initialize count as 0 and travese through the all cells of
    // given matrix
    int count = 0;
    for (int i = 0; i < ROW; ++i)
        for (int j = 0; j < COL; ++j)
            if (M[i][j] && !visited[i][j]) // If a cell with value 1 is not
            {                         // visited yet, then new island found
                DFS(M, i, j, visited);     // Visit all cells in this island.
                ++count;                   // and increment island count
            }
 
    return count;
}
 
// Driver program to test above function
int main()
{
    int M[][COL]= {  {1, 1, 0, 0, 0},
        {0, 1, 0, 0, 1},
        {1, 0, 0, 1, 1},
        {0, 0, 0, 0, 0},
        {1, 0, 1, 0, 1}
    };
 
    printf("Number of islands is: %d\n", countIslands(M));
 
    return 0;
}
<end>ai-matrix insert function
<start>ai-function matrix insert
// Program to count islands in boolean 2D matrix
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
 
#define ROW 5
#define COL 5
 
// A function to check if a given cell (row, col) can be included in DFS
int isSafe(int M[][COL], int row, int col, bool visited[][COL])
{
    // row number is in range, column number is in range and value is 1 
    // and not yet visited
    return (row >= 0) && (row < ROW) &&     
           (col >= 0) && (col < COL) &&      
           (M[row][col] && !visited[row][col]); 
}
 
// A utility function to do DFS for a 2D boolean matrix. It only considers
// the 8 neighbours as adjacent vertices
void DFS(int M[][COL], int row, int col, bool visited[][COL])
{
    // These arrays are used to get row and column numbers of 8 neighbours 
    // of a given cell
    static int rowNbr[] = {-1, -1, -1,  0, 0,  1, 1, 1};
    static int colNbr[] = {-1,  0,  1, -1, 1, -1, 0, 1};
 
    // Mark this cell as visited
    visited[row][col] = true;
 
    // Recur for all connected neighbours
    for (int k = 0; k < 8; ++k)
        if (isSafe(M, row + rowNbr[k], col + colNbr[k], visited) )
            DFS(M, row + rowNbr[k], col + colNbr[k], visited);
}
 
// The main function that returns count of islands in a given boolean
// 2D matrix
int countIslands(int M[][COL])
{
    // Make a bool array to mark visited cells.
    // Initially all cells are unvisited
    bool visited[ROW][COL];
    memset(visited, 0, sizeof(visited));
 
    // Initialize count as 0 and travese through the all cells of
    // given matrix
    int count = 0;
    for (int i = 0; i < ROW; ++i)
        for (int j = 0; j < COL; ++j)
            if (M[i][j] && !visited[i][j]) // If a cell with value 1 is not
            {                         // visited yet, then new island found
                DFS(M, i, j, visited);     // Visit all cells in this island.
                ++count;                   // and increment island count
            }
 
    return count;
}
 
// Driver program to test above function
int main()
{
    int M[][COL]= {  {1, 1, 0, 0, 0},
        {0, 1, 0, 0, 1},
        {1, 0, 0, 1, 1},
        {0, 0, 0, 0, 0},
        {1, 0, 1, 0, 1}
    };
 
    printf("Number of islands is: %d\n", countIslands(M));
 
    return 0;
}
<end>ai-function matrix insert
<start>ai-matrix island count
// Program to count islands in boolean 2D matrix
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
 
#define ROW 5
#define COL 5
 
// A function to check if a given cell (row, col) can be included in DFS
int isSafe(int M[][COL], int row, int col, bool visited[][COL])
{
    // row number is in range, column number is in range and value is 1 
    // and not yet visited
    return (row >= 0) && (row < ROW) &&     
           (col >= 0) && (col < COL) &&      
           (M[row][col] && !visited[row][col]); 
}
 
// A utility function to do DFS for a 2D boolean matrix. It only considers
// the 8 neighbours as adjacent vertices
void DFS(int M[][COL], int row, int col, bool visited[][COL])
{
    // These arrays are used to get row and column numbers of 8 neighbours 
    // of a given cell
    static int rowNbr[] = {-1, -1, -1,  0, 0,  1, 1, 1};
    static int colNbr[] = {-1,  0,  1, -1, 1, -1, 0, 1};
 
    // Mark this cell as visited
    visited[row][col] = true;
 
    // Recur for all connected neighbours
    for (int k = 0; k < 8; ++k)
        if (isSafe(M, row + rowNbr[k], col + colNbr[k], visited) )
            DFS(M, row + rowNbr[k], col + colNbr[k], visited);
}
 
// The main function that returns count of islands in a given boolean
// 2D matrix
int countIslands(int M[][COL])
{
    // Make a bool array to mark visited cells.
    // Initially all cells are unvisited
    bool visited[ROW][COL];
    memset(visited, 0, sizeof(visited));
 
    // Initialize count as 0 and travese through the all cells of
    // given matrix
    int count = 0;
    for (int i = 0; i < ROW; ++i)
        for (int j = 0; j < COL; ++j)
            if (M[i][j] && !visited[i][j]) // If a cell with value 1 is not
            {                         // visited yet, then new island found
                DFS(M, i, j, visited);     // Visit all cells in this island.
                ++count;                   // and increment island count
            }
 
    return count;
}
 
// Driver program to test above function
int main()
{
    int M[][COL]= {  {1, 1, 0, 0, 0},
        {0, 1, 0, 0, 1},
        {1, 0, 0, 1, 1},
        {0, 0, 0, 0, 0},
        {1, 0, 1, 0, 1}
    };
 
    printf("Number of islands is: %d\n", countIslands(M));
 
    return 0;
}
<end>ai-matrix island count
<start>ai-island count matrix
// Program to count islands in boolean 2D matrix
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
 
#define ROW 5
#define COL 5
 
// A function to check if a given cell (row, col) can be included in DFS
int isSafe(int M[][COL], int row, int col, bool visited[][COL])
{
    // row number is in range, column number is in range and value is 1 
    // and not yet visited
    return (row >= 0) && (row < ROW) &&     
           (col >= 0) && (col < COL) &&      
           (M[row][col] && !visited[row][col]); 
}
 
// A utility function to do DFS for a 2D boolean matrix. It only considers
// the 8 neighbours as adjacent vertices
void DFS(int M[][COL], int row, int col, bool visited[][COL])
{
    // These arrays are used to get row and column numbers of 8 neighbours 
    // of a given cell
    static int rowNbr[] = {-1, -1, -1,  0, 0,  1, 1, 1};
    static int colNbr[] = {-1,  0,  1, -1, 1, -1, 0, 1};
 
    // Mark this cell as visited
    visited[row][col] = true;
 
    // Recur for all connected neighbours
    for (int k = 0; k < 8; ++k)
        if (isSafe(M, row + rowNbr[k], col + colNbr[k], visited) )
            DFS(M, row + rowNbr[k], col + colNbr[k], visited);
}
 
// The main function that returns count of islands in a given boolean
// 2D matrix
int countIslands(int M[][COL])
{
    // Make a bool array to mark visited cells.
    // Initially all cells are unvisited
    bool visited[ROW][COL];
    memset(visited, 0, sizeof(visited));
 
    // Initialize count as 0 and travese through the all cells of
    // given matrix
    int count = 0;
    for (int i = 0; i < ROW; ++i)
        for (int j = 0; j < COL; ++j)
            if (M[i][j] && !visited[i][j]) // If a cell with value 1 is not
            {                         // visited yet, then new island found
                DFS(M, i, j, visited);     // Visit all cells in this island.
                ++count;                   // and increment island count
            }
 
    return count;
}
 
// Driver program to test above function
int main()
{
    int M[][COL]= {  {1, 1, 0, 0, 0},
        {0, 1, 0, 0, 1},
        {1, 0, 0, 1, 1},
        {0, 0, 0, 0, 0},
        {1, 0, 1, 0, 1}
    };
 
    printf("Number of islands is: %d\n", countIslands(M));
 
    return 0;
}
<end>ai-island count matrix
<start>ai-matrix submatrix maxmimum number
// C/C++ code for Maximum size square sub-matrix with all 1s
#include<stdio.h>
#include<algorithm>
#define bool int
#define R 6
#define C 5
/* UTILITY FUNCTIONS */
/* Function to get minimum of three values */
int min(int a, int b, int c)
{
  int m = a;
  if (m > b) 
    m = b;
  if (m > c) 
    m = c;
  return m;
}
void printMaxSubSquare(bool M[R][C])
{
  int i,j;
  int S[R][C];
  int max_of_s, max_i, max_j; 
  
  /* Set first column of S[][]*/
  for(i = 0; i < R; i++)
     S[i][0] = M[i][0];
  
  /* Set first row of S[][]*/    
  for(j = 0; j < C; j++)
     S[0][j] = M[0][j];
      
  /* Construct other entries of S[][]*/
  for(i = 1; i < R; i++)
  {
    for(j = 1; j < C; j++)
    {
      if(M[i][j] == 1) 
        S[i][j] = min(S[i][j-1], S[i-1][j], S[i-1][j-1]) + 1;
      else
        S[i][j] = 0;
    }    
  } 
   
  /* Find the maximum entry, and indexes of maximum entry 
     in S[][] */
  max_of_s = S[0][0]; max_i = 0; max_j = 0;
  for(i = 0; i < R; i++)
  {
    for(j = 0; j < C; j++)
    {
      if(max_of_s < S[i][j])
      {
         max_of_s = S[i][j];
         max_i = i; 
         max_j = j;
      }        
    }                 
  }     
   
  printf("Maximum size sub-matrix is: \n");
  for(i = max_i; i > max_i - max_of_s; i--)
  {
    for(j = max_j; j > max_j - max_of_s; j--)
    {
      printf("%d ", M[i][j]);
    }  
    printf("\n");
  }  
}     
 

 
/* Driver function to test above functions */
int main()
{
  bool M[R][C] =  {{0, 1, 1, 0, 1}, 
                   {1, 1, 0, 1, 0}, 
                   {0, 1, 1, 1, 0},
                   {1, 1, 1, 1, 0},
                   {1, 1, 1, 1, 1},
                   {0, 0, 0, 0, 0}};
                
  printMaxSubSquare(M);
  getchar();  
}  
<end>ai-matrix submatrix maxmimum number
<start>ai-matrix celebrity
#include <bits/stdc++.h>
#include <list>
using namespace std;
 
// Max # of persons in the party
#define N 8
 
// Person with 2 is celebrity
bool  MATRIX[N][N] = {{1, 0, 0, 0},
                      {0, 0, 0, 0},
                      {1, 1, 0, 1},
                      {0, 0, 0, 0}};
 
bool knows(int a, int b)
{
    return MATRIX[a][b];
}
 
// Returns -1 if celebrity is not present.
// If present, returns id  (value from 0 to n-1).
int findCelebrity(int n)
{
    // Handle trivial case of size = 2
 
    stack<int> s;
 
    int C; // Celebrity
 
    // Push everybody to stack
    for (int i=0; i<n; i++)
        s.push(i);
 
    // Extract top 2
    int A = s.top();
    s.pop();
    int B = s.top();
    s.pop();
 
    // Find a potential celevrity
    while (s.size() > 1)
    {
        if (knows(A, B))
        {
            A = s.top();
            s.pop();
        }
        else
        {
            B = s.top();
            s.pop();
        }
    }
 
    // Potential candidate?
    C = s.top();
    s.pop();
 
    // Last candidate was not examined, it leads
    // one excess comparison (optimize)
    if (knows(C, B))
        C = B;
 
    if (knows(C, A))
        C = A;
 
    // Check if C is actually a celebrity or not
    for (int i = 0; i < n; i++)
    {
        // If any person doesn't know 'a' or 'a'
        // doesn't know any person, return -1
        if ( (i != C) &&
                (knows(C, i) || !knows(i, C)) )
            return -1;
    }
 
    return C;
}
 
// Driver code
int main()
{
    int n = 4;
    int id = findCelebrity(n);
    id == -1 ? cout << "No celebrity" :
               cout << "Celebrity ID " << id;
    return 0;
}

<end>ai-matrix celebrity
<start>ai-jobs schedule two jubs  can run same time greedy
#include <bits/stdc++.h>
using namespace std;
 
bool checkJobs(int startin[], int endin[], int n)
{
    // making a pair of starting and ending time of job
    vector<pair<int, int> > a;
    for (int i = 0; i < n; i++)
        a.push_back(make_pair(startin[i], endin[i]));
 
    // sorting according to starting time of job
    sort(a.begin(), a.end());
 
    // starting first and second job simultaneously
    long long tv1 = a[0].second, tv2 = a[1].second;
 
    for (int i = 2; i < n; i++) {
         
        // Checking if starting time of next new job
        // is greater than ending time of currently
        // scheduled first job
        if (a[i].first >= tv1)
        {
            tv2 = tv1;
            tv1 = a[i].second;
        }
         
        // Checking if starting time of next new job
        // is greater than ending time of ocurrently
        // scheduled second job
        else if (a[i].first >= tv2)
            tv2 = a[i].second;
 
        else
            return false;
    }
    return true;
}
 
// Driver code
int main()
{
    int startin[] = { 1, 2, 4 }; // starting time of jobs
    int endin[] = { 2, 3, 5 }; // ending times of jobs
    int n = sizeof(startin) / sizeof(startin[0]);
    cout << checkJobs(startin, endin, n);
    return 0;
}
<end>ai-jobs schedule two jubs  can run same time greedy
<start>ai-Minimum Number of Platforms Required for a Railway/Bus Station
// Program to find minimum number of platforms required on a railway station
#include<iostream>
#include<algorithm>
using namespace std;
 
// Returns minimum number of platforms reqquired
int findPlatform(int arr[], int dep[], int n)
{
   // Sort arrival and departure arrays
   sort(arr, arr+n);
   sort(dep, dep+n);
 
   // plat_needed indicates number of platforms needed at a time
   int plat_needed = 1, result = 1;
   int i = 1, j = 0;
 
   // Similar to merge in merge sort to process all events in sorted order
   while (i < n && j < n)
   {
      // If next event in sorted order is arrival, increment count of
      // platforms needed
      if (arr[i] < dep[j])
      {
          plat_needed++;
          i++;
          if (plat_needed > result)  // Update result if needed
              result = plat_needed;
      }
      else // Else decrement count of platforms needed
      {
          plat_needed--;
          j++;
      }
   }
 
   return result;
}
 
// Driver program to test methods of graph class
int main()
{
    int arr[] = {900, 940, 950, 1100, 1500, 1800};
    int dep[] = {910, 1200, 1120, 1130, 1900, 2000};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Minimum Number of Platforms Required = "
         << findPlatform(arr, dep, n);
    return 0;
}
<end>ai-Minimum Number of Platforms Required for a Railway/Bus Station
<start>ai-Minimum Number of city Required for a trips
// Program to find minimum number of platforms required on a railway station
#include<iostream>
#include<algorithm>
using namespace std;
 
// Returns minimum number of platforms reqquired
int findPlatform(int arr[], int dep[], int n)
{
   // Sort arrival and departure arrays
   sort(arr, arr+n);
   sort(dep, dep+n);
 
   // plat_needed indicates number of platforms needed at a time
   int plat_needed = 1, result = 1;
   int i = 1, j = 0;
 
   // Similar to merge in merge sort to process all events in sorted order
   while (i < n && j < n)
   {
      // If next event in sorted order is arrival, increment count of
      // platforms needed
      if (arr[i] < dep[j])
      {
          plat_needed++;
          i++;
          if (plat_needed > result)  // Update result if needed
              result = plat_needed;
      }
      else // Else decrement count of platforms needed
      {
          plat_needed--;
          j++;
      }
   }
 
   return result;
}
 
// Driver program to test methods of graph class
int main()
{
    int arr[] = {900, 940, 950, 1100, 1500, 1800};
    int dep[] = {910, 1200, 1120, 1130, 1900, 2000};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "Minimum Number of Platforms Required = "
         << findPlatform(arr, dep, n);
    return 0;
}
<end>ai-Minimum Number of city Required for a trips
<start>ai-Buy Maximum Stocks if i stocks can be bought on i-th day
// CPP program to find maximum number of stocks that
// can be bought with given constraints.
#include <bits/stdc++.h>
using namespace std;
// Return the maximum stocks
int buyMaximumProducts(int n, int k, int price[])
{
    vector<pair<int, int> > v;
 
    // Making pair of product cost and number
    // of day..
    for (int i = 0; i < n; ++i) 
        v.push_back(make_pair(price[i], i + 1));    
 
    // Sorting the vector pair.
    sort(v.begin(), v.end());    
 
    // Calculating the maximum number of stock 
    // count.
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += min(v[i].second, k / v[i].first);
        k -= v[i].first * min(v[i].second, 
                               (k / v[i].first));
    }
 
    return ans;
}
 
// Driven Program
int main()
{
    int price[] = { 10, 7, 19 };
    int n = sizeof(price)/sizeof(price[0]);
    int k = 45;
 
    cout << buyMaximumProducts(n, k, price) << endl;
 
    return 0;
}
<end>ai-Buy Maximum Stocks if i stocks can be bought on i-th day
<start>ai-buy Maximum Stocks if i stocks can be bought on i-th day
// CPP program to find maximum number of stocks that
// can be bought with given constraints.
#include <bits/stdc++.h>
using namespace std;
// Return the maximum stocks
int buyMaximumProducts(int n, int k, int price[])
{
    vector<pair<int, int> > v;
 
    // Making pair of product cost and number
    // of day..
    for (int i = 0; i < n; ++i) 
        v.push_back(make_pair(price[i], i + 1));    
 
    // Sorting the vector pair.
    sort(v.begin(), v.end());    
 
    // Calculating the maximum number of stock 
    // count.
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        ans += min(v[i].second, k / v[i].first);
        k -= v[i].first * min(v[i].second, 
                               (k / v[i].first));
    }
 
    return ans;
}
 
// Driven Program
int main()
{
    int price[] = { 10, 7, 19 };
    int n = sizeof(price)/sizeof(price[0]);
    int k = 45;
 
    cout << buyMaximumProducts(n, k, price) << endl;
 
    return 0;
}
<end>ai-buy Maximum Stocks if i stocks can be bought on i-th day
<start>ai-find the minimum and maximum amount to buy all N candies
#include<bits/stdc++.h>
using namespace std;
 
// Function to find the minimum amount
// to buy all candies
int findMinimum(int arr[], int n, int k)
{
    int res = 0;
    for (int i=0; i<n ; i++)
    {
        // Buy current candy
        res += arr[i];
 
        // And take k candies for free
        // from the last
        n = n-k;
    }
    return res;
}
 
// Function to find the maximum amount
// to buy all candies
int findMaximum(int arr[], int n, int k)
{
    int res = 0, index = 0;
 
    for (int i=n-1; i>=index; i--)
    {
        // Buy candy with maximum amount
        res += arr[i];
 
        // And get k candies for free from
        // the starting
        index += k;
    }
    return res;
}
 
// Driver code
int main()
{
    int arr[] = {7, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 3;
    sort(arr, arr+n);
 
    cout << findMinimum(arr, n, k)<<" "
         << findMaximum(arr, n, k)<<endl;
    return 0;
}
<end>ai-find the minimum and maximum amount to buy all N candies
<start>ai-minimum and maximum amount to buy all N candies
#include<bits/stdc++.h>
using namespace std;
 
// Function to find the minimum amount
// to buy all candies
int findMinimum(int arr[], int n, int k)
{
    int res = 0;
    for (int i=0; i<n ; i++)
    {
        // Buy current candy
        res += arr[i];
 
        // And take k candies for free
        // from the last
        n = n-k;
    }
    return res;
}
 
// Function to find the maximum amount
// to buy all candies
int findMaximum(int arr[], int n, int k)
{
    int res = 0, index = 0;
 
    for (int i=n-1; i>=index; i--)
    {
        // Buy candy with maximum amount
        res += arr[i];
 
        // And get k candies for free from
        // the starting
        index += k;
    }
    return res;
}
 
// Driver code
int main()
{
    int arr[] = {7, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 3;
    sort(arr, arr+n);
 
    cout << findMinimum(arr, n, k)<<" "
         << findMaximum(arr, n, k)<<endl;
    return 0;
}
<end>ai-minimum and maximum amount to buy all N candies
<start>ai-string distance
#include<bits/stdc++.h>
using namespace std;
 int levenshtein_distance(const std::string &s1, const std::string &s2)
{
	// To change the type this function manipulates and returns, change
	// the return type and the types of the two variables below.
	int s1len = s1.size();
	int s2len = s2.size();
	
	auto column_start = (decltype(s1len))1;
	
	auto column = new decltype(s1len)[s1len + 1];
	std::iota(column + column_start, column + s1len + 1, column_start);
	
	for (auto x = column_start; x <= s2len; x++) {
		column[0] = x;
		auto last_diagonal = x - column_start;
		for (auto y = column_start; y <= s1len; y++) {
			auto old_diagonal = column[y];
			auto possibilities = {
				column[y] + 1,
				column[y - 1] + 1,
				last_diagonal + (s1[y - 1] == s2[x - 1]? 0 : 1)
			};
			column[y] = std::min(possibilities);
			last_diagonal = old_diagonal;
		}
	}
	auto result = column[s1len];
	delete[] column;
	return result;
}
int main()
{
	cout<<levenshtein_distance("dow","daws");
}
<end>ai-string distance
<start>ai-string convert to string
#include<bits/stdc++.h>
using namespace std;
 int levenshtein_distance(const std::string &s1, const std::string &s2)
{
	// To change the type this function manipulates and returns, change
	// the return type and the types of the two variables below.
	int s1len = s1.size();
	int s2len = s2.size();
	
	auto column_start = (decltype(s1len))1;
	
	auto column = new decltype(s1len)[s1len + 1];
	std::iota(column + column_start, column + s1len + 1, column_start);
	
	for (auto x = column_start; x <= s2len; x++) {
		column[0] = x;
		auto last_diagonal = x - column_start;
		for (auto y = column_start; y <= s1len; y++) {
			auto old_diagonal = column[y];
			auto possibilities = {
				column[y] + 1,
				column[y - 1] + 1,
				last_diagonal + (s1[y - 1] == s2[x - 1]? 0 : 1)
			};
			column[y] = std::min(possibilities);
			last_diagonal = old_diagonal;
		}
	}
	auto result = column[s1len];
	delete[] column;
	return result;
}
int main()
{
	cout<<levenshtein_distance("dow","daws");
}
<end>ai-string convert to string
<start>ai-graph adj list
#include<bits/stdc++.h>
using namespace std;
 
    vector <int> adj[10];

    int main()
    {
        int x, y, nodes, edges;
        cin >> nodes;       //Number of nodes
        cin >> edges;       //Number of edges
        for(int i = 0;i < edges;++i)
        {
                cin >> x >> y;
            adj[x].push_back(y);        //Insert y in adjacency list of x
         }
    for(int i = 1;i <= nodes;++i)
    {   
            cout << "Adjacency list of node " << i << ": ";
        for(int j = 0;j < adj[i].size();++j)
            {
            if(j == adj[i].size() - 1)
                    cout << adj[i][j] << endl;
            else
                cout << adj[i][j] << " --> ";
    }
    }
    return 0;
    }
<end>ai-graph adj list
<start>ai-graph dijkstra minimum distance from vertex

#include <stdio.h>
#include <limits.h>
#define V 9
int minDistance(int dist[], bool sptSet[])
{
   // Initialize min value
   int min = INT_MAX, min_index;
  
   for (int v = 0; v < V; v++)
     if (sptSet[v] == false && dist[v] <= min)
         min = dist[v], min_index = v;
  
   return min_index;
}
  
// A utility function to print the constructed distance array
int printSolution(int dist[], int n)
{
   printf("Vertex   Distance from Sourcen");
   for (int i = 0; i < V; i++)
      printf("%d tt %dn", i, dist[i]);
}
  
// Funtion that implements Dijkstra's single source shortest path algorithm
// for a graph represented using adjacency matrix representation
void dijkstra(int graph[V][V], int src)
{
     int dist[V];     // The output array.  dist[i] will hold the shortest
                      // distance from src to i
  
     bool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest
                     // path tree or shortest distance from src to i is finalized
  
     // Initialize all distances as INFINITE and stpSet[] as false
     for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;
  
     // Distance of source vertex from itself is always 0
     dist[src] = 0;
  
     // Find shortest path for all vertices
     for (int count = 0; count < V-1; count++)
     {
       // Pick the minimum distance vertex from the set of vertices not
       // yet processed. u is always equal to src in first iteration.
       int u = minDistance(dist, sptSet);
  
       // Mark the picked vertex as processed
       sptSet[u] = true;
  
       // Update dist value of the adjacent vertices of the picked vertex.
       for (int v = 0; v < V; v++)
  
         // Update dist[v] only if is not in sptSet, there is an edge from 
         // u to v, and total weight of path from src to  v through u is 
         // smaller than current value of dist[v]
         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX 
                                       && dist[u]+graph[u][v] < dist[v])
            dist[v] = dist[u] + graph[u][v];
     }
  
     // print the constructed distance array
     printSolution(dist, V);
}
  
// driver program to test above function
int main()
{
   /* Let us create the example graph discussed above */
   int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},
                      {4, 0, 8, 0, 0, 0, 0, 11, 0},
                      {0, 8, 0, 7, 0, 4, 0, 0, 2},
                      {0, 0, 7, 0, 9, 14, 0, 0, 0},
                      {0, 0, 0, 9, 0, 10, 0, 0, 0},
                      {0, 0, 4, 14, 10, 0, 2, 0, 0},
                      {0, 0, 0, 0, 0, 2, 0, 1, 6},
                      {8, 11, 0, 0, 0, 0, 1, 0, 7},
                      {0, 0, 2, 0, 0, 0, 6, 7, 0}
                     };
  
    dijkstra(graph, 0);
  
    return 0;
}
<end>ai-graph dijkstra minimum distance from vertex
<start>ai-graph minimum distance from vertex with dijkstra

#include <stdio.h>
#include <limits.h>
#define V 9
int minDistance(int dist[], bool sptSet[])
{
   // Initialize min value
   int min = INT_MAX, min_index;
  
   for (int v = 0; v < V; v++)
     if (sptSet[v] == false && dist[v] <= min)
         min = dist[v], min_index = v;
  
   return min_index;
}
  
// A utility function to print the constructed distance array
int printSolution(int dist[], int n)
{
   printf("Vertex   Distance from Sourcen");
   for (int i = 0; i < V; i++)
      printf("%d tt %dn", i, dist[i]);
}
  
// Funtion that implements Dijkstra's single source shortest path algorithm
// for a graph represented using adjacency matrix representation
void dijkstra(int graph[V][V], int src)
{
     int dist[V];     // The output array.  dist[i] will hold the shortest
                      // distance from src to i
  
     bool sptSet[V]; // sptSet[i] will true if vertex i is included in shortest
                     // path tree or shortest distance from src to i is finalized
  
     // Initialize all distances as INFINITE and stpSet[] as false
     for (int i = 0; i < V; i++)
        dist[i] = INT_MAX, sptSet[i] = false;
  
     // Distance of source vertex from itself is always 0
     dist[src] = 0;
  
     // Find shortest path for all vertices
     for (int count = 0; count < V-1; count++)
     {
       // Pick the minimum distance vertex from the set of vertices not
       // yet processed. u is always equal to src in first iteration.
       int u = minDistance(dist, sptSet);
  
       // Mark the picked vertex as processed
       sptSet[u] = true;
  
       // Update dist value of the adjacent vertices of the picked vertex.
       for (int v = 0; v < V; v++)
  
         // Update dist[v] only if is not in sptSet, there is an edge from 
         // u to v, and total weight of path from src to  v through u is 
         // smaller than current value of dist[v]
         if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX 
                                       && dist[u]+graph[u][v] < dist[v])
            dist[v] = dist[u] + graph[u][v];
     }
  
     // print the constructed distance array
     printSolution(dist, V);
}
  
// driver program to test above function
int main()
{
   /* Let us create the example graph discussed above */
   int graph[V][V] = {{0, 4, 0, 0, 0, 0, 0, 8, 0},
                      {4, 0, 8, 0, 0, 0, 0, 11, 0},
                      {0, 8, 0, 7, 0, 4, 0, 0, 2},
                      {0, 0, 7, 0, 9, 14, 0, 0, 0},
                      {0, 0, 0, 9, 0, 10, 0, 0, 0},
                      {0, 0, 4, 14, 10, 0, 2, 0, 0},
                      {0, 0, 0, 0, 0, 2, 0, 1, 6},
                      {8, 11, 0, 0, 0, 0, 1, 0, 7},
                      {0, 0, 2, 0, 0, 0, 6, 7, 0}
                     };
  
    dijkstra(graph, 0);
  
    return 0;
}


<end>ai-graph minimum distance from vertex with dijkstra
<start>ai-Job Scheduling  weighted story algorithm 
Weighted Job Scheduling
Given N jobs where every job is represented by following three elements of it.

Start Time
Finish Time
Profit or Value Associated
Find the maximum profit subset of jobs such that no two jobs in the subset overlap.

Example:

Input: Number of Jobs n = 4
       Job Details {Start Time, Finish Time, Profit}
       Job 1:  {1, 2, 50} 
       Job 2:  {3, 5, 20}
       Job 3:  {6, 19, 100}
       Job 4:  {2, 100, 200}
Output: The maximum profit is 250.
We can get the maximum profit by scheduling jobs 1 and 4.
Note that there is longer schedules possible Jobs 1, 2 and 3 
but the profit with this schedule is 20+50+100 which is less than 250. 
First sort jobs according to finish time.
2) Now apply following recursive process. 
   // Here arr[] is array of n jobs
   findMaximumProfit(arr[], n)
   {
     a) if (n == 1) return arr[0];
     b) Return the maximum of following two profits.
         (i) Maximum profit by excluding current job, i.e., 
             findMaximumProfit(arr, n-1)
         (ii) Maximum profit by including the current job            
   }

How to find the profit including current job?
The idea is to find the latest job before the current job (in 
sorted array) that doesn't conflict with current job 'arr[n-1]'. 
Once we find such a job, we recur for all jobs till that job and
add profit of current job to result.
In the above example, "job 1" is the latest non-conflicting
for "job 4" and "job 2" is the latest non-conflicting for "job 3".
 
<end>ai-Job Scheduling  weighted story algorithm 
<start>ai-job Scheduling  weighted code greedy
// C++ program for weighted job scheduling using Naive Recursive Method
#include <iostream>
#include <algorithm>
using namespace std;
 
// A job has start time, finish time and profit.
struct Job
{
    int start, finish, profit;
};
 
// A utility function that is used for sorting events
// according to finish time
bool jobComparataor(Job s1, Job s2)
{
    return (s1.finish < s2.finish);
}
 
// Find the latest job (in sorted array) that doesn't
// conflict with the job[i]. If there is no compatible job,
// then it returns -1.
int latestNonConflict(Job arr[], int i)
{
    for (int j=i-1; j>=0; j--)
    {
        if (arr[j].finish <= arr[i-1].start)
            return j;
    }
    return -1;
}
 
// A recursive function that returns the maximum possible
// profit from given array of jobs.  The array of jobs must
// be sorted according to finish time.
int findMaxProfitRec(Job arr[], int n)
{
    // Base case
    if (n == 1) return arr[n-1].profit;
 
    // Find profit when current job is inclueded
    int inclProf = arr[n-1].profit;
    int i = latestNonConflict(arr, n);
    if (i != -1)
      inclProf += findMaxProfitRec(arr, i+1);
 
    // Find profit when current job is excluded
    int exclProf = findMaxProfitRec(arr, n-1);
 
    return max(inclProf,  exclProf);
}
 
// The main function that returns the maximum possible
// profit from given array of jobs
int findMaxProfit(Job arr[], int n)
{
    // Sort jobs according to finish time
    sort(arr, arr+n, jobComparataor);
 
    return findMaxProfitRec(arr, n);
}
 
// Driver program
int main()
{
    Job arr[] = {{3, 10, 20}, {1, 2, 50}, {6, 19, 100}, {2, 100, 200}};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout << "The optimal profit is " << findMaxProfit(arr, n);
    return 0;
}
<end>ai-job Scheduling  weighted code greedy
<start>ai-job Scheduling  weighted story algorithm 
Input: Number of Jobs n = 4
       Job Details {Start Time, Finish Time, Profit}
       Job 1:  {1, 2, 50} 
       Job 2:  {3, 5, 20}
       Job 3:  {6, 19, 100}
       Job 4:  {2, 100, 200}
Output: The maximum profit is 250.
We can get the maximum profit by scheduling jobs 1 and 4.
Note that there is longer schedules possible Jobs 1, 2 and 3 
but the profit with this schedule is 20+50+100 which is less than 250. 
1) First sort jobs according to finish time.
2) Now apply following recursive process. 
   // Here arr[] is array of n jobs
   findMaximumProfit(arr[], n)
   {
     a) if (n == 1) return arr[0];
     b) Return the maximum of following two profits.
         (i) Maximum profit by excluding current job, i.e., 
             findMaximumProfit(arr, n-1)
         (ii) Maximum profit by including the current job            
   }

How to find the profit including current job?
The idea is to find the latest job before the current job (in 
sorted array) that doesn't conflict with current job 'arr[n-1]'. 
Once we find such a job, we recur for all jobs till that job and
add profit of current job to result.
In the above example, "job 1" is the latest non-conflicting
for "job 4" and "job 2" is the latest non-conflicting for "job 3".
<end>ai-job Scheduling  weighted story algorithm 
<start>ai-permutation two array sum equal
/*Permute two arrays such that sum of every pair is greater or equal to K
Given two arrays of equal size n and an integer k.
 The task is to permute both arrays such that sum of their corresponding element 
 is greater than or equal to k i.e a[i] + b[i] >= k. The task is print “Yes” 
 if any such permutation exists, otherwise print “No”.
 Input : a[] = {2, 1, 3}, 
        b[] = { 7, 8, 9 }, 
        k = 10. 
Output : Yes
Permutation  a[] = { 1, 2, 3 } and b[] = { 9, 8, 7 } 
satisfied the condition a[i] + b[i] >= K.

Input : a[] = {1, 2, 2, 1}, 
        b[] = { 3, 3, 3, 4 }, 
        k = 5. 
Output : No
 */
 #include<bits/stdc++.h>
using namespace std;
 
// Check wheather any permutation exists which
// satisfy the condition.
bool isPossible(int a[], int b[], int n, int k)
{
    // Sort the array a[] in decreasing order.
    sort(a, a + n);
 
    // Sort the array b[] in increasing order.
    sort(b, b + n, greater<int>());
 
    // Checking condition on each index.
    for (int i = 0; i < n; i++)
        if (a[i] + b[i] < k)
            return false;
 
    return true;
}
 
// Driven Program
int main()
{
    int a[] = { 2, 1, 3 };
    int b[] = { 7, 8, 9 };
    int k = 10;
    int n = sizeof(a)/sizeof(a[0]);
 
    isPossible(a, b, n, k) ? cout << "Yes" :
                             cout << "No";
    return 0;
}
<end>ai-permutation two array sum equal
<start>ai-array tw permutation is equal
/*Permute two arrays such that sum of every pair is greater or equal to K
Given two arrays of equal size n and an integer k.
 The task is to permute both arrays such that sum of their corresponding element 
 is greater than or equal to k i.e a[i] + b[i] >= k. The task is print “Yes” 
 if any such permutation exists, otherwise print “No”.
 Input : a[] = {2, 1, 3}, 
        b[] = { 7, 8, 9 }, 
        k = 10. 
Output : Yes
Permutation  a[] = { 1, 2, 3 } and b[] = { 9, 8, 7 } 
satisfied the condition a[i] + b[i] >= K.

Input : a[] = {1, 2, 2, 1}, 
        b[] = { 3, 3, 3, 4 }, 
        k = 5. 
Output : No
 */
 #include<bits/stdc++.h>
using namespace std;
 
// Check wheather any permutation exists which
// satisfy the condition.
bool isPossible(int a[], int b[], int n, int k)
{
    // Sort the array a[] in decreasing order.
    sort(a, a + n);
 
    // Sort the array b[] in increasing order.
    sort(b, b + n, greater<int>());
 
    // Checking condition on each index.
    for (int i = 0; i < n; i++)
        if (a[i] + b[i] < k)
            return false;
 
    return true;
}
 
// Driven Program
int main()
{
    int a[] = { 2, 1, 3 };
    int b[] = { 7, 8, 9 };
    int k = 10;
    int n = sizeof(a)/sizeof(a[0]);
 
    isPossible(a, b, n, k) ? cout << "Yes" :
                             cout << "No";
    return 0;
}
<end>ai-array tw permutation is equal
<start>ai-story midhouse
-coding
-girl
-unity
<end>ai-story midhouse
<start>ai-story coding 1
-when coding which problems used n codejam
-practice on problem 
-practice on hackerearth
-practice on topcoder
-dance on code
<end>ai-story coding 1
<start>ai-xor two binary string
#include<bits/stdc++.h>
 using namespace std;
class NetworkXOneTimePad
{
public:
     
    string  xor1(string word,string key)
    {
    	string p=key;

       for(int i = 0; i<key.length(); i++)
 {
    p[i] = ((word[i]-'0') ^ (key[i]-'0')) + '0'; 
 }
        return p;

    }
};
int main()
{
    NetworkXOneTimePad a;
    cout<<a.xor1("100","110");
    
    return 0;
}


<end>ai-xor two binary string
<start>ai-vector find item
if ( std::find(vector.begin(), vector.end(), item) != vector.end() )

<end>ai-vector find item
<start>ai-bfs zero one
// C++ program to implement single source
// shortest path for a Binary Graph
#include<bits/stdc++.h>
using namespace std;
 
/* no.of vertices */
#define V 9
 
// a structure to represent edges
struct node
{
    // two variable one denote the node
    // and other the weight
    int to, weight;
};
 
// vector to store edges
vector <node> edges[V];
 
// Prints shortest distance from given source to
// every other vertex
void zeroOneBFS(int src)
{
    // Initialize distances from given source
    int dist[V];
    for (int i=0; i<V; i++)
        dist[i] = INT_MAX;
 
    // double ende queue to do BFS.
    deque <int> Q;
    dist[src] = 0;
    Q.push_back(src);
 
    while (!Q.empty())
    {
        int v = Q.front();
        Q.pop_front();
 
        for (int i=0; i<edges[v].size(); i++)
        {
            // checking for the optimal distance
            if (dist[edges[v][i].to] > dist[v] + edges[v][i].weight)
            {
                dist[edges[v][i].to] = dist[v] + edges[v][i].weight;
 
                // Put 0 weight edges to front and 1 weight
                // edges to back so that vertices are processed
                // in increasing order of weights.
                if (edges[v][i].weight == 0)
                    Q.push_front(edges[v][i].to);
                else
                    Q.push_back(edges[v][i].to);
            }
        }
    }
 
    // printing the shortest distances
    for (int i=0; i<V; i++)
        cout << dist[i] << " ";
}
 
void addEdge(int u, int v, int wt)
{
   edges[u].push_back({v, wt});
   edges[v].push_back({u, wt});
}
 
// Driver function
int main()
{
    addEdge(0, 1, 1);
    addEdge(0, 2, 1);
    addEdge(1, 2, 0);
    addEdge(1, 2, 0);
    addEdge(1, 3, 0);
    addEdge(2, 3, 1);
   
    int src = 0;//source node
    zeroOneBFS(src);
    return 0;
}


<end>ai-bfs zero one
<start>ai-bfs zero one
// C++ program to implement single source
// shortest path for a Binary Graph
#include<bits/stdc++.h>
using namespace std;
 
/* no.of vertices */
#define V 9
 
// a structure to represent edges
struct node
{
    // two variable one denote the node
    // and other the weight
    int to, weight;
};
 
// vector to store edges
vector <node> edges[V];
 
// Prints shortest distance from given source to
// every other vertex
void zeroOneBFS(int src)
{
    // Initialize distances from given source
    int dist[V];
    for (int i=0; i<V; i++)
        dist[i] = INT_MAX;
 
    // double ende queue to do BFS.
    deque <int> Q;
    dist[src] = 0;
    Q.push_back(src);
 
    while (!Q.empty())
    {
        int v = Q.front();
        Q.pop_front();
 
        for (int i=0; i<edges[v].size(); i++)
        {
            // checking for the optimal distance
            if (dist[edges[v][i].to] > dist[v] + edges[v][i].weight)
            {
                dist[edges[v][i].to] = dist[v] + edges[v][i].weight;
 
                // Put 0 weight edges to front and 1 weight
                // edges to back so that vertices are processed
                // in increasing order of weights.
                if (edges[v][i].weight == 0)
                    Q.push_front(edges[v][i].to);
                else
                    Q.push_back(edges[v][i].to);
            }
        }
    }
 
    // printing the shortest distances
    for (int i=0; i<V; i++)
        cout << dist[i] << " ";
}
 
void addEdge(int u, int v, int wt)
{
   edges[u].push_back({v, wt});
   edges[v].push_back({u, wt});
}
 
// Driver function
int main()
{
    addEdge(0, 1, 1);
    addEdge(0, 2, 1);
    addEdge(1, 2, 0);
    addEdge(1, 2, 0);
    addEdge(1, 3, 0);
    addEdge(2, 3, 1);
   
    int src = 0;//source node
    zeroOneBFS(src);
    return 0;
}


<end>ai-bfs zero one
<start>ai-array max occurence
#include <bits/stdc++.h>
#define ll long long int
using namespace std;
int main()
{
  
    ll t;
    cin>>t;
    ll p;int max1,c;
    c=0;
    max1=0;c=0;
    for(int i=0;i<t;i++)
    {
    cin>>p;
    
  
    {
    if(p>max1)
    {
    	max1=p;
    	c=1;
    }
    else if(p==max1)
    c++;
    }
    
   }
    cout<<c;
    return 0;
}



 

<end>ai-array max occurence
<start>ai-string count char
#include <bits/stdc++.h>
#define ll long long int
using namespace std;
string uniqs (string s)
 {
 string result="";
 int c=1;
 for(int i=0;i<s.length();i++)
  {
  	if(s[i]==s[i+1])
  	c++;
  	else
  	{
   		 cout<<s[i]<<":"<<c<<endl;
   		if(c%2!=0)
   		result+=s[i];
  		c=1;
    }
  }
   
  return result;
}
int main()
{
   string s;
   cin>>s;
   int i=0;
   string result=uniqs(s);
   if(result!="")
   cout<<result;
   else
   cout<<"Empty String";
    
}



 

<end>ai-string count char
<start>ai-string unicode
#include <bits/stdc++.h>
#define ll long long int
using namespace std;
 
int main()
{
   string s;
   cin>>s;
   int c=1;
   for(int i=0;i<s.length();i++)
   {
   	if((s[i]>=65)&&(s[i]<=90))
   	c++;
    }
    cout<<c;
}



 

<end>ai-string unicode
<start>ai-string map count
 

#include <bits/stdc++.h>
#define ll long long int
using namespace std;
 
int  distinct(string s,int a1,int b1)
{
	 map<char,int> a;
	 for(int i=0;i<s.length();i++)
	 if((s[i]!=s[a1])||(s[i]!=s[b1]))
	 
	 a[s[i]]++;
	 for(int i=0;i<s.size();i++)
	
 
	  cout<<a[s[i]]<<":"<<s[i]<<endl;
      cout<<a.size()<<endl;
}
 
int main()
{
   string s;
   cin>>s;
   int i=0;
  distinct(s,0,1);
 
   
    
}



 







<end>ai-string map count
<start>ai-string encrypt letter
#include <bits/stdc++.h>
using namespace std;
void encrypt( std::string &iostr , int key )
{
	key %= 26;
	 
	int ch;

	for( auto &it : iostr )
	{
		bool isup=false;
		if((tolower(it)<='z')&&(tolower(it)>='a'))
		{
		ch = tolower(it) + key;
		if(tolower(it)!=it)
		 isup=true;
		if( ch > 'z' )
			ch -= 26;
		if(isup)
		 ch=toupper(ch);	
		it = ch;
       }
	}
}
int main()
{
	int t,k ;
	cin>>t;
	string source;
	char s[t];
	 for(int i=0;i<t;i++)
	{
		cin>>s[i];
		source+=s[i];
    }
	cin>>k;
	cout << source << endl;
	encrypt( source , k );
		cout << source << std::endl;
}



<end>ai-string encrypt letter
<start>ai-string find all sub string
#include <iostream>
#include <string>

using namespace std;

int main() {
    string org("SOS");
    string s;
    cin >> s;

    int r = 0;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] != org[i%3]) r++;
    }
    cout << r << endl;
    return 0;
}
<end>ai-string find all sub string
<start>ai-string separate cpp
#include <set>
#include <map>
#include <cmath>
#include <deque>
#include <cctype>
#include <cstdio>
#include <limits>
#include <string>
#include <vector>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <exception>

using namespace std;

vector<long long> separate(string line, long long num) {
    vector<long long> res;
    string head = to_string(num);
    if (line.substr(0, head.size()) != head) {
        return res;
    }
    line = line.substr(head.size());
    if (line.empty()) {
        res.push_back(num);
        return res;
    }
    vector<long long> remains = separate(line, num + 1);
    if (remains.empty()) {
        return res;
    }
    res.push_back(num);
    res.insert(res.end(), remains.begin(), remains.end());
    return res;
}

vector<long long> separate(string line) {
    vector<long long> res;
    if (line.empty() || line[0] == '0') {
        return res;
    }
    for (int i = 1; i < line.size(); i++) {
        double num_d = stod(line.substr(0, i));
        if (num_d > numeric_limits<long long>::max()) {
            break;
        }
        long long num = stoll(line.substr(0, i));
        vector<long long> nums = separate(line, num);
        for(int i=0;i<nums.size();i++)
        cout<<nums[i]<<" ";
        if (!nums.empty()) {
            return nums;
        }
    }
    return res;
}

int main() {
    int T;
    cin >> T;
    cin.ignore();
    for (int t = 0; t < T; t++) {
        string line;
        getline(cin, line);
        vector<long long> nums = separate(line);
        if (nums.empty()) {
            cout << "NO" << endl;
        } else {
            cout << "YES " << nums[0] << endl;
        }
    }
    return 0;
}
<end>ai-string separate cpp
<start>ai-string separate numbers cpp
#include <set>
#include <map>
#include <cmath>
#include <deque>
#include <cctype>
#include <cstdio>
#include <limits>
#include <string>
#include <vector>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <algorithm>
#include <exception>

using namespace std;

vector<long long> separate(string line, long long num) {
    vector<long long> res;
    string head = to_string(num);
    if (line.substr(0, head.size()) != head) {
        return res;
    }
    line = line.substr(head.size());
    if (line.empty()) {
        res.push_back(num);
        return res;
    }
    vector<long long> remains = separate(line, num + 1);
    if (remains.empty()) {
        return res;
    }
    res.push_back(num);
    res.insert(res.end(), remains.begin(), remains.end());
    return res;
}

vector<long long> separate(string line) {
    vector<long long> res;
    if (line.empty() || line[0] == '0') {
        return res;
    }
    for (int i = 1; i < line.size(); i++) {
        double num_d = stod(line.substr(0, i));
        if (num_d > numeric_limits<long long>::max()) {
            break;
        }
        long long num = stoll(line.substr(0, i));
        vector<long long> nums = separate(line, num);
        for(int i=0;i<nums.size();i++)
        cout<<nums[i]<<" ";
        if (!nums.empty()) {
            return nums;
        }
    }
    return res;
}

int main() {
    int T;
    cin >> T;
    cin.ignore();
    for (int t = 0; t < T; t++) {
        string line;
        getline(cin, line);
        vector<long long> nums = separate(line);
        if (nums.empty()) {
            cout << "NO" << endl;
        } else {
            cout << "YES " << nums[0] << endl;
        }
    }
    return 0;
}
<end>ai-string separate numbers cpp
<start>ai-string start end compare
#include<bits/stdc++.h>
using namespace std;

int main() {
  string s;
   int t;
  cin>>t;
  while(t--)
  {
  cin>>s;
  int end=s.length()-1;
  bool isfun=true;
   int i=0;
  while(i<s.length()-1)
  {
  	
 if(abs(s[i]-s[i+1])!=abs(s[s.length()-i-1]-s[s.length()-(i+1)-1]))
 isfun=false;
  	 i++;
  }
  if(isfun)
  cout<<"Funny"<<endl;
  else
  cout<<"Not Funny"<<endl;
}
    return 0;
}
<end>ai-string start end compare
<start>ai-string remove duplicate
#include<bits/stdc++.h>
using namespace std;
string removeduplicate(string s)
{
	string result;
	for(int i=0;i<s.length();i++)
	if ( std::find(result.begin(), result.end(), s[i]) == result.end() )
	result.push_back(s[i]);
	return result;
}
int main() {
	map<char,int> a;
		 
	  int co=0;
	string s;
	string al="abcdefghijklmnopqrstuvwxyz";
	int t;
	cin>>t;
	int i1=0;
	while(i1++<t)
	{
	cin>>s;
	s=removeduplicate(s);
 
	for(int i=0;i<s.length();i++)
	a[s[i]]++;
     }
   for(int i=0;i<al.length();i++)
      if(a[al[i]]==t)
      co++;
      cout<<co; 
}





<end>ai-string remove duplicate
<start>ai-string operator integer compare
#include<bits/stdc++.h>
using namespace std;
 
    bool compare_cstring(string a, string b)
{
	if(a.size() == b.size())
        return a<b;
    return a.size() < b.size();
 
}
    
int main() {
	 long long int t;
	 cin>>t;
    vector<string> s(t);

    for(long long int i=0;i<t;i++)
    cin>>s[i];
    sort(s.begin(),s.end(),compare_cstring);
    cout<<"--------"<<endl;
    for(long long int i=0;i<t;i++)
     cout<<s[i]<<endl;     	 
}



 

<end>ai-string operator integer compare
<start>ai-insertion sort simulator
 
 
#include <bits/stdc++.h>
using namespace std;
void insertionSort(int N, int arr[]) {
  int i, j, value;

  for (i = 1; i < N; i++) {
    value = arr[i];
    j = i - 1;

    while (j >= 0 && value < arr[j]) {
      arr[j + 1] = arr[j];
      j = j - 1;
    }
    arr[j + 1] = value;
     for (j = 0; j < N; j++) {
    cout<< arr[j]<<" ";
  }

 
    cout<<endl;
  }
}

int main(void) {
  // Read input
  int N;
  scanf("%d", & N);

  int arr[N], i;
  for (i = 0; i < N; i++) {
    scanf("%d", & arr[i]);
  }

  // Sorting
  insertionSort(N, arr);

  return 0;
}

<end>ai-insertion sort simulator
<start>ai-quicksort left right
#include <bits/stdc++.h>
using namespace std;
using namespace std;
int main()
{
	int t;
	cin>>t;
	int pivot=0;
	vector<int> a(t),left,right;
	for(int i=0;i<t;i++)
	{
	 cin>>a[i];
	 if(i==0)
	 pivot=a[i];
	 else
	 {
	 	if(a[i]>pivot)
	 	left.push_back(a[i]);
	 	
	 	if(a[i]<pivot)
	 	right.push_back(a[i]);
     }
    }
    for(int i=0;i<right.size();i++)
    cout<<right[i]<<" ";
    cout<<pivot<<" ";
     for(int i=0;i<left.size();i++)
    cout<<left[i]<<" ";
	return 0;
	
}
<end>ai-quicksort left right
<start>ai-count sort char
// C Program for counting sort
#include <stdio.h>
#include <string.h>
#define RANGE 255
 
// The main function that sort the given string arr[] in
// alphabatical order
void countSort(char arr[])
{
    // The output character array that will have sorted arr
    char output[strlen(arr)];
 
    // Create a count array to store count of inidividul
    // characters and initialize count array as 0
    int count[RANGE + 1], i;
    memset(count, 0, sizeof(count));
 
    // Store count of each character
    for(i = 0; arr[i]; ++i)
        ++count[arr[i]];
 
    // Change count[i] so that count[i] now contains actual
    // position of this character in output array
    for (i = 1; i <= RANGE; ++i)
        count[i] += count[i-1];
 
    // Build the output character array
    for (i = 0; arr[i]; ++i)
    {
        output[count[arr[i]]-1] = arr[i];
        --count[arr[i]];
    }
 
    // Copy the output array to arr, so that arr now
    // contains sorted characters
    for (i = 0; arr[i]; ++i)
        arr[i] = output[i];
}
 
// Driver program to test above function
int main()
{
    char arr[] = "geeksforgeeks";//"applepp";
 
    countSort(arr);
 
    printf("Sorted character array is %sn", arr);
    return 0;
}
<end>ai-count sort char
<start>ai-sort dance ball
#include <bits/stdc++.h>

using namespace std;

const int N = 1e4 + 4;

int s[N];

int main() {
  time_t startt = clock();
  int tt;
  scanf("%d", &tt);
  for (int tc = 1; tc <= tt; tc++) {
    int e, n;
    scanf("%d %d", &e, &n);
    for (int i = 0; i < n; i++) {
      scanf("%d", s+i);
    }
    sort(s, s+n);
    int h = 0;
    for (int i = 0, j = n-1; i <= j; i++) {
      if (s[i] < e) {
        e -= s[i];
        h++;
      }
      else if (h > 0 && i < j) {
        e += s[j]-s[i];
        j--;
      }
    }
    printf("Case #%d: %d\n", tc, h);
    cerr << "~ #" << tc << " done! time : " << (double)(clock()-startt) * 1000/CLOCKS_PER_SEC << " ms" << endl;
  }
  return 0;
}



<end>ai-sort dance ball
<start>ai-array compare count
#include <bits/stdc++.h>
 
using namespace std;
 
int main() {
  int n,p,m;
  cin>>n;
  map<int,int> a,b;;
  for(int i=0;i<n;i++)
  {
  	cin>>p;
  	a[p]++;
  }
  cin>>m;
  for(int i=0;i<m;i++)
  {
  	cin>>p;
  	b[p]++;
  }
    for(int i=0;i<a.size();i++)
  {
  	if(a[i])
    if(a[i]!=b[i])
  	cout<<i<<" ";
  }
    return 0;
}



<end>ai-array compare count
<start>ai-quicksort sum left right
#include <iostream>
#include <vector>
#include <string>

using namespace std;
 
int main() {

     int numCases;
    cin >> numCases;
    if( numCases > 10 || numCases < 1 ) {
        cout << "Error with input." << endl;
        return 1;
    }

     vector< string > results;
    for( int i = 0; i < numCases; i++ ) {
        
        vector< int > data;
        int numElements;
        cin >> numElements;
        int totalSum = 0;
        for( int i = 0; i < numElements; i++ ) {
            int element;
            cin >> element;
            data.push_back( element );
            totalSum += element;
        } 

        
        int leftSum = 0;
        int rightSum = totalSum;
        int flag = 1;
        for( vector< int >::iterator it = data.begin(); it != data.end(); it++ ) {
            if( it == data.begin() ) {
                leftSum = 0;
            } else {
                leftSum = leftSum + *( it - 1 );
            }
            rightSum -= ( *it );                
            
            if( leftSum == rightSum ) {
                results.push_back( "YES" );
                flag = 0;
            }
        }
        if( flag == 1 ) results.push_back( "NO" );
        
    }  
 
    for( vector< string >:: iterator it = results.begin(); it != results.end(); it++ ) {
        cout << (*it) << endl;
    } 
}
<end>ai-quicksort sum left right
<start>ai-print all sub array
#include <bits/stdc++.h>
using namespace std;
 
// To find sum of all subarrya
int findSum(int arr[], int n,int m)
{
    // Sum all array elements
    int sum = 0;
    for (int i = 0; i < n; i++)
        sum += arr[i]%m;
 
    // Result is sum * 2^(n-1)
    return sum * (1 << (n - 1));
}
 
// Driver program to test findSum()
int main()
{
	int t,n,m;
	cin>>t;
	int max=0;
	while(t--)
	{
     int n,m;
     cin>>n>>m;
     int sum=0;
     int arr[n];
      for(int i=0;i<n;i++)
       cin>>arr[i]; 
for (int i = 0; i < n; i++) {
   for (int j = n-1; j >= i; j--) {
      for (int k=i; k<=j; k++) {
         {
         	cout << "A[" << k << "] ";
        }
         
         sum+=arr[k];
     }
     if(max<sum%m)
     max=sum%m;
     sum=0;
   }
}
cout <<endl<<max<<endl;
    }
    return 0;
}
<end>ai-print all sub array
<start>ai-print subarray sum all
#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <set>
using namespace std;


int main() {
    long long n , m , x , sum = 0 , result = 0 ;
    set<long long> map ;
    int q ;
    cin >> q ;
    while(q){
        cin >> n >> m ;
        for(int i = 0 ; i < n ; i++){
            cin >> x ;
            sum = (sum + x) % m ;
            auto it = map.upper_bound(sum) ;
            if(it != map.end()){
                result = max(result , (sum - *it + m) % m) ;
            }
            result = max(result , sum) ;
            map.insert(sum) ;
        }
        cout << result << endl ;
        q-- ;
        sum = 0 ;
        result = 0 ;
        map.clear() ;
    }
    return 0;
}
<end>ai-print subarray sum all
<start>ai-remove same char sequence
#include<bits/stdc++.h>
using namespace std;
 bool allisunpair(string p,string &s)
{
	
	for(int i=0;i<s.length();i++)
	if(s[i]==s[i+1])
	{
		     	s.erase(s.begin()+i+1);
		
 	s.erase(s.begin()+i);
    
	return false;
    }
	return true;
}
int main()
{
    
   string s;
   cin>>s;
   string r=s;
   
  while(!allisunpair(s,r))
  s=s;
  if(r=="")
  cout<<"Empty String";
  else
   cout<<r;
   return 0;
}


<end>ai-remove same char sequence
<start>ai-boost sample
#include <iostream>
#include <boost/random/random_device.hpp>
#include <boost/random.hpp>
#include <boost/multiprecision/cpp_int.hpp>
#include<bits/stdc++.h>
using namespace std;
namespace mp = boost::multiprecision;
using namespace boost::multiprecision;
int main()
{
	cpp_int d = 1200000;
	pow(2, 2);
	mp::cpp_int x = mp::pow(mp::cpp_int(2), 1024);
	std::cout << x << "\n";

	boost::random::random_device gen;
	boost::random::uniform_int_distribution<mp::cpp_int> ui(1, x);

	for (unsigned i = 0; i < 10; ++i) {
		mp::cpp_int y = ui(gen);
		std::cout << y << "\n";
	}
	cout << "hehe";
	system("pause");

}
<end>ai-boost sample
<start>ai-boost sample
dddd
<end>ai-boost sample
<start>ai-float large number claculate
#include <boost/random/random_device.hpp>
#include <boost/random.hpp>
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/multiprecision/cpp_dec_float.hpp>


#include<bits/stdc++.h>
using namespace std;
namespace mp = boost::multiprecision;
using namespace boost::multiprecision;
int main()
{
 
	map<cpp_int,cpp_int> d;
	cpp_dec_float_100 a,b = 2;

	cin >> a >> b;
	cout <<fixed<< setprecision(7)<< (a*b);
	system("pause");

}


<end>ai-float large number claculate
<start>#include <bits/stdc++.h>

using namespace std;
bool ispal(string s)
{	
xxxx
	if (s == string(s.rbegin(), s.rend())) 
		return true	 ;
		  	return false;

}
int main()
{
   	string s,s1;		int t;
	cin>>t;
	while(t--)
	{
			cin>>s>>s1;
		 if(ispal(s+s1)||(ispal(s1+s)))
			 cout<<"YES";
		 else
			 cout<<"NO";
	}
	 ;
    return 0;
}








#include <bits/stdc++.h>

using namespace std;
bool ispal(string s)
{	
xxxx
	if (s == string(s.rbegin(), s.rend())) 
		return true	 ;
		  	return false;

}
int main()
{
   	string s,s1;		int t;
	cin>>t;
	while(t--)
	{
			cin>>s>>s1;
		 if(ispal(s+s1)||(ispal(s1+s)))
			 cout<<"YES";
		 else
			 cout<<"NO";
	}
	 ;
    return 0;
}








<end>#include <bits/stdc++.h>

using namespace std;
bool ispal(string s)
{	
xxxx
	if (s == string(s.rbegin(), s.rend())) 
		return true	 ;
		  	return false;

}
int main()
{
   	string s,s1;		int t;
	cin>>t;
	while(t--)
	{
			cin>>s>>s1;
		 if(ispal(s+s1)||(ispal(s1+s)))
			 cout<<"YES";
		 else
			 cout<<"NO";
	}
	 ;
    return 0;
}








<start>sss
sss
<end>sss
<start>ai-xxnew
dddd
<end>ai-xxnew
<start>ai-dawoodnew5
dawood5
<end>ai-dawoodnew5
<start>ai-boost with random
#include <iostream>
 
#include <boost/multiprecision/cpp_int.hpp>
#include<boost/multiprecision/cpp_int.hpp>
#include<boost/random.hpp>
#include<bits/stdc++.h>
using namespace std;
namespace mp = boost::multiprecision;
using namespace boost::multiprecision;
int main()
{
	cpp_int d = 1200000;
	pow(2, 2);
	cpp_int x = pow(mp::cpp_int(2), 1024);
	typedef boost::mt19937 RNGType;
	RNGType rng;
	boost::uniform_int<> one_to_six(1, 6);
	boost::variate_generator< RNGType, boost::uniform_int<> >
		dice(rng, one_to_six);
	for (int i = 0; i < 6; i++) {
		int n = dice();
		cout << n << endl;
	}
	std::cout << x << "\n";
	 
	 

	 
	cout << "hehe";
	system("pause");

}
<end>ai-boost with random
<start>ai-forsample
for(int i=0;i<12;i++)
<end>ai-forsample
<start>ai-newdialog1
welcome to new dialog
<end>ai-newdialog1
<start>ai-marioc
#include <stdio.h>
#include <cs50.h>
int main (void) 
{
int height;
int h=1;
do 
{
printf ("height:");
height=get_int();
} 
while (height<0||height>23);
int i=0;
int t=height;
for (i=0; i<height; i++)
{
int s=0;
for (s=0; s<t-1; s++)
{
    printf(" ");
}
int n=0;
for (n=0; n<h+1; n++)
{
    printf("#");
}
h++;
t--;
    printf("\n");
}
}
<end>ai-marioc
<start>ai-initialsmore
#include <stdio.h>
#include <ctype.h>
#include <cs50.h>
#include <string.h>
  


int main (void) 
{
    string s = get_string();
    if (s != NULL)
    {
      
            if (s[0] != ' ') 
            {
                printf("%c", toupper(s[0]));
            }
            
        
    for (int i = 1, n = strlen(s); i < n; i++)
        {     
            if (s[i-1] == ' ' && s[i] != ' ') 
            {
                printf("%c", toupper(s[i]));
            }
        }
    printf("\n");
    }
    
}
<end>ai-initialsmore
<start>ai-caesarc
#include <cs50.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

string get_plain_text(void);
int cast_argv_to_int(string);
void print_error(void);
void cipher_loop(int , string);
void print_error(void);
void print_cipher(int, int, int);

#define UPPER_OFFSET 65
#define LOWER_OFFSET 97


int main(int argc, string argv[])
{
    if(argc == 2)
    {
        int k = cast_argv_to_int(argv[1]);
        string plain_text = get_plain_text();
        printf("ciphertext: ");
        cipher_loop(k, plain_text);
        printf("\n");
        
        return 0;
    }
    else
    {
        print_error();
        return 1;
    }
}

void print_error(void)
{
    printf("Wrong argument count entered\n");
}

string get_plain_text()
{
    string plain_text;
    
    do
    {
        printf("plaintext:");
        plain_text = get_string();
    }
    while(plain_text == NULL);
    
    return plain_text;
}

int cast_argv_to_int(string arg)
{
    int num = atoi(arg);
    
    if(num >= 0)
    {
        return num;
    }
    else
    {
        printf("Changed negative argument to positive \n");
        return num * -1;
    }
}

void cipher_loop(int offset, string user_input)
{
    for(int i=0, length=strlen(user_input); i<length; i++)
        {
            int string_index = (int)user_input[i];
            int string_index_plus_key = string_index + offset;
            
          
            if(isupper(string_index))
            {
                int upper_cipher_int = string_index_plus_key;
                
                print_cipher(upper_cipher_int, string_index_plus_key, UPPER_OFFSET);
                
            }
            else if(islower(string_index))
            {
                int lower_cipher_int = string_index_plus_key;
                
                print_cipher(lower_cipher_int, string_index_plus_key, LOWER_OFFSET);
            }
            else
            {
                printf("%c", string_index);
            }
        }
}

void print_cipher(int cipher, int index_key, int offset)
{
    cipher = index_key - offset;
    
    if(cipher > 25)
    {
        cipher = ((cipher)%26) + offset;
        printf("%c", cipher);
    }
    else
    {
        printf("%c", cipher + offset);
    }
}
<end>ai-caesarc
<start>ai-divisior sum digits
//divisor sum  odd digits of number
//12= 1 2 3 4 6 12
//12=1+0+3+0+0+1=5
#include <bits/stdc++.h>
using namespace std;
void verify(int n, int l, int r){
    assert(n >= l && n <= r);
}
const int N = 1000002;
int get_sum(int n){
	int ans = 0;
	while(n){
		if((n % 10) % 2 == 1)	ans += n % 10;
		n /= 10;
	}
	return ans;
}
int ans[N];
 
int main(){
	for(int i=1;i<N;i++){
		int temp = get_sum(i);
		for(int j=i;j<N;j+=i)
			ans[j] += temp;
	}
	int q;
	scanf("%d", &q);
	verify(q, 1, 1000*1000);
	while(q--){
		int n;
		scanf("%d", &n);
		verify(n, 1, 1000*1000);
		printf("%d\n", ans[n]);
	}
    return 0;
}
<end>ai-divisior sum digits
<start>ai-string to int atoi
 const char *str1 = "42";
    const char *str2 = "3.14159";
    const char *str3 = "31337 geek";
    
    int num1 = atoi(str1);
    int num2 = atoi(str2);
    int num3 = atoi(str3);
   
    cout << "atoi(\"" << str1 
              << "\") is " << num1 << '\n';
    cout << "atoi(\"" << str2 
              << "\") is " << num2 << '\n';
    cout << "atoi(\"" << str3 
              << "\") is " << num3 << '\n';
    
<end>ai-string to int atoi
<start>string

<end>string
<start>ai-hi?
hi dawood
<end>ai-hi?
<start>ai-cs50 pset 4 recover

#include <stdio.h>
#include <stdint.h>


const int BLOCK_SIZE = 512;

int main(int argc, char *argv[])
{

    if (argc != 2)
    {
        fprintf(stderr, "Usage: ./recover image\n");
        return 1;
    }
    
 
    FILE *infile = fopen(argv[1], "r");
    if (infile == NULL)
    {
        fprintf(stderr, "Could not open file\n");
        return 2;
    }
    

    uint8_t buffer[512];
    
   
    int jpeg_counter = 0;
  

   
    FILE *img = NULL;
    

    while(fread(buffer, BLOCK_SIZE, 1, infile))
    {
     
        if (buffer[0] == 0xff && buffer[1] == 0xd8 && buffer[2] == 0xff
            && (buffer[3] & 0xf0) == 0xe0)
        {
           
            if (img != NULL)
            {
             
                fclose(img);
            }
            
      
            char filename[8];
            sprintf(filename, "%03i.jpg", jpeg_counter);
            img = fopen(filename, "w");
            jpeg_counter++;
        }
        
       
        if (img != NULL)
        {
            fwrite(buffer, BLOCK_SIZE, 1, img);
        }
    }
    
 
    if (img != NULL)
    {
        fclose(img);
    }
    

    fclose(infile);
  
    return 0;
    
}
<end>ai-cs50 pset 4 recover
<start>ai-swapcode
void swap(int *a, int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
<end>ai-swapcode
<start>ai-int *a?
int *a declares a pointer to an int with the name a, and later using *a means we are going to the location a points to, and retrieving the value there (also known as dereferencing a pointer).
<end>ai-int *a?
<start>ai-node cs50
typedef struct node
{
    int n;
    struct node *next;
}
node;
<end>ai-node cs50
<start>ai-node search cs50
bool search(int n, node *list)
{
    node *ptr = list;
    while (ptr != NULL)
    {
        if (ptr->n == n)
        {
            return true;
        }
        ptr = ptr->next;
    }
    return false;
}
<end>ai-node search cs50
<start>ai-what is Stack?
Now we have a struct stack, with an array of ints called numbers with size CAPACITY we can define elsewhere. And it also will have a property called size, since we won’t always have as many items in our stack as its capacity
<end>ai-what is Stack?
<start>ai-Struct cs50?
typedef struct
{
    int numbers[CAPACITY];
    int size;
}
stack;
<end>ai-Struct cs50?
<start>ai-Queue
typedef struct
{
    int front;
    int *numbers;
    int size;
}
queue;
<end>ai-Queue
<start>ai-Queue
typedef struct
{
    int front;
    int *numbers;
    int size;
}
queue;
<end>ai-Queue
<start>ai-hi doctor?
hi dawood whatis going on?
<end>ai-hi doctor?
<start>ai-what is your name?
my name is dawood abbaspour 34 from iran tabriz
<end>ai-what is your name?
<start>ai-what is your proplem1?
#include<bits/stdc++.h>
using namespace std;
int main()
{
return 0;
}
<end>ai-what is your proplem1?
<start>ai-hi dawooddd
welcome
<end>ai-hi dawooddd
<start>ai-node cs50 advanced
typedef struct node
{
    char symbol;
    float frequency;
    struct node *left;
    struct node *right;
}
node;
<end>ai-node cs50 advanced
<start>ai-swap python
x=5
y=7
x,y=y,x
print(x,y)
<end>ai-swap python
<start>ai-printdq
print("dq234")
<end>ai-printdq
<start>msdnwebsite
https://msdn.microsoft.com/en-us/library/system.diagnostics.process.getcurrentprocess(v=vs.110).aspx
<end>msdnwebsite
<start>msdnwebsite
https://msdn.microsoft.com/en-us/library/system.diagnostics.process.getcurrentprocess(v=vs.110).aspx
<end>msdnwebsite
<start>googlesite
https://www.google.com/
<end>googlesite
<start>newdaw
dawood
<end>newdaw
<start>ai-googlesite
https://www.google.com/
<end>ai-googlesite
<start>ai-allcpp1
 #include<bits/stdc++.h>
using namespace std;
int main()
{
    int i=12;
    i+=12;
    cout<<i<<"hiy";
    return 0;
    
}
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int i=12;
    i+=12;
    cout<<"hello world";
    return 0;
    
}

  
<end>ai-allcpp1
<start>ai-w22
 welcome
test
all 
code

<end>ai-w22
<start>ai-wr
wwwrer
<end>ai-wr
<start>ai-caesar python
import cs50
import sys

def main():
    if len(sys.argv) != 2:
        print("You should provide cmd line arguments!")
        exit(1)
    
    key = int(sys.argv[1])
    translated = []
    message = cs50.get_string()
    for symbol in message:
        if symbol.isalpha():
            translated.append(caesar(symbol, key))
        else:
            translated.append(symbol)
                
    print("".join(translated))
    exit(0)

def caesar(char, key):
    if char.isupper():
        return chr(((ord(char) - 65 + key) % 26) + 65)
    else:
        return chr(((ord(char) - 97 + key) % 26) + 97)
        
if __name__ == "__main__":
    main()
<end>ai-caesar python
<start>ai-print hello world c
#include <stdio.h>

int main(void)
{
    printf("Hello, world!\n");
}
<end>ai-print hello world c
<start>ai-print hello world in c
print hello world in c
<end>ai-print hello world in c
<start>ai-caesar python
import cs50
import sys

def main():
    if len(sys.argv) != 2:
        print("You should provide cmd line arguments!")
        exit(1)
    
    key = int(sys.argv[1])
    translated = []
    message = cs50.get_string()
    for symbol in message:
        if symbol.isalpha():
            translated.append(caesa(symbol, key))
        else:
            translated.append(symbol)
                
    print("".join(translated))
    exit(0)

def caesar(char, key):
    if char.isupper():
        return chr(((ord(char) - 65 + key) % 26) + 65)
    else:
        return chr(((ord(char) - 97 + key) % 26) + 97)
        
if __name__ == "__main__":
    main()
<end>ai-caesar python
<start>ai-caesar in python
 import cs50
import sys

def main():
    if len(sys.argv) != 2:
        print("You should provide cmd line arguments!")
        exit(1)
    
    key = int(sys.argv[1])
    translated = []
    message = cs50.get_string()
    for symbol in message:
        if symbol.isalpha():
            translated.append(caesar(symbol, key))
        else:
            translated.append(symbol)
                
    print("".join(translated))
    exit(0)

def caesar(char, key):
    if char.isupper():
        return chr(((ord(char) - 65 + key) % 26) + 65)
    else:
        return chr(((ord(char) - 97 + key) % 26) + 97)
        
if __name__ == "__main__":
    main()
import cs50
import sys

def main():
    if len(sys.argv) != 2:
        print("You should provide cmd line arguments!")
        exit(1)
    
    key = int(sys.argv[1])
    translated = []
    message = cs50.get_string()
    for symbol in message:
        if symbol.isalpha():
            translated.append(caesa(symbol, key))
        else:
            translated.append(symbol)
                
    print("".join(translated))
    exit(0)

def caesar(char, key):
    if char.isupper():
        return chr(((ord(char) - 65 + key) % 26) + 65)
    else:
        return chr(((ord(char) - 97 + key) % 26) + 97)
        
if __name__ == "__main__":
    main()

<end>ai-caesar in python
<start>ai-gready in python
import cs50

def main():
    while True:
        print("O hai! How much change is owed?")
        amount = cs50.get_float()
        if amount >= 0:
            break
    
    number_of_coins = 0
    cents = int(round(amount * 100))
    
    number_of_coins += cents // 25
    cents %= 25
    
    number_of_coins += cents // 10
    cents %= 10
    
    number_of_coins += cents // 5
    cents %= 5
    
    number_of_coins += cents
    
    print("{}".format(number_of_coins))
    
if __name__ == "__main__":
    main()
<end>ai-gready in python
<start>ai-greedy in python
 import cs50

def main():
    while True:
        print("O hai! How much change is owed?")
        amount = cs50.get_float()
        if amount >= 0:
            break
    
    number_of_coins = 0
    cents = int(round(amount * 100))
    
    number_of_coins += cents // 25
    cents %= 25
    
    number_of_coins += cents // 10
    cents %= 10
    
    number_of_coins += cents // 5
    cents %= 5
    
    number_of_coins += cents
    
    print("{}".format(number_of_coins))
    
if __name__ == "__main__":
    main()

<end>ai-greedy in python
